// Script: converte-classes-java-em-txt-unico (v3)
// Data de criação do arquivo de saída: 2025-05-27 22:27:17

// Estrutura de diretórios do projeto:
src/
    main/
        java/
            br/
                com/
                    fiap/
                        gs/
                            gsapi/
                                client/
                                config/
                                controller/
                                dto/
                                    geocoding/
                                    request/
                                    response/
                                    viacep/
                                exception/
                                mapper/
                                model/
                                repository/
                                service/
                                    search/
                                specification/
        resources/
            static/
            templates/
    outros/
        bd-oracle-gs/
        teste-postman/
    test/
        java/
            br/
                com/
                    fiap/
                        gs/
                            gsapi/

// Arquivos encontrados (FQN => caminho relativo):
// br.com.fiap.gs.gsapi.GsapiApplication => main\java\br\com\fiap\gs\gsapi\GsapiApplication.java
// br.com.fiap.gs.gsapi.client.NominatimClient => main\java\br\com\fiap\gs\gsapi\client\NominatimClient.java
// br.com.fiap.gs.gsapi.client.ViaCepClient => main\java\br\com\fiap\gs\gsapi\client\ViaCepClient.java
// br.com.fiap.gs.gsapi.config.AppConfig => main\java\br\com\fiap\gs\gsapi\config\AppConfig.java
// br.com.fiap.gs.gsapi.config.CorsConfig => main\java\br\com\fiap\gs\gsapi\config\CorsConfig.java
// br.com.fiap.gs.gsapi.config.OpenApiConfig => main\java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java
// br.com.fiap.gs.gsapi.config.SwaggerBrowserLauncher => main\java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java
// br.com.fiap.gs.gsapi.controller.ClienteController => main\java\br\com\fiap\gs\gsapi\controller\ClienteController.java
// br.com.fiap.gs.gsapi.controller.ContatoController => main\java\br\com\fiap\gs\gsapi\controller\ContatoController.java
// br.com.fiap.gs.gsapi.controller.EnderecoController => main\java\br\com\fiap\gs\gsapi\controller\EnderecoController.java
// br.com.fiap.gs.gsapi.dto.geocoding.NominatimResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\geocoding\NominatimResponseDTO.java
// br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.EonetEventosRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\EonetEventosRequestDTO.java
// br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.EonetEventoResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\EonetEventoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.viacep.ViaCepResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\viacep\ViaCepResponseDTO.java
// br.com.fiap.gs.gsapi.exception.GlobalExceptionHandler => main\java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java
// br.com.fiap.gs.gsapi.exception.ResourceNotFoundException => main\java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java
// br.com.fiap.gs.gsapi.mapper.ClienteMapper => main\java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java
// br.com.fiap.gs.gsapi.mapper.ContatoMapper => main\java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java
// br.com.fiap.gs.gsapi.mapper.EnderecoMapper => main\java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java
// br.com.fiap.gs.gsapi.mapper.EonetEventoMapper => main\java\br\com\fiap\gs\gsapi\mapper\EonetEventoMapper.java
// br.com.fiap.gs.gsapi.model.Cliente => main\java\br\com\fiap\gs\gsapi\model\Cliente.java
// br.com.fiap.gs.gsapi.model.Contato => main\java\br\com\fiap\gs\gsapi\model\Contato.java
// br.com.fiap.gs.gsapi.model.Endereco => main\java\br\com\fiap\gs\gsapi\model\Endereco.java
// br.com.fiap.gs.gsapi.model.EonetEventos => main\java\br\com\fiap\gs\gsapi\model\EonetEventos.java
// br.com.fiap.gs.gsapi.repository.ClienteRepository => main\java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java
// br.com.fiap.gs.gsapi.repository.ContatoRepository => main\java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java
// br.com.fiap.gs.gsapi.repository.EnderecoRepository => main\java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java
// br.com.fiap.gs.gsapi.repository.EonetEventoRepository => main\java\br\com\fiap\gs\gsapi\repository\EonetEventoRepository.java
// br.com.fiap.gs.gsapi.service.ClienteService => main\java\br\com\fiap\gs\gsapi\service\ClienteService.java
// br.com.fiap.gs.gsapi.service.ContatoService => main\java\br\com\fiap\gs\gsapi\service\ContatoService.java
// br.com.fiap.gs.gsapi.service.EnderecoGeocodingService => main\java\br\com\fiap\gs\gsapi\service\EnderecoGeocodingService.java
// br.com.fiap.gs.gsapi.service.EnderecoService => main\java\br\com\fiap\gs\gsapi\service\EnderecoService.java
// br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria => main\java\br\com\fiap\gs\gsapi\service\search\ClienteSearchCriteria.java
// br.com.fiap.gs.gsapi.specification.ClienteSpecification => main\java\br\com\fiap\gs\gsapi\specification\ClienteSpecification.java
// br.com.fiap.gs.gsapi.specification.ContatoSpecification => main\java\br\com\fiap\gs\gsapi\specification\ContatoSpecification.java
// br.com.fiap.gs.gsapi.specification.EnderecoSpecification => main\java\br\com\fiap\gs\gsapi\specification\EnderecoSpecification.java

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\GsapiApplication.java   |   package br.com.fiap.gs.gsapi   |   class GsapiApplication
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching; // Import para habilitar o cache
// import org.springframework.data.jpa.repository.config.EnableJpaAuditing; // Opcional: para auditoria

@SpringBootApplication
@EnableCaching // Habilita o suporte a cache do Spring
// @EnableJpaAuditing // Descomente se for usar auditoria JPA (ex: @CreatedDate, @LastModifiedDate)
public class GsapiApplication {

	public static void main(String[] args) {
		SpringApplication.run(GsapiApplication.class, args);
	}

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\client\NominatimClient.java   |   package br.com.fiap.gs.gsapi.client   |   class NominatimClient
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.client
package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.geocoding.NominatimResponseDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Flux;
import reactor.util.retry.Retry;

import java.time.Duration;

@Component
public class NominatimClient {

    private static final Logger logger = LoggerFactory.getLogger(NominatimClient.class);
    private final WebClient webClient;

    // Configure no application.properties: app.geocoding.user-agent=SuaApp/1.0 (seu.email@example.com)
    // É OBRIGATÓRIO para Nominatim.
    @Value("${app.geocoding.user-agent:GSAPIDefaultApp/1.0 (fiap.gs@example.com)}")
    private String userAgent;

    private static final String NOMINATIM_BASE_URL = "https://nominatim.openstreetmap.org";

    @Autowired
    public NominatimClient(WebClient.Builder webClientBuilder) {
        // O User-Agent será definido no momento da requisição para garantir que o valor de @Value seja injetado
        this.webClient = webClientBuilder.baseUrl(NOMINATIM_BASE_URL).build();
    }

    public Flux<NominatimResponseDTO> buscarCoordenadasPorEndereco(String logradouro, String numero, String bairro, String cidade, String estado, String cep) {
        // Monta a query string de forma mais estruturada.
        // A API do Nominatim é sensível à formatação da query.
        // Usar parâmetros separados pode ser mais eficaz do que uma string única 'q'.
        logger.info("Buscando coordenadas no Nominatim para: Rua='{}', Num='{}', Bairro='{}', Cidade='{}', Estado='{}', CEP='{}'",
                logradouro, numero, bairro, cidade, estado, cep);
        logger.info("Usando User-Agent para Nominatim: {}", this.userAgent);

        return this.webClient.get()
                .uri(uriBuilder -> uriBuilder.path("/search")
                        // Parâmetros de busca estruturada
                        .queryParam("street", (numero != null && !numero.trim().isEmpty() ? numero + " " : "") + logradouro)
                        .queryParam("city", cidade)
                        .queryParam("county", bairro) // 'county' é frequentemente usado para bairro/distrito no OSM
                        .queryParam("state", estado)
                        .queryParam("country", "Brazil")
                        .queryParam("postalcode", cep)
                        // Parâmetros de controle
                        .queryParam("format", "jsonv2") // jsonv2 é geralmente mais consistente
                        .queryParam("addressdetails", "1")
                        .queryParam("limit", "1") // Pega o resultado mais relevante
                        .build())
                .header(HttpHeaders.USER_AGENT, this.userAgent) // Adiciona o User-Agent aqui
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToFlux(NominatimResponseDTO.class)
                .timeout(Duration.ofSeconds(10)) // Timeout para a requisição
                .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).maxBackoff(Duration.ofSeconds(5))
                        .filter(throwable -> throwable instanceof WebClientResponseException.TooManyRequests) // Exemplo de retry para 429
                        .doBeforeRetry(retrySignal -> logger.warn("Nominatim API rate limit atingido, tentando novamente... Tentativa {}", retrySignal.totalRetries() + 1))
                )
                .doOnError(WebClientResponseException.class, error ->
                        logger.error("Erro HTTP ao chamar Nominatim API: Status {}, Resposta: {}", error.getStatusCode(), error.getResponseBodyAsString(), error))
                .doOnError(error -> !(error instanceof WebClientResponseException), error -> // Loga outros erros
                        logger.error("Erro inesperado ao chamar Nominatim API: {}", error.getMessage(), error))
                .onErrorResume(error -> {
                    logger.warn("Falha ao buscar coordenadas no Nominatim após tentativas. Retornando vazio.");
                    return Flux.empty(); // Retorna vazio em caso de erro final para não quebrar o fluxo
                });
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\client\ViaCepClient.java   |   package br.com.fiap.gs.gsapi.client   |   class ViaCepClient
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.client
package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.viacep.ViaCepResponseDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

@Component
public class ViaCepClient {

    private static final Logger logger = LoggerFactory.getLogger(ViaCepClient.class);
    private final RestTemplate restTemplate;
    private static final String VIA_CEP_URL = "https://viacep.com.br/ws/{cep}/json/";

    @Autowired
    public ViaCepClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public ViaCepResponseDTO buscarEnderecoPorCep(String cep) {
        if (cep == null || cep.trim().isEmpty()) {
            logger.warn("Tentativa de buscar CEP nulo ou vazio.");
            return null;
        }
        // Remove caracteres não numéricos do CEP
        String cepNumerico = cep.replaceAll("[^0-9]", "");
        if (cepNumerico.length() != 8) {
            logger.warn("CEP inválido fornecido: '{}'. CEP numérico processado: '{}'. Deve conter 8 dígitos.", cep, cepNumerico);
            return null; // Ou lançar uma exceção de argumento inválido
        }

        try {
            logger.info("Buscando endereço na API ViaCEP para o CEP: {}", cepNumerico);
            ViaCepResponseDTO response = restTemplate.getForObject(VIA_CEP_URL, ViaCepResponseDTO.class, cepNumerico);

            if (response != null && response.isErro()) {
                logger.warn("CEP {} não encontrado ou inválido na API ViaCEP (retornou erro=true).", cepNumerico);
                return null; // CEP não encontrado pela API
            }
            if (response != null && response.getCep() == null) { // Outra forma de ViaCEP indicar erro para CEPs inexistentes
                logger.warn("CEP {} não resultou em dados válidos na API ViaCEP (campos nulos).", cepNumerico);
                return null;
            }

            logger.info("Endereço encontrado para o CEP {}: {}", cepNumerico, (response != null && response.getLocalidade() != null) ? response.getLocalidade() : "N/A");
            return response;
        } catch (HttpClientErrorException e) {
            logger.error("Erro HTTP ao chamar a API ViaCEP para o CEP {}: Status {} - Resposta: {}", cepNumerico, e.getStatusCode(), e.getResponseBodyAsString(), e);
            return null;
        } catch (RestClientException e) {
            logger.error("Erro de conectividade ou outro erro do RestClient ao chamar a API ViaCEP para o CEP {}: {}", cepNumerico, e.getMessage(), e);
            return null;
        } catch (Exception e) {
            logger.error("Erro inesperado ao processar a resposta da API ViaCEP para o CEP {}: {}", cepNumerico, e.getMessage(), e);
            return null;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\AppConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class AppConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.Duration;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        // Configura o RestTemplate com um timeout e um interceptor para logging (opcional)
        // BufferingClientHttpRequestFactory é útil se você quiser logar o corpo da requisição/resposta
        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
        requestFactory.setConnectTimeout((int) Duration.ofSeconds(10).toMillis());
        requestFactory.setReadTimeout((int) Duration.ofSeconds(10).toMillis());

        return builder
                .requestFactory(() -> new BufferingClientHttpRequestFactory(requestFactory))
                // .additionalInterceptors(new LoggingClientHttpRequestInterceptor()) // Crie esta classe se quiser logar
                .build();
    }

    @Bean
    public WebClient.Builder webClientBuilder() {
        // Configurações padrão para o WebClient.Builder, se necessário
        // Ex: timeouts, codecs, etc. podem ser configurados aqui globalmente
        // ou no momento da construção do WebClient específico.
        return WebClient.builder();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\CorsConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class CorsConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;
import java.util.List;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    private final Environment environment;

    // Origens permitidas para produção (leia do application.properties)
    // Ex: cors.production.allowed.origins=https://meufrontend.com,https://outrofrontend.com
    @Value("${cors.production.allowed.origins:}")
    private String[] productionAllowedOrigins;

    // Origens permitidas para desenvolvimento (pode ser fixo ou também configurável)
    @Value("${cors.development.allowed.origins:http://localhost:3000,http://localhost:3001,http://127.0.0.1:3000,http://127.0.0.1:3001}")
    private String[] developmentAllowedOrigins;

    public CorsConfig(Environment environment) {
        this.environment = environment;
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
        String[] allowedOriginsToUse;

        if (isProdProfileActive) {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÇÃO DE CORS PARA PRODUÇÃO <<<<<<<<<<");
            if (productionAllowedOrigins != null && productionAllowedOrigins.length > 0 &&
                    Arrays.stream(productionAllowedOrigins).anyMatch(origin -> origin != null && !origin.trim().isEmpty())) {
                allowedOriginsToUse = Arrays.stream(productionAllowedOrigins)
                        .filter(origin -> origin != null && !origin.trim().isEmpty())
                        .toArray(String[]::new);
                System.out.println("Allowed Origins (prod): " + String.join(", ", allowedOriginsToUse));
            } else {
                System.out.println("WARN: Nenhuma origem de produção VÁLIDA configurada para CORS (cors.production.allowed.origins). CORS estará altamente restrito.");
                // Por segurança, defina um fallback restrito ou nenhuma origem se não configurado
                allowedOriginsToUse = new String[]{}; // Ou uma URL de fallback muito específica
            }
        } else {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÇÃO DE CORS PARA DESENVOLVIMENTO/PADRÃO <<<<<<<<<<");
            allowedOriginsToUse = developmentAllowedOrigins;
            System.out.println("Allowed Origins (dev/default): " + String.join(", ", allowedOriginsToUse));
        }

        if (allowedOriginsToUse.length > 0) {
            registry.addMapping("/**") // Aplica a todas as rotas da API
                    .allowedOrigins(allowedOriginsToUse)
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD")
                    .allowedHeaders("*") // Permite todos os cabeçalhos
                    .allowCredentials(true) // Importante se você usar cookies ou autenticação baseada em sessão
                    .maxAge(3600); // Tempo em segundos que o resultado de uma requisição pre-flight OPTIONS pode ser cacheado
        } else if (isProdProfileActive) {
            // Se em produção e nenhuma origem válida foi configurada, não adicione nenhum mapping de CORS
            // ou adicione um muito restritivo para bloquear por padrão.
            System.out.println("WARN: CORS em produção está bloqueado pois nenhuma origem válida foi configurada.");
        }
    }

    // Alternativamente, você pode usar um CorsFilter Bean se preferir uma configuração mais programática
    // ou se precisar de mais controle sobre a ordem dos filtros.
    // @Bean
    // public CorsFilter corsFilter() {
    //     UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    //     CorsConfiguration config = new CorsConfiguration();
    //     config.setAllowCredentials(true);
    //
    //     boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
    //     if (isProdProfileActive && productionAllowedOrigins != null && productionAllowedOrigins.length > 0) {
    //         config.setAllowedOrigins(Arrays.asList(productionAllowedOrigins));
    //     } else {
    //         config.setAllowedOrigins(Arrays.asList(developmentAllowedOrigins)); // Ou use allowedOriginPatterns
    //     }
    //
    //     config.addAllowedHeader("*");
    //     config.addAllowedMethod("*"); // GET, POST, PUT, DELETE, etc.
    //     source.registerCorsConfiguration("/**", config);
    //     return new CorsFilter(source);
    // }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class OpenApiConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

/**
 * Classe de configuração do Springdoc OpenAPI para definir as informações detalhadas da API.
 * Isso inclui título, versão, descrição, informações de contato e licença,
 * que serão exibidos na interface do Swagger UI.
 */
@Configuration
public class OpenApiConfig {

    private static final Logger log = LoggerFactory.getLogger(OpenApiConfig.class);

    // Você pode injetar valores do application.properties se precisar
    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    @Bean
    public OpenAPI customOpenAPI() {
        log.info("🔧 Configuração personalizada do OpenAPI inicializada.");

        // Constrói a URL base do servidor dinamicamente
        String serverUrl = "http://localhost:" + serverPort + (contextPath != null ? contextPath : "");

        return new OpenAPI()
                .info(new Info()
                        .title("GS API - Alertas de Desastres Naturais") // Título da sua API
                        .version("v1.0.0") // Versão da sua API
                        .description("""
                                **API RESTful para o Global Solution FIAP 2025**

                                Esta API fornece funcionalidades para consulta de informações sobre desastres naturais
                                e gerenciamento de alertas para usuários com base em sua localização.
                                Integração com a API EONET da NASA e serviços de geolocalização.

                                **Funcionalidades Principais:**
                                - Cadastro e gerenciamento de clientes e seus endereços.
                                - Consulta de eventos de desastres naturais (via EONET).
                                - Associação de eventos de desastres a endereços de clientes.
                                - Visualização de alertas em mapas (a ser implementado no frontend).
                                """)
                        .contact(new Contact()
                                .name("Equipe GS API") // Nome da sua equipe ou seu nome
                                .email("seu-email@fiap.com.br") // Seu email de contato
                                .url("https://github.com/seu-usuario/gs-api-repo") // URL do seu projeto no GitHub
                        )
                        .license(new License()
                                .name("Apache 2.0") // Ou a licença que você escolher
                                .url("https://www.apache.org/licenses/LICENSE-2.0.html")
                        )
                )
                .servers(List.of(
                        new Server().url(serverUrl).description("Servidor Local de Desenvolvimento")
                        // Você pode adicionar outros servidores aqui (ex: homologação, produção)
                        // new Server().url("https://api.seudominio.com/gsapi").description("Servidor de Produção")
                ));
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java   |   package br.com.fiap.gs.gsapi.config   |   class SwaggerBrowserLauncher
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.EventListener;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Componente para abrir automaticamente o Swagger UI no navegador
 * quando a aplicação inicia em um perfil de desenvolvimento.
 */
@Configuration
@Profile("dev") // Ativa este componente apenas quando o perfil 'dev' estiver ativo
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    // O caminho padrão do Swagger UI é geralmente /swagger-ui/index.html ou /swagger-ui.html
    // Verifique a propriedade springdoc.swagger-ui.path se você a customizou
    @Value("${springdoc.swagger-ui.path:/swagger-ui.html}")
    private String swaggerUiPath;

    @Value("${app.launch-swagger-on-startup:true}") // Propriedade customizada para controlar o lançamento
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automática do Swagger UI no navegador está desabilitada via app.launch-swagger-on-startup=false.");
            return;
        }

        // Constrói a URL completa, garantindo que o contextPath seja tratado corretamente
        String effectiveContextPath = (contextPath == null || "/".equals(contextPath)) ? "" : contextPath;
        String effectiveSwaggerUiPath = swaggerUiPath.startsWith("/") ? swaggerUiPath : "/" + swaggerUiPath;

        String url = "http://localhost:" + serverPort + effectiveContextPath + effectiveSwaggerUiPath;
        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI: {}", url);
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI (URL: {}): {}", url, e.getMessage(), e);
            }
        } else {
            log.warn("Abertura automática do navegador não é suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\controller\ClienteController.java   |   package br.com.fiap.gs.gsapi.controller   |   class ClienteController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.controller
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.exception.GlobalExceptionHandler; // Para referência no Swagger
import br.com.fiap.gs.gsapi.service.ClienteService;
import br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria; // Para busca por parâmetros

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springdoc.core.annotations.ParameterObject; // Para agrupar parâmetros de paginação e filtro no Swagger

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/api/v1/clientes")
@Tag(name = "Clientes", description = "Endpoints para gerenciamento de clientes e suas informações relacionadas.")
public class ClienteController {

    private final ClienteService clienteService;

    @Autowired
    public ClienteController(ClienteService clienteService) {
        this.clienteService = clienteService;
    }

    @Operation(
            summary = "Listar todos os clientes com paginação, ordenação e filtros.",
            description = "Retorna uma lista paginada de clientes. Permite filtrar por nome (parcial, case-insensitive), " +
                    "documento (exato) e data de nascimento (exato, formato YYYY-MM-DD ou como definido na entidade). " +
                    "Parâmetros de paginação padrão: `page=0`, `size=10`. Parâmetro de ordenação padrão: `sort=nome,asc`."
    )
    @Parameters({
            @Parameter(name = "page", description = "Número da página (começa em 0)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
            @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
            @Parameter(name = "sort", description = "Critério de ordenação (ex: nome,asc ou nome,desc ou multiplos: nome,asc&sort=documento,desc)", in = ParameterIn.QUERY, schema = @Schema(type = "string", example = "nome,asc"))
            // Os parâmetros de ClienteSearchCriteria (nome, documento, dataNascimento) serão documentados automaticamente pelo @ParameterObject
    })
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de clientes encontrada.",
                    content = @Content(mediaType = "application/json",
                            schema = @Schema(implementation = Page.class))) // Idealmente, o Swagger mostraria Page<ClienteResponseDTO>
    })
    @GetMapping
    public ResponseEntity<Page<ClienteResponseDTO>> listarTodosClientes(
            @ParameterObject @Valid ClienteSearchCriteria criteria, // Parâmetros de filtro agrupados e validados
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) {
        Page<ClienteResponseDTO> clientes = clienteService.listarTodos(criteria, pageable); // CORRIGIDO: Passando criteria
        return ResponseEntity.ok(clientes);
    }

    @Operation(summary = "Buscar cliente por ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Cliente encontrado.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class))),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @GetMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> buscarClientePorId(
            @Parameter(description = "ID do cliente a ser buscado.", required = true, example = "1") @PathVariable Long id) {
        ClienteResponseDTO cliente = clienteService.buscarPorId(id);
        return ResponseEntity.ok(cliente);
    }

    @Operation(summary = "Criar um novo cliente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "Requisição inválida devido a erro de validação ou regra de negócio (ex: documento duplicado).", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PostMapping
    public ResponseEntity<ClienteResponseDTO> criarCliente(
            @Parameter(description = "Dados do cliente para criação.", required = true,
                    content = @Content(schema = @Schema(implementation = ClienteRequestDTO.class)))
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO) {
        ClienteResponseDTO clienteSalvo = clienteService.criar(clienteRequestDTO);
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(clienteSalvo.getIdCliente())
                .toUri();
        return ResponseEntity.created(location).body(clienteSalvo);
    }

    @Operation(summary = "Atualizar um cliente existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Cliente atualizado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "Requisição inválida devido a erro de validação ou regra de negócio.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class))),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PutMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> atualizarCliente(
            @Parameter(description = "ID do cliente a ser atualizado.", required = true, example = "1") @PathVariable Long id,
            @Parameter(description = "Dados do cliente para atualização.", required = true,
                    content = @Content(schema = @Schema(implementation = ClienteRequestDTO.class)))
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO) {
        ClienteResponseDTO clienteAtualizado = clienteService.atualizar(id, clienteRequestDTO);
        return ResponseEntity.ok(clienteAtualizado);
    }

    @Operation(summary = "Deletar um cliente por ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Cliente deletado com sucesso.", content = @Content),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarCliente(
            @Parameter(description = "ID do cliente a ser deletado.", required = true, example = "1") @PathVariable Long id) {
        clienteService.deletar(id);
        return ResponseEntity.noContent().build();
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\controller\ContatoController.java   |   package br.com.fiap.gs.gsapi.controller   |   class ContatoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.controller
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.exception.GlobalExceptionHandler;
import br.com.fiap.gs.gsapi.service.ContatoService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/api/v1/contatos")
@Tag(name = "Contatos", description = "Endpoints para gerenciamento de informações de contato")
public class ContatoController {

    private final ContatoService contatoService;

    @Autowired
    public ContatoController(ContatoService contatoService) {
        this.contatoService = contatoService;
    }

    @Operation(
            summary = "Listar todos os contatos com paginação e filtros.",
            description = "Retorna uma lista paginada de contatos. Permite filtrar por email (parcial, case-insensitive), tipo de contato (exato, case-insensitive) e DDD (exato)."
    )
    @Parameters({
            @Parameter(name = "page", description = "Número da página (começa em 0)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
            @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
            @Parameter(name = "sort", description = "Critério de ordenação (ex: email,asc)", in = ParameterIn.QUERY, schema = @Schema(type = "string", example = "email,asc")),
            @Parameter(name = "email", description = "Filtrar por email (busca parcial, case-insensitive)", in = ParameterIn.QUERY, schema = @Schema(type = "string")),
            @Parameter(name = "tipoContato", description = "Filtrar por tipo de contato (busca exata, case-insensitive)", in = ParameterIn.QUERY, schema = @Schema(type = "string")),
            @Parameter(name = "ddd", description = "Filtrar por DDD (busca exata)", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
    })
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de contatos encontrada.",
                    content = @Content(mediaType = "application/json",
                            schema = @Schema(implementation = Page.class))) // Idealmente, Page<ContatoResponseDTO>
    })
    @GetMapping
    public ResponseEntity<Page<ContatoResponseDTO>> listarTodosContatos(
            @RequestParam(required = false) String email,
            @RequestParam(required = false) String tipoContato,
            @RequestParam(required = false) String ddd,
            @PageableDefault(size = 10, sort = "idContato") Pageable pageable) {
        Page<ContatoResponseDTO> contatos = contatoService.listarTodos(email, tipoContato, ddd, pageable);
        return ResponseEntity.ok(contatos);
    }

    @Operation(summary = "Buscar contato por ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Contato encontrado.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ContatoResponseDTO.class))),
            @ApiResponse(responseCode = "404", description = "Contato não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @GetMapping("/{id}")
    public ResponseEntity<ContatoResponseDTO> buscarContatoPorId(
            @Parameter(description = "ID do contato a ser buscado.", required = true, example = "1") @PathVariable Long id) {
        ContatoResponseDTO contato = contatoService.buscarPorId(id);
        return ResponseEntity.ok(contato);
    }

    @Operation(summary = "Buscar contato por Email")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Contato encontrado.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ContatoResponseDTO.class))),
            @ApiResponse(responseCode = "404", description = "Contato não encontrado para o email fornecido.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @GetMapping("/email/{email}")
    public ResponseEntity<ContatoResponseDTO> buscarContatoPorEmail(
            @Parameter(description = "Email do contato a ser buscado.", required = true, example = "cliente@example.com") @PathVariable String email) {
        ContatoResponseDTO contato = contatoService.buscarPorEmail(email);
        return ResponseEntity.ok(contato);
    }

    @Operation(summary = "Criar um novo contato.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Contato criado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ContatoResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "Requisição inválida (ex: email duplicado).", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PostMapping
    public ResponseEntity<ContatoResponseDTO> criarContato(
            @Parameter(description = "Dados do contato para criação.", required = true,
                    content = @Content(schema = @Schema(implementation = ContatoRequestDTO.class)))
            @Valid @RequestBody ContatoRequestDTO contatoRequestDTO) {
        ContatoResponseDTO contatoSalvo = contatoService.criar(contatoRequestDTO);
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(contatoSalvo.getIdContato())
                .toUri();
        return ResponseEntity.created(location).body(contatoSalvo);
    }

    @Operation(summary = "Atualizar um contato existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Contato atualizado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ContatoResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "Requisição inválida (ex: email duplicado).", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class))),
            @ApiResponse(responseCode = "404", description = "Contato não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PutMapping("/{id}")
    public ResponseEntity<ContatoResponseDTO> atualizarContato(
            @Parameter(description = "ID do contato a ser atualizado.", required = true, example = "1") @PathVariable Long id,
            @Parameter(description = "Dados do contato para atualização.", required = true,
                    content = @Content(schema = @Schema(implementation = ContatoRequestDTO.class)))
            @Valid @RequestBody ContatoRequestDTO contatoRequestDTO) {
        ContatoResponseDTO contatoAtualizado = contatoService.atualizar(id, contatoRequestDTO);
        return ResponseEntity.ok(contatoAtualizado);
    }

    @Operation(summary = "Deletar um contato por ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Contato deletado com sucesso.", content = @Content),
            @ApiResponse(responseCode = "404", description = "Contato não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class))),
            @ApiResponse(responseCode = "409", description = "Conflito: Contato associado a um ou mais clientes e não pode ser excluído.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarContato(
            @Parameter(description = "ID do contato a ser deletado.", required = true, example = "1") @PathVariable Long id) {
        // Semelhante ao EnderecoService, a lógica de verificação de associação com cliente
        // antes de deletar pode lançar uma exceção específica tratada pelo GlobalExceptionHandler.
        contatoService.deletar(id);
        return ResponseEntity.noContent().build();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\controller\EnderecoController.java   |   package br.com.fiap.gs.gsapi.controller   |   class EnderecoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.controller
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.exception.GlobalExceptionHandler; // Para referência no Swagger
import br.com.fiap.gs.gsapi.mapper.EnderecoMapper; // Já existia
import br.com.fiap.gs.gsapi.model.Endereco; // Já existia
import br.com.fiap.gs.gsapi.service.EnderecoGeocodingService; // Já existia
import br.com.fiap.gs.gsapi.service.EnderecoService; // Novo serviço CRUD

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springdoc.core.annotations.ParameterObject;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/enderecos")
@Tag(name = "Endereços", description = "Endpoints para gerenciamento, consulta e geocodificação de endereços")
public class EnderecoController {

    private final EnderecoService enderecoService; // Novo serviço para CRUD
    private final EnderecoGeocodingService enderecoGeocodingService; // Mantido para o endpoint específico
    private final EnderecoMapper enderecoMapper; // Mantido para conversões se necessário aqui

    @Autowired
    public EnderecoController(EnderecoService enderecoService,
                              EnderecoGeocodingService enderecoGeocodingService,
                              EnderecoMapper enderecoMapper) {
        this.enderecoService = enderecoService;
        this.enderecoGeocodingService = enderecoGeocodingService;
        this.enderecoMapper = enderecoMapper;
    }

    @Operation(summary = "Buscar endereço completo por CEP e número (com geocodificação)",
            description = "Busca dados do endereço usando ViaCEP e tenta obter coordenadas de geolocalização (Nominatim). " +
                    "Se o endereço já existe e possui coordenadas, ele é retornado; caso contrário, é buscado, geocodificado e salvo/atualizado." +
                    "Este endpoint é ideal para 'obter ou criar dinamicamente' um endereço com geolocalização.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Endereço encontrado e geocodificado (ou criado/atualizado).",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "CEP ou número inválido.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class))),
            @ApiResponse(responseCode = "404", description = "CEP não encontrado ou endereço não pôde ser geocodificado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @GetMapping("/geocodificar/cep/{cep}")
    public ResponseEntity<EnderecoResponseDTO> buscarOuCriarEnderecoGeocodificado(
            @Parameter(description = "CEP a ser consultado (apenas números ou formatado)", required = true, example = "01001000")
            @PathVariable String cep,
            @Parameter(description = "Número do endereço para geolocalização mais precisa", required = true, example = "100")
            @RequestParam String numero,
            @Parameter(description = "Complemento do endereço (opcional)", example = "Apto 101")
            @RequestParam(required = false) String complemento) {

        if (cep == null || cep.replaceAll("[^0-9]", "").length() != 8) {
            return ResponseEntity.badRequest().body(null); // Melhorar com ApiError
        }
        if (numero == null || numero.trim().isEmpty()) {
            return ResponseEntity.badRequest().body(null); // Melhorar com ApiError
        }

        // A lógica de `obterOuCriarEnderecoCompleto` já está no EnderecoGeocodingService
        // E agora também adicionamos uma fachada no EnderecoService
        EnderecoResponseDTO enderecoCompleto = enderecoService.criarOuBuscarEnderecoGeocodificado(cep, numero, complemento);
        return ResponseEntity.ok(enderecoCompleto);
    }


    // --- Endpoints CRUD para Endereço ---

    @Operation(
            summary = "Listar todos os endereços com paginação e filtros.",
            description = "Retorna uma lista paginada de endereços. Permite filtrar por CEP (parcial), logradouro (parcial, case-insensitive) e localidade (parcial, case-insensitive)."
    )
    @Parameters({
            @Parameter(name = "page", description = "Número da página (começa em 0)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
            @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
            @Parameter(name = "sort", description = "Critério de ordenação (ex: logradouro,asc)", in = ParameterIn.QUERY, schema = @Schema(type = "string", example = "localidade,asc")),
            @Parameter(name = "cep", description = "Filtrar por CEP (busca parcial nos números)", in = ParameterIn.QUERY, schema = @Schema(type = "string")),
            @Parameter(name = "logradouro", description = "Filtrar por logradouro (busca parcial, case-insensitive)", in = ParameterIn.QUERY, schema = @Schema(type = "string")),
            @Parameter(name = "localidade", description = "Filtrar por localidade (busca parcial, case-insensitive)", in = ParameterIn.QUERY, schema = @Schema(type = "string"))
    })
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de endereços encontrada.",
                    content = @Content(mediaType = "application/json",
                            schema = @Schema(implementation = Page.class))) // Idealmente, Page<EnderecoResponseDTO>
    })
    @GetMapping
    public ResponseEntity<Page<EnderecoResponseDTO>> listarTodosEnderecos(
            @RequestParam(required = false) String cep,
            @RequestParam(required = false) String logradouro,
            @RequestParam(required = false) String localidade,
            @PageableDefault(size = 10, sort = "idEndereco") Pageable pageable) {
        Page<EnderecoResponseDTO> enderecos = enderecoService.listarTodos(cep, logradouro, localidade, pageable);
        return ResponseEntity.ok(enderecos);
    }

    @Operation(summary = "Buscar endereço por ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Endereço encontrado.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class))),
            @ApiResponse(responseCode = "404", description = "Endereço não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @GetMapping("/{id}")
    public ResponseEntity<EnderecoResponseDTO> buscarEnderecoPorId(
            @Parameter(description = "ID do endereço a ser buscado.", required = true, example = "1") @PathVariable Long id) {
        EnderecoResponseDTO endereco = enderecoService.buscarPorId(id);
        return ResponseEntity.ok(endereco);
    }

    @Operation(summary = "Criar um novo endereço manualmente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Endereço criado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "Requisição inválida.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PostMapping
    public ResponseEntity<EnderecoResponseDTO> criarEndereco(
            @Parameter(description = "Dados do endereço para criação.", required = true,
                    content = @Content(schema = @Schema(implementation = EnderecoRequestDTO.class)))
            @Valid @RequestBody EnderecoRequestDTO enderecoRequestDTO) {
        EnderecoResponseDTO enderecoSalvo = enderecoService.criar(enderecoRequestDTO);
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(enderecoSalvo.getIdEndereco())
                .toUri();
        return ResponseEntity.created(location).body(enderecoSalvo);
    }

    @Operation(summary = "Atualizar um endereço existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Endereço atualizado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "Requisição inválida.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class))),
            @ApiResponse(responseCode = "404", description = "Endereço não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PutMapping("/{id}")
    public ResponseEntity<EnderecoResponseDTO> atualizarEndereco(
            @Parameter(description = "ID do endereço a ser atualizado.", required = true, example = "1") @PathVariable Long id,
            @Parameter(description = "Dados do endereço para atualização.", required = true,
                    content = @Content(schema = @Schema(implementation = EnderecoRequestDTO.class)))
            @Valid @RequestBody EnderecoRequestDTO enderecoRequestDTO) {
        EnderecoResponseDTO enderecoAtualizado = enderecoService.atualizar(id, enderecoRequestDTO);
        return ResponseEntity.ok(enderecoAtualizado);
    }

    @Operation(summary = "Deletar um endereço por ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Endereço deletado com sucesso.", content = @Content),
            @ApiResponse(responseCode = "404", description = "Endereço não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class))),
            @ApiResponse(responseCode = "409", description = "Conflito: Endereço associado a um ou mais clientes e não pode ser excluído.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarEndereco(
            @Parameter(description = "ID do endereço a ser deletado.", required = true, example = "1") @PathVariable Long id) {
        // A lógica de verificação de associação com cliente antes de deletar
        // pode ser colocada no EnderecoService e lançar uma exceção específica (ex: DataIntegrityViolationException ou uma customizada)
        // que o GlobalExceptionHandler poderia tratar com status 409 CONFLICT.
        // Por ora, o service tem uma lógica comentada, mas a deleção prossegue.
        enderecoService.deletar(id);
        return ResponseEntity.noContent().build();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\geocoding\NominatimResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.geocoding   |   class NominatimResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.geocoding
package br.com.fiap.gs.gsapi.dto.geocoding;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

// Ignora propriedades desconhecidas no JSON para evitar erros de deserialização
@JsonIgnoreProperties(ignoreUnknown = true)
public class NominatimResponseDTO {

    @JsonProperty("place_id")
    private String placeId;

    @JsonProperty("lat")
    private String latitude;

    @JsonProperty("lon")
    private String longitude;

    @JsonProperty("display_name")
    private String displayName;

    // Adicionar mais campos se necessário, como 'address' para detalhes
    // @JsonProperty("address")
    // private NominatimAddressDetailsDTO addressDetails;

    // Construtor padrão
    public NominatimResponseDTO() {
    }

    // Getters e Setters
    public String getPlaceId() { return placeId; }
    public void setPlaceId(String placeId) { this.placeId = placeId; }
    public String getLatitude() { return latitude; }
    public void setLatitude(String latitude) { this.latitude = latitude; }
    public String getLongitude() { return longitude; }
    public void setLongitude(String longitude) { this.longitude = longitude; }
    public String getDisplayName() { return displayName; }
    public void setDisplayName(String displayName) { this.displayName = displayName; }
    // public NominatimAddressDetailsDTO getAddressDetails() { return addressDetails; }
    // public void setAddressDetails(NominatimAddressDetailsDTO addressDetails) { this.addressDetails = addressDetails; }

    // DTO aninhado para detalhes do endereço, se você precisar deles
    // @JsonIgnoreProperties(ignoreUnknown = true)
    // public static class NominatimAddressDetailsDTO {
    //     private String road;
    //     private String suburb; // Bairro
    //     private String city;
    //     private String state;
    //     private String postcode;
    //     private String country;
    //     // Getters e Setters
    // }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class ClienteRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import java.util.Set; // Importar Set
import java.util.HashSet; // Importar HashSet

public class ClienteRequestDTO {

    @NotBlank(message = "O nome não pode estar em branco")
    @Size(max = 100, message = "O nome deve ter no máximo 100 caracteres")
    private String nome;

    @NotBlank(message = "O sobrenome não pode estar em branco")
    @Size(max = 100, message = "O sobrenome deve ter no máximo 100 caracteres")
    private String sobrenome;

    @NotBlank(message = "A data de nascimento não pode estar em branco")
    @Size(max = 10, message = "A data de nascimento deve ter no máximo 10 caracteres") // Ou use @Pattern para formato
    private String dataNascimento;

    @NotBlank(message = "O documento não pode estar em branco")
    @Size(max = 18, message = "O documento deve ter no máximo 18 caracteres")
    private String documento;

    private ContatoRequestDTO contato; // Ou contatoPrincipal
    private EnderecoRequestDTO endereco; // Ou enderecoPrincipal

    public ClienteRequestDTO() {
    }

    // Construtor, Getters e Setters
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }

    public ContatoRequestDTO getContato() {
        return contato;
    }

    public void setContato(ContatoRequestDTO contato) {
        this.contato = contato;
    }

    public EnderecoRequestDTO getEndereco() {
        return endereco;
    }

    public void setEndereco(EnderecoRequestDTO endereco) {
        this.endereco = endereco;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class ContatoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.request

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class ContatoRequestDTO {

    @NotBlank(message = "O DDD não pode estar em branco")
    @Size(min = 2, max = 3, message = "O DDD deve ter entre 2 e 3 caracteres")
    private String ddd;

    @NotBlank(message = "O telefone não pode estar em branco")
    @Size(min = 8, max = 15, message = "O telefone deve ter entre 8 e 15 caracteres")
    @Pattern(regexp = "^[0-9]+$", message = "O telefone deve conter apenas números")
    private String telefone;

    @Size(min = 9, max = 15, message = "O celular deve ter entre 9 e 15 caracteres")
    @Pattern(regexp = "^[0-9]+$", message = "O celular deve conter apenas números")
    private String celular; // Pode ser opcional dependendo da regra de negócio

    @Size(min = 9, max = 15, message = "O WhatsApp deve ter entre 9 e 15 caracteres")
    @Pattern(regexp = "^[0-9]+$", message = "O WhatsApp deve conter apenas números")
    private String whatsapp; // Pode ser opcional

    @NotBlank(message = "O email não pode estar em branco")
    @Email(message = "Formato de email inválido")
    @Size(max = 255, message = "O email deve ter no máximo 255 caracteres")
    private String email;

    @NotBlank(message = "O tipo de contato não pode estar em branco")
    @Size(max = 50, message = "O tipo de contato deve ter no máximo 50 caracteres")
    private String tipoContato;

    public ContatoRequestDTO() {
    }

    public ContatoRequestDTO(String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    public String getDdd() {
        return ddd;
    }

    public void setDdd(String ddd) {
        this.ddd = ddd;
    }

    public String getTelefone() {
        return telefone;
    }

    public void setTelefone(String telefone) {
        this.telefone = telefone;
    }

    public String getCelular() {
        return celular;
    }

    public void setCelular(String celular) {
        this.celular = celular;
    }

    public String getWhatsapp() {
        return whatsapp;
    }

    public void setWhatsapp(String whatsapp) {
        this.whatsapp = whatsapp;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getTipoContato() {
        return tipoContato;
    }

    public void setTipoContato(String tipoContato) {
        this.tipoContato = tipoContato;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class EnderecoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.DecimalMax;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Digits;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.math.BigDecimal; // IMPORTAR

public class EnderecoRequestDTO {

    @NotBlank(message = "O CEP não pode estar em branco")
    @Size(min = 8, max = 9, message = "O CEP deve ter entre 8 e 9 caracteres (ex: 00000-000 ou 00000000)")
    private String cep;

    @NotNull(message = "O número não pode ser nulo")
    @Min(value = 1, message = "O número deve ser no mínimo 1")
    @Max(value = 99999, message = "O número deve ser no máximo 99999")
    private int numero;

    @NotBlank(message = "O logradouro não pode estar em branco")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres")
    private String logradouro;

    @NotBlank(message = "O bairro não pode estar em branco")
    @Size(max = 255, message = "O bairro deve ter no máximo 255 caracteres")
    private String bairro;

    @NotBlank(message = "A localidade não pode estar em branco")
    @Size(max = 100, message = "A localidade deve ter no máximo 100 caracteres")
    private String localidade;

    @NotBlank(message = "A UF não pode estar em branco")
    @Size(min = 2, max = 2, message = "A UF deve ter 2 caracteres")
    private String uf;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres")
    private String complemento; // Complemento é opcional, mas o DDL tinha NOT NULL. Ajuste conforme necessidade.

    @NotNull(message = "A latitude não pode ser nula")
    @DecimalMin(value = "-90.0000000", inclusive = true, message = "Latitude mínima é -90.0")
    @DecimalMax(value = "90.0000000", inclusive = true, message = "Latitude máxima é 90.0")
    @Digits(integer = 3, fraction = 7, message = "Latitude deve ter até 3 dígitos inteiros e 7 fracionários")
    private BigDecimal latitude; // ALTERADO para BigDecimal

    @NotNull(message = "A longitude não pode ser nula")
    @DecimalMin(value = "-180.0000000", inclusive = true, message = "Longitude mínima é -180.0")
    @DecimalMax(value = "180.0000000", inclusive = true, message = "Longitude máxima é 180.0")
    @Digits(integer = 3, fraction = 7, message = "Longitude deve ter até 3 dígitos inteiros e 7 fracionários")
    private BigDecimal longitude; // ALTERADO para BigDecimal

    public EnderecoRequestDTO() {
    }

    // Construtor atualizado
    public EnderecoRequestDTO(String cep, int numero, String logradouro, String bairro, String localidade, String uf, String complemento, BigDecimal latitude, BigDecimal longitude) {
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    // Getters e Setters
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public int getNumero() { return numero; }
    public void setNumero(int numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public BigDecimal getLatitude() { return latitude; } // Tipo de retorno atualizado
    public void setLatitude(BigDecimal latitude) { this.latitude = latitude; } // Tipo do parâmetro atualizado
    public BigDecimal getLongitude() { return longitude; } // Tipo de retorno atualizado
    public void setLongitude(BigDecimal longitude) { this.longitude = longitude; } // Tipo do parâmetro atualizado
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\EonetEventosRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class EonetEventosRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.request

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.time.Instant;

public class EonetEventosRequestDTO {

    @NotBlank(message = "O ID original da EONET (eonetApiId) não pode estar em branco.")
    @Size(max = 50, message = "O ID da EONET deve ter no máximo 50 caracteres.")
    private String eonetApiId; // O ID original da API EONET (ex: "EONET_12345")

    @NotBlank(message = "O payload JSON do evento (jsonEvento) não pode estar em branco.")
    // Não há uma anotação de tamanho padrão para CLOB em DTOs,
    // mas a validação de ser um JSON válido ocorreria na camada de serviço ou ao persistir.
    private String jsonEvento; // O JSON completo do evento

    @NotNull(message = "A data do evento/ingestão não pode ser nula.")
    private Instant data; // A coluna 'data' da sua tabela gs_eonet (TIMESTAMP WITH LOCAL TIME ZONE)

    public EonetEventosRequestDTO() {
    }

    public EonetEventosRequestDTO(String eonetApiId, String jsonEvento, Instant data) {
        this.eonetApiId = eonetApiId;
        this.jsonEvento = jsonEvento;
        this.data = data;
    }

    public String getEonetApiId() {
        return eonetApiId;
    }

    public void setEonetApiId(String eonetApiId) {
        this.eonetApiId = eonetApiId;
    }

    public String getJsonEvento() {
        return jsonEvento;
    }

    public void setJsonEvento(String jsonEvento) {
        this.jsonEvento = jsonEvento;
    }

    public Instant getData() {
        return data;
    }

    public void setData(Instant data) {
        this.data = data;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class ClienteResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

import java.util.Set;
// Supondo que você também crie ContatoResponseDTO e EnderecoResponseDTO
// import br.com.fiap.gs.gsapi.dto.ContatoResponseDTO;
// import br.com.fiap.gs.gsapi.dto.EnderecoResponseDTO;

public class ClienteResponseDTO {
    private long idCliente;
    private String nome;
    private String sobrenome;
    private String dataNascimento;
    private String documento;
    private Set<ContatoResponseDTO> contatos;   // Usar DTOs para objetos aninhados
    private Set<EnderecoResponseDTO> enderecos; // Usar DTOs para objetos aninhados

    public ClienteResponseDTO() {
    }

    // Construtor, Getters e Setters
    public long getIdCliente() { return idCliente; }
    public void setIdCliente(long idCliente) { this.idCliente = idCliente; }
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }
    public Set<ContatoResponseDTO> getContatos() { return contatos; }
    public void setContatos(Set<ContatoResponseDTO> contatos) { this.contatos = contatos; }
    public Set<EnderecoResponseDTO> getEnderecos() { return enderecos; }
    public void setEnderecos(Set<EnderecoResponseDTO> enderecos) { this.enderecos = enderecos; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class ContatoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

public class ContatoResponseDTO {
    private long idContato;
    private String ddd;
    private String telefone;
    private String celular;
    private String whatsapp;
    private String email;
    private String tipoContato;

    public ContatoResponseDTO() {
    }
    // Construtor, Getters e Setters
    public long getIdContato() { return idContato; }
    public void setIdContato(long idContato) { this.idContato = idContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class EnderecoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.response
package br.com.fiap.gs.gsapi.dto.response;

import java.math.BigDecimal; // IMPORTAR
import java.util.Set;

public class EnderecoResponseDTO {
    private long idEndereco;
    private String cep;
    private int numero;
    private String logradouro;
    private String bairro;
    private String localidade;
    private String uf;
    private String complemento;
    private BigDecimal latitude;  // ALTERADO para BigDecimal
    private BigDecimal longitude; // ALTERADO para BigDecimal
    private Set<EonetEventoResponseDTO> eonetEventos;

    public EnderecoResponseDTO() {
    }

    // Getters e Setters
    public long getIdEndereco() { return idEndereco; }
    public void setIdEndereco(long idEndereco) { this.idEndereco = idEndereco; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public int getNumero() { return numero; }
    public void setNumero(int numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public BigDecimal getLatitude() { return latitude; } // Tipo de retorno atualizado
    public void setLatitude(BigDecimal latitude) { this.latitude = latitude; } // Tipo do parâmetro atualizado
    public BigDecimal getLongitude() { return longitude; } // Tipo de retorno atualizado
    public void setLongitude(BigDecimal longitude) { this.longitude = longitude; } // Tipo do parâmetro atualizado
    public Set<EonetEventoResponseDTO> getEonetEventos() { return eonetEventos; }
    public void setEonetEventos(Set<EonetEventoResponseDTO> eonetEventos) { this.eonetEventos = eonetEventos; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\EonetEventoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class EonetEventoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.response

package br.com.fiap.gs.gsapi.dto.response;

import java.time.Instant;

public class EonetEventoResponseDTO {
    private long idEonet; // PK numérica interna da sua tabela gs_eonet
    private String eonetApiId; // O ID original da API EONET (ex: "EONET_12345")
    private Instant data; // A coluna 'data' da sua tabela gs_eonet (TIMESTAMP WITH LOCAL TIME ZONE)

    // Campos que seriam extraídos do JSON na camada de serviço/mapper
    private String tituloEvento;
    private String linkEvento;
    private Instant dataOcorrenciaOriginalEonet; // A data do evento conforme reportado pela EONET (pode ser diferente da sua 'data' de ingestão)
    private String categoriaPrincipal; // Exemplo: "Wildfires", "Severe Storms"

    // Não inclua o campo 'jsonEvento' (CLOB) aqui.

    public EonetEventoResponseDTO() {
    }

    // Construtor, Getters e Setters
    public long getIdEonet() { return idEonet; }
    public void setIdEonet(long idEonet) { this.idEonet = idEonet; }
    public String getEonetApiId() { return eonetApiId; }
    public void setEonetApiId(String eonetApiId) { this.eonetApiId = eonetApiId; }
    public Instant getData() { return data; }
    public void setData(Instant data) { this.data = data; }
    public String getTituloEvento() { return tituloEvento; }
    public void setTituloEvento(String tituloEvento) { this.tituloEvento = tituloEvento; }
    public String getLinkEvento() { return linkEvento; }
    public void setLinkEvento(String linkEvento) { this.linkEvento = linkEvento; }
    public Instant getDataOcorrenciaOriginalEonet() { return dataOcorrenciaOriginalEonet; }
    public void setDataOcorrenciaOriginalEonet(Instant dataOcorrenciaOriginalEonet) { this.dataOcorrenciaOriginalEonet = dataOcorrenciaOriginalEonet; }
    public String getCategoriaPrincipal() { return categoriaPrincipal; }
    public void setCategoriaPrincipal(String categoriaPrincipal) { this.categoriaPrincipal = categoriaPrincipal; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\viacep\ViaCepResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.viacep   |   class ViaCepResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.viacep
package br.com.fiap.gs.gsapi.dto.viacep;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

// Ignora propriedades desconhecidas no JSON para evitar erros de deserialização
@JsonIgnoreProperties(ignoreUnknown = true)
public class ViaCepResponseDTO {

    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade; // Cidade
    private String uf;         // Estado
    private String ibge;
    private String gia;
    private String ddd;
    private String siafi;

    @JsonProperty("erro") // Para mapear o campo "erro" do JSON para o método isErro() / setErro()
    private boolean erro; // ViaCEP retorna erro=true se o CEP não for encontrado

    // Construtor padrão
    public ViaCepResponseDTO() {
    }

    // Getters e Setters para todos os campos
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getIbge() { return ibge; }
    public void setIbge(String ibge) { this.ibge = ibge; }
    public String getGia() { return gia; }
    public void setGia(String gia) { this.gia = gia; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getSiafi() { return siafi; }
    public void setSiafi(String siafi) { this.siafi = siafi; }
    public boolean isErro() { return erro; } // Getter para boolean
    public void setErro(boolean erro) { this.erro = erro; } // Setter para boolean
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java   |   package br.com.fiap.gs.gsapi.exception   |   class GlobalExceptionHandler
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.exception
package br.com.fiap.gs.gsapi.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        logger.warn("Recurso não encontrado: {} na requisição: {}", ex.getMessage(), request.getDescription(false));
        ApiError apiError = new ApiError(HttpStatus.NOT_FOUND.value(), ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(apiError, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Object> handleIllegalArgumentException(IllegalArgumentException ex, WebRequest request) {
        logger.warn("Argumento ilegal: {} na requisição: {}", ex.getMessage(), request.getDescription(false));
        ApiError apiError = new ApiError(HttpStatus.BAD_REQUEST.value(), ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(apiError, HttpStatus.BAD_REQUEST);
    }

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers,
            HttpStatusCode status, WebRequest request) {

        logger.warn("Erro de validação: {} na requisição: {}", ex.getMessage(), request.getDescription(false));
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", status.value());
        body.put("message", "Erro de validação nos campos da requisição.");

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.toList());

        ex.getBindingResult().getGlobalErrors().forEach(globalError -> {
            errors.add(globalError.getObjectName() + ": " + globalError.getDefaultMessage());
        });

        body.put("details", errors);

        return new ResponseEntity<>(body, headers, status);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleAllUncaughtException(Exception ex, WebRequest request) {
        logger.error("Erro inesperado no servidor na requisição: " + request.getDescription(false) , ex);
        ApiError apiError = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(), "Ocorreu um erro inesperado no servidor. Tente novamente mais tarde.", LocalDateTime.now());
        return new ResponseEntity<>(apiError, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // Classe DTO interna para representar a resposta de erro padronizada
    // Adicionado timestamp para melhor rastreabilidade
    // CORRIGIDO: Tornada pública para ser acessível por outras classes (ex: Swagger schema)
    public static class ApiError {
        private int status;
        private String message;
        private LocalDateTime timestamp;

        public ApiError(int status, String message, LocalDateTime timestamp) {
            this.status = status;
            this.message = message;
            this.timestamp = timestamp;
        }
        public int getStatus() { return status; }
        public void setStatus(int status) { this.status = status; }
        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }
        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java   |   package br.com.fiap.gs.gsapi.exception   |   class ResourceNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.exception
package br.com.fiap.gs.gsapi.exception; // Pacote corrigido

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class ClienteMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.model.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;

import java.util.List;
import java.util.Set;

@Mapper(
        componentModel = "spring",
        uses = {ContatoMapper.class, EnderecoMapper.class}, // Para mapear coleções aninhadas
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE // Para atualizações parciais
)
public interface ClienteMapper {

    // --- Mapeamentos PARA DTO de Resposta ---
    // MapStruct usará ContatoMapper e EnderecoMapper para as coleções.
    ClienteResponseDTO toClienteResponseDTO(Cliente cliente);

    List<ClienteResponseDTO> toClienteResponseDTOList(List<Cliente> clientes);

    Set<ClienteResponseDTO> toClienteResponseDTOSet(Set<Cliente> clientes);

    // --- Mapeamentos PARA Entidade ---
    // IDs de contatos e endereços são tratados no serviço.
    // ClienteRequestDTO foi modificado para ter `contatoIds` e `enderecoIds`.
    // O mapeamento direto de DTOs aninhados para criação/atualização de Contato/Endereco
    // a partir do ClienteRequestDTO não está implementado aqui, e sim a associação por IDs no serviço.
    @Mapping(target = "idCliente", ignore = true)
    @Mapping(target = "contatos", ignore = true)  // Coleções gerenciadas no serviço (via contatoIds)
    @Mapping(target = "enderecos", ignore = true) // Coleções gerenciadas no serviço (via enderecoIds)
    Cliente toCliente(ClienteRequestDTO clienteRequestDTO);

    @Mapping(target = "idCliente", ignore = true)
    @Mapping(target = "contatos", ignore = true)
    @Mapping(target = "enderecos", ignore = true)
    void updateClienteFromDto(ClienteRequestDTO clienteRequestDTO, @MappingTarget Cliente cliente);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class ContatoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.model.Contato;
import org.mapstruct.BeanMapping; // Importar
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;

import java.util.List;
import java.util.Set;

@Mapper(
        componentModel = "spring",
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE
)
public interface ContatoMapper {

    // --- Mapeamentos PARA DTO de Resposta ---
    ContatoResponseDTO toContatoResponseDTO(Contato contato);
    List<ContatoResponseDTO> toContatoResponseDTOList(List<Contato> contatos);
    Set<ContatoResponseDTO> toContatoResponseDTOSet(Set<Contato> contatos);

    // --- Mapeamentos PARA Entidade ---
    @BeanMapping(ignoreByDefault = true) // IGNORA TODOS OS CAMPOS POR PADRÃO
    @Mapping(source = "ddd", target = "ddd")
    @Mapping(source = "telefone", target = "telefone")
    @Mapping(source = "celular", target = "celular")
    @Mapping(source = "whatsapp", target = "whatsapp")
    @Mapping(source = "email", target = "email")
    @Mapping(source = "tipoContato", target = "tipoContato")
    // idContato e clientes serão ignorados por padrão e não precisam de @Mapping(target="...", ignore=true)
    Contato toContato(ContatoRequestDTO contatoRequestDTO);

    @BeanMapping(ignoreByDefault = true) // IGNORA TODOS OS CAMPOS POR PADRÃO
    @Mapping(source = "ddd", target = "ddd")
    @Mapping(source = "telefone", target = "telefone")
    @Mapping(source = "celular", target = "celular")
    @Mapping(source = "whatsapp", target = "whatsapp")
    @Mapping(source = "email", target = "email")
    @Mapping(source = "tipoContato", target = "tipoContato")
        // idContato e clientes serão ignorados por padrão
    void updateContatoFromDto(ContatoRequestDTO contatoRequestDTO, @MappingTarget Contato contato);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class EnderecoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.model.Endereco;
import org.mapstruct.BeanMapping; // Importar
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;

import java.util.List;
import java.util.Set;

@Mapper(
        componentModel = "spring",
        uses = {EonetEventoMapper.class},
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE
)
public interface EnderecoMapper {

    // --- Mapeamentos PARA DTO de Resposta ---
    // Para estes, não precisamos de ignoreByDefault, pois queremos a maioria dos campos
    EnderecoResponseDTO toEnderecoResponseDTO(Endereco endereco);
    List<EnderecoResponseDTO> toEnderecoResponseDTOList(List<Endereco> enderecos);
    Set<EnderecoResponseDTO> toEnderecoResponseDTOSet(Set<Endereco> enderecos);

    // --- Mapeamentos PARA Entidade ---
    @BeanMapping(ignoreByDefault = true) // IGNORA TODOS OS CAMPOS POR PADRÃO
    @Mapping(source = "cep", target = "cep")
    @Mapping(source = "numero", target = "numero")
    @Mapping(source = "logradouro", target = "logradouro")
    @Mapping(source = "bairro", target = "bairro")
    @Mapping(source = "localidade", target = "localidade")
    @Mapping(source = "uf", target = "uf")
    @Mapping(source = "complemento", target = "complemento")
    @Mapping(source = "latitude", target = "latitude")
    @Mapping(source = "longitude", target = "longitude")
    // idEndereco, clientes, eonetEventos serão ignorados por padrão
    // e não precisam de @Mapping(target="...", ignore=true) explícito aqui
    Endereco toEndereco(EnderecoRequestDTO enderecoRequestDTO);

    @BeanMapping(ignoreByDefault = true) // IGNORA TODOS OS CAMPOS POR PADRÃO
    @Mapping(source = "cep", target = "cep")
    @Mapping(source = "numero", target = "numero")
    @Mapping(source = "logradouro", target = "logradouro")
    @Mapping(source = "bairro", target = "bairro")
    @Mapping(source = "localidade", target = "localidade")
    @Mapping(source = "uf", target = "uf")
    @Mapping(source = "complemento", target = "complemento")
    @Mapping(source = "latitude", target = "latitude")
    @Mapping(source = "longitude", target = "longitude")
        // idEndereco, clientes, eonetEventos serão ignorados por padrão
    void updateEnderecoFromDto(EnderecoRequestDTO enderecoRequestDTO, @MappingTarget Endereco endereco);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\EonetEventoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class EonetEventoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EonetEventosRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EonetEventoResponseDTO;
import br.com.fiap.gs.gsapi.model.EonetEventos;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.mapstruct.BeanMapping; // Certifique-se que este import existe
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring")
public abstract class EonetEventoMapper {

    private static final Logger logger = LoggerFactory.getLogger(EonetEventoMapper.class);
    private final ObjectMapper objectMapper = new ObjectMapper();

    // --- Mapeamento PARA Entidade ---
    // ESTE É O MÉTODO PROBLEMÁTICO (LINHA 36 no log de erro)
    @BeanMapping(ignoreByDefault = true) // <<== GARANTA QUE ESTA ANOTAÇÃO ESTÁ AQUI
    @Mapping(source = "eonetApiId", target = "eonetApiId")
    @Mapping(source = "jsonEvento", target = "jsonEvento")
    @Mapping(source = "data", target = "data")
    // As propriedades "idEonet" (PK) e "enderecosEnvolvidos" (mappedBy)
    // serão ignoradas por padrão porque ignoreByDefault=true e não há @Mapping para elas.
    public abstract EonetEventos toEonetEventos(EonetEventosRequestDTO requestDTO);

    // --- Mapeamentos PARA DTO de Resposta ---
    @Mapping(target = "idEonet", source = "idEonet")
    @Mapping(target = "eonetApiId", source = "eonetApiId")
    @Mapping(target = "data", source = "data")
    @Mapping(target = "tituloEvento", source = "jsonEvento", qualifiedByName = "jsonToTitulo")
    @Mapping(target = "linkEvento", source = "jsonEvento", qualifiedByName = "jsonToLink")
    @Mapping(target = "dataOcorrenciaOriginalEonet", source = "jsonEvento", qualifiedByName = "jsonToDataOcorrencia")
    @Mapping(target = "categoriaPrincipal", source = "jsonEvento", qualifiedByName = "jsonToCategoriaPrincipal")
    public abstract EonetEventoResponseDTO toEonetEventoResponseDTO(EonetEventos eonetEventos);

    public abstract List<EonetEventoResponseDTO> toEonetEventoResponseDTOList(List<EonetEventos> eonetEventosList);

    public abstract Set<EonetEventoResponseDTO> toEonetEventoResponseDTOSet(Set<EonetEventos> eonetEventosSet);

    // --- Métodos Auxiliares para extrair dados do JSON (mantidos como antes) ---
    @Named("jsonToTitulo")
    protected String jsonToTitulo(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode titleNode = rootNode.path("title");
            return titleNode.isMissingNode() ? null : titleNode.asText();
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair título: {}. JSON: {}", e.getMessage(), jsonEvento.substring(0, Math.min(jsonEvento.length(), 200)));
            return null;
        }
    }

    @Named("jsonToLink")
    protected String jsonToLink(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode linkNode = rootNode.path("link");
            if (!linkNode.isMissingNode() && StringUtils.hasText(linkNode.asText())) {
                return linkNode.asText();
            }
            JsonNode sourcesNode = rootNode.path("sources");
            if (!sourcesNode.isMissingNode() && sourcesNode.isArray() && sourcesNode.size() > 0) {
                JsonNode firstSourceUrlNode = sourcesNode.get(0).path("url");
                if (!firstSourceUrlNode.isMissingNode()) {
                    return firstSourceUrlNode.asText();
                }
            }
            return null;
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair link: {}. JSON: {}", e.getMessage(), jsonEvento.substring(0, Math.min(jsonEvento.length(), 200)));
            return null;
        }
    }

    @Named("jsonToDataOcorrencia")
    protected Instant jsonToDataOcorrencia(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode geometriesNode = rootNode.path("geometries");
            if (!geometriesNode.isMissingNode() && geometriesNode.isArray() && geometriesNode.size() > 0) {
                JsonNode firstGeometry = geometriesNode.get(0);
                JsonNode dateNode = firstGeometry.path("date");
                if (!dateNode.isMissingNode() && StringUtils.hasText(dateNode.asText())) {
                    try {
                        return Instant.parse(dateNode.asText());
                    } catch (DateTimeParseException dtpe) {
                        logger.error("Erro ao parsear data de ocorrência do JSON: '{}'. Formato inválido. Erro: {}", dateNode.asText(), dtpe.getMessage());
                        return null;
                    }
                }
            }
            JsonNode rootDateNode = rootNode.path("date");
            if (!rootDateNode.isMissingNode() && StringUtils.hasText(rootDateNode.asText())) {
                try {
                    return Instant.parse(rootDateNode.asText());
                } catch (DateTimeParseException dtpe) {
                    logger.error("Erro ao parsear data de ocorrência (raiz) do JSON: '{}'. Formato inválido. Erro: {}", rootDateNode.asText(), dtpe.getMessage());
                    return null;
                }
            }
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair data de ocorrência: {}. JSON: {}", e.getMessage(), jsonEvento.substring(0, Math.min(jsonEvento.length(), 200)));
        }
        return null;
    }

    @Named("jsonToCategoriaPrincipal")
    protected String jsonToCategoriaPrincipal(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode categoriesNode = rootNode.path("categories");
            if (!categoriesNode.isMissingNode() && categoriesNode.isArray() && categoriesNode.size() > 0) {
                JsonNode firstCategory = categoriesNode.get(0);
                JsonNode titleNode = firstCategory.path("title");
                return titleNode.isMissingNode() ? null : titleNode.asText();
            }
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair categoria principal: {}. JSON: {}", e.getMessage(), jsonEvento.substring(0, Math.min(jsonEvento.length(), 200)));
        }
        return null;
    }

    // Classe utilitária interna para StringUtils.hasText (ou importe o do Spring Core)
    private static class StringUtils {
        public static boolean hasText(String str) {
            return str != null && !str.trim().isEmpty();
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Cliente.java   |   package br.com.fiap.gs.gsapi.model   |   class Cliente
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_cliente")
public class Cliente {

    @Id
    // Usando Coluna de Identidade (Oracle 12c+) em vez de Sequence + Trigger explícitos
    // Se o DDL gerado pelo Data Modeler usa Sequence+Trigger, mantenha as anotações @SequenceGenerator e @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Ou GenerationType.SEQUENCE se usar o DDL com sequence/trigger
    @Column(name = "id_cliente")
    private Long idCliente; // Usar Long (wrapper) para IDs é uma boa prática, permite nulo antes da persistência

    @Column(name = "nome", length = 100, nullable = false)
    private String nome;

    @Column(name = "sobrenome", length = 100, nullable = false)
    private String sobrenome;

    @Column(name = "data_nascimento", length = 10, nullable = false)
    private String dataNascimento; // Para MVP. Ideal: java.time.LocalDate

    @Column(name = "documento", length = 18, nullable = false, unique = true)
    private String documento;

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(name = "gs_clientecontato",
            joinColumns = @JoinColumn(name = "gs_cliente_id_cliente", referencedColumnName = "id_cliente"),
            inverseJoinColumns = @JoinColumn(name = "gs_contato_id_contato", referencedColumnName = "id_contato"))
    private Set<Contato> contatos = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(name = "gs_clienteendereco",
            joinColumns = @JoinColumn(name = "gs_cliente_id_cliente", referencedColumnName = "id_cliente"),
            inverseJoinColumns = @JoinColumn(name = "gs_endereco_id_endereco", referencedColumnName = "id_endereco"))
    private Set<Endereco> enderecos = new HashSet<>();

    public Cliente() {
    }

    public Cliente(String nome, String sobrenome, String dataNascimento, String documento) {
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
        this.documento = documento;
    }

    // Getters e Setters
    public Long getIdCliente() { return idCliente; }
    public void setIdCliente(Long idCliente) { this.idCliente = idCliente; }
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }
    public Set<Contato> getContatos() { return contatos; }
    public void setContatos(Set<Contato> contatos) { this.contatos = contatos; }
    public Set<Endereco> getEnderecos() { return enderecos; }
    public void setEnderecos(Set<Endereco> enderecos) { this.enderecos = enderecos; }

    // Métodos utilitários para gerenciar coleções bidirecionais
    public void addContato(Contato contato) {
        this.contatos.add(contato);
        contato.getClientesInternal().add(this); // Use um método package-private ou protected em Contato
    }
    public void removeContato(Contato contato) {
        this.contatos.remove(contato);
        contato.getClientesInternal().remove(this);
    }
    public void addEndereco(Endereco endereco) {
        this.enderecos.add(endereco);
        endereco.getClientesInternal().add(this);
    }
    public void removeEndereco(Endereco endereco) {
        this.enderecos.remove(endereco);
        endereco.getClientesInternal().remove(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cliente cliente = (Cliente) o;
        // Se o ID é nulo, a igualdade só pode ser por referência de objeto.
        // Após a persistência, o ID é a melhor forma de verificar igualdade.
        return idCliente != null && idCliente.equals(cliente.idCliente);
    }

    @Override
    public int hashCode() {
        // Se o ID é nulo, use o hashCode do objeto.
        // Após a persistência, o ID é a melhor forma.
        return idCliente != null ? Objects.hash(idCliente) : super.hashCode();
    }

    @Override
    public String toString() {
        return "Cliente{" +
                "idCliente=" + idCliente +
                ", nome='" + nome + '\'' +
                ", sobrenome='" + sobrenome + '\'' +
                ", documento='" + documento + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Contato.java   |   package br.com.fiap.gs.gsapi.model   |   class Contato
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*; // Para todas as anotações JPA
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_contato", uniqueConstraints = {
        @UniqueConstraint(name = "unq_gs_contato_email", columnNames = {"email"})
})
public class Contato {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_contato")
    private Long idContato;

    @Column(name = "ddd", length = 3, nullable = false)
    private String ddd;

    @Column(name = "telefone", length = 15, nullable = false)
    private String telefone;

    @Column(name = "celular", length = 15, nullable = false)
    private String celular;

    @Column(name = "whatsapp", length = 15, nullable = false)
    private String whatsapp;

    @Column(name = "email", length = 255, nullable = false)
    private String email;

    @Column(name = "tipo_contato", length = 50, nullable = false)
    private String tipoContato;

    @ManyToMany(mappedBy = "contatos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    public Contato() {
    }

    public Contato(String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    // Getters e Setters
    public Long getIdContato() { return idContato; }
    public void setIdContato(Long idContato) { this.idContato = idContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }

    public Set<Cliente> getClientes() {
        return clientes;
    }

    Set<Cliente> getClientesInternal() {
        return clientes;
    }

    protected void setClientes(Set<Cliente> clientes) {
        this.clientes = clientes;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Contato contato = (Contato) o;
        return idContato != null && idContato.equals(contato.idContato);
    }

    @Override
    public int hashCode() {
        return idContato != null ? Objects.hash(idContato) : super.hashCode();
    }

    @Override
    public String toString() {
        return "Contato{" +
                "idContato=" + idContato +
                ", email='" + email + '\'' +
                ", tipoContato='" + tipoContato + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Endereco.java   |   package br.com.fiap.gs.gsapi.model   |   class Endereco
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.math.BigDecimal; // IMPORTAR
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_endereco")
public class Endereco {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_endereco")
    private Long idEndereco;

    @Column(name = "cep", length = 9, nullable = false)
    private String cep;

    @Column(name = "numero", nullable = false)
    private int numero;

    @Column(name = "logradouro", length = 255, nullable = false)
    private String logradouro;

    @Column(name = "bairro", length = 255, nullable = false)
    private String bairro;

    @Column(name = "localidade", length = 100, nullable = false)
    private String localidade;

    @Column(name = "uf", length = 2, nullable = false)
    private String uf;

    @Column(name = "complemento", length = 255, nullable = false)
    private String complemento;

    @Column(name = "latitude", nullable = false, precision = 10, scale = 7)
    private BigDecimal latitude; // ALTERADO para BigDecimal

    @Column(name = "longitude", nullable = false, precision = 10, scale = 7)
    private BigDecimal longitude; // ALTERADO para BigDecimal

    @ManyToMany(mappedBy = "enderecos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(name = "gs_enderecoeventos",
            joinColumns = @JoinColumn(name = "gs_endereco_id_endereco", referencedColumnName = "id_endereco"),
            inverseJoinColumns = @JoinColumn(name = "gs_eonet_id_eonet", referencedColumnName = "id_eonet"))
    private Set<EonetEventos> eonetEventos = new HashSet<>();

    public Endereco() {
    }

    // Construtor atualizado para BigDecimal
    public Endereco(String cep, int numero, String logradouro, String bairro, String localidade, String uf, String complemento, BigDecimal latitude, BigDecimal longitude) {
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    // Getters e Setters
    public Long getIdEndereco() { return idEndereco; }
    public void setIdEndereco(Long idEndereco) { this.idEndereco = idEndereco; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public int getNumero() { return numero; }
    public void setNumero(int numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }

    // Getters e Setters para latitude e longitude atualizados
    public BigDecimal getLatitude() { return latitude; }
    public void setLatitude(BigDecimal latitude) { this.latitude = latitude; }
    public BigDecimal getLongitude() { return longitude; }
    public void setLongitude(BigDecimal longitude) { this.longitude = longitude; }

    public Set<Cliente> getClientes() {
        return clientes;
    }

    Set<Cliente> getClientesInternal() { return clientes; }
    protected void setClientes(Set<Cliente> clientes) { this.clientes = clientes; }

    public Set<EonetEventos> getEonetEventos() { return eonetEventos; }
    public void setEonetEventos(Set<EonetEventos> eonetEventos) { this.eonetEventos = eonetEventos; }

    public void addEonetEvento(EonetEventos evento) {
        this.eonetEventos.add(evento);
        if (evento != null && evento.getEnderecosEnvolvidosInternal() != null) {
            evento.getEnderecosEnvolvidosInternal().add(this);
        }
    }
    public void removeEonetEvento(EonetEventos evento) {
        this.eonetEventos.remove(evento);
        if (evento != null && evento.getEnderecosEnvolvidosInternal() != null) {
            evento.getEnderecosEnvolvidosInternal().remove(this);
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Endereco endereco = (Endereco) o;
        return idEndereco != null && idEndereco.equals(endereco.idEndereco);
    }

    @Override
    public int hashCode() {
        return idEndereco != null ? Objects.hash(idEndereco) : super.hashCode();
    }

    @Override
    public String toString() {
        return "Endereco{" +
                "idEndereco=" + idEndereco +
                ", cep='" + cep + '\'' +
                ", logradouro='" + logradouro + '\'' +
                ", numero=" + numero +
                ", localidade='" + localidade + '\'' +
                ", uf='" + uf + '\'' +
                ", latitude=" + latitude + // Adicionado para melhor visualização
                ", longitude=" + longitude + // Adicionado para melhor visualização
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\EonetEventos.java   |   package br.com.fiap.gs.gsapi.model   |   class EonetEventos
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.time.Instant;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_eonet", uniqueConstraints = {
        @UniqueConstraint(name = "unq_gs_eonet_eonet_api_id", columnNames = {"eonet_id"}) // Nome da coluna no DDL é eonet_id
})
public class EonetEventos {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_eonet")
    private Long idEonet; // PK numérica interna

    @Column(name = "eonet_id", length = 50, nullable = false) // ID original da API EONET
    private String eonetApiId;

    @Lob
    @Column(name = "json", columnDefinition = "CLOB") // DDL tem CLOB NULL
    private String jsonEvento;

    @Column(name = "data") // DDL tem TIMESTAMP WITH LOCAL TIME ZONE NULL
    private Instant data;

    @ManyToMany(mappedBy = "eonetEventos", fetch = FetchType.LAZY)
    private Set<Endereco> enderecosEnvolvidos = new HashSet<>();

    public EonetEventos() {
    }

    public EonetEventos(String eonetApiId, String jsonEvento, Instant data) {
        this.eonetApiId = eonetApiId;
        this.jsonEvento = jsonEvento;
        this.data = data;
    }

    // Getters e Setters
    public Long getIdEonet() { return idEonet; }
    public void setIdEonet(Long idEonet) { this.idEonet = idEonet; }
    public String getEonetApiId() { return eonetApiId; }
    public void setEonetApiId(String eonetApiId) { this.eonetApiId = eonetApiId; }
    public String getJsonEvento() { return jsonEvento; }
    public void setJsonEvento(String jsonEvento) { this.jsonEvento = jsonEvento; }
    public Instant getData() { return data; }
    public void setData(Instant data) { this.data = data; }

    Set<Endereco> getEnderecosEnvolvidosInternal() { return enderecosEnvolvidos; }
    protected void setEnderecosEnvolvidos(Set<Endereco> enderecosEnvolvidos) { this.enderecosEnvolvidos = enderecosEnvolvidos; }


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EonetEventos that = (EonetEventos) o;
        // Chave de negócio primária é o eonetApiId
        if (eonetApiId != null) {
            return eonetApiId.equals(that.eonetApiId);
        }
        // Se ambos eonetApiId são nulos, e os IDs gerados são nulos, são "iguais" apenas se forem a mesma instância.
        // Se os IDs gerados existem, eles devem ser usados para comparação.
        return idEonet != null && idEonet.equals(that.idEonet);
    }

    @Override
    public int hashCode() {
        // Chave de negócio primária é o eonetApiId
        return Objects.hash(eonetApiId);
    }

    @Override
    public String toString() {
        return "EonetEventos{" +
                "idEonet=" + idEonet +
                ", eonetApiId='" + eonetApiId + '\'' +
                ", data=" + data +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class ClienteRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Cliente;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long>, JpaSpecificationExecutor<Cliente> {

    // Exemplo de busca customizada (se necessário)
    Optional<Cliente> findByDocumento(String documento);

    // JpaSpecificationExecutor já permite buscas dinâmicas com Specifications
    // JpaRepository já oferece:
    // - save, saveAll
    // - findById, findAll, findAllById
    // - delete, deleteAll, deleteById
    // - count
    // - existsById
    // - findAll(Sort sort)
    // - findAll(Pageable pageable) -> para paginação
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class ContatoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Contato;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // IMPORTADO
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ContatoRepository extends JpaRepository<Contato, Long>, JpaSpecificationExecutor<Contato> { // ADICIONADO

    Optional<Contato> findByEmail(String email);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class EnderecoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Endereco;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // Adicionar se precisar de buscas dinâmicas para Endereco
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface EnderecoRepository extends JpaRepository<Endereco, Long>, JpaSpecificationExecutor<Endereco> { // Adicionado JpaSpecificationExecutor

    // Método para buscar um endereço pelo CEP
    List<Endereco> findByCep(String cep);

    // Método para buscar um endereço pelo CEP e número (NECESSÁRIO PARA EnderecoGeocodingService)
    Optional<Endereco> findByCepAndNumero(String cep, int numero);

    // Adicione outros métodos de busca customizados se necessário
    // Exemplo: buscar endereços por UF
    // List<Endereco> findByUf(String uf);

    // Exemplo: buscar endereços por localidade (cidade)
    // List<Endereco> findByLocalidadeIgnoreCase(String localidade);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\EonetEventoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class EonetEventoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.EonetEventos;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.Optional;

@Repository
public interface EonetEventoRepository extends JpaRepository<EonetEventos, Long> {

    // Busca pelo ID original da API EONET (que é único)
    Optional<EonetEventos> findByEonetApiId(String eonetApiId);

    // Exemplo de busca por eventos dentro de um período de data (usando a coluna 'data' da sua tabela)
    Page<EonetEventos> findByDataBetween(Instant dataInicio, Instant dataFim, Pageable pageable);

    // Exemplo de como você poderia buscar eventos cujo JSON contenha um certo título
    // ATENÇÃO: Buscas diretas em CLOB JSON podem ser menos performáticas.
    // O ideal é ter campos extraídos e indexados para filtros comuns.
    // Esta é uma query nativa para Oracle como exemplo, pode precisar de ajustes.
    @Query(value = "SELECT * FROM gs_eonet e WHERE JSON_VALUE(e.json, '$.title') LIKE %:titulo%", nativeQuery = true)
    Page<EonetEventos> findByJsonTitleContaining(@Param("titulo") String titulo, Pageable pageable);

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\ClienteService.java   |   package br.com.fiap.gs.gsapi.service   |   class ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service
package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.ClienteMapper;
import br.com.fiap.gs.gsapi.mapper.ContatoMapper;
import br.com.fiap.gs.gsapi.mapper.EnderecoMapper;
import br.com.fiap.gs.gsapi.model.Cliente;
import br.com.fiap.gs.gsapi.model.Contato;
import br.com.fiap.gs.gsapi.model.Endereco;
import br.com.fiap.gs.gsapi.repository.ClienteRepository;
import br.com.fiap.gs.gsapi.repository.ContatoRepository;
import br.com.fiap.gs.gsapi.repository.EnderecoRepository;
import br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria;
import br.com.fiap.gs.gsapi.specification.ClienteSpecification;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.dao.DataIntegrityViolationException; // Para usar no deletar
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;

@Service
@CacheConfig(cacheNames = "clientes")
public class ClienteService {

    private final ClienteRepository clienteRepository;
    private final ContatoRepository contatoRepository;
    private final EnderecoRepository enderecoRepository;
    private final ClienteMapper clienteMapper;
    private final ContatoMapper contatoMapper;
    private final EnderecoMapper enderecoMapper;
    private final EnderecoGeocodingService enderecoGeocodingService;

    @Autowired
    public ClienteService(ClienteRepository clienteRepository,
                          ContatoRepository contatoRepository,
                          EnderecoRepository enderecoRepository,
                          ClienteMapper clienteMapper,
                          ContatoMapper contatoMapper,
                          EnderecoMapper enderecoMapper,
                          EnderecoGeocodingService enderecoGeocodingService) {
        this.clienteRepository = clienteRepository;
        this.contatoRepository = contatoRepository;
        this.enderecoRepository = enderecoRepository;
        this.clienteMapper = clienteMapper;
        this.contatoMapper = contatoMapper;
        this.enderecoMapper = enderecoMapper;
        this.enderecoGeocodingService = enderecoGeocodingService;
    }

    @Transactional(readOnly = true)
    @Cacheable(key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString() + '-' + T(java.util.Objects).hashCode(#criteria)")
    public Page<ClienteResponseDTO> listarTodos(ClienteSearchCriteria criteria, Pageable pageable) {
        Specification<Cliente> spec = ClienteSpecification.fromCriteria(criteria);
        Page<Cliente> clientesPage = clienteRepository.findAll(spec, pageable);
        return clientesPage.map(clienteMapper::toClienteResponseDTO);
    }

    @Transactional(readOnly = true)
    @Cacheable(key = "#id")
    public ClienteResponseDTO buscarPorId(Long id) {
        Cliente cliente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com ID: " + id));
        return clienteMapper.toClienteResponseDTO(cliente);
    }

    @Transactional
    @CacheEvict(value = "clientes", allEntries = true)
    public ClienteResponseDTO criar(ClienteRequestDTO clienteRequestDTO) {
        clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).ifPresent(c -> {
            throw new IllegalArgumentException("Cliente com o documento '" + clienteRequestDTO.getDocumento() + "' já existe.");
        });

        Cliente cliente = clienteMapper.toCliente(clienteRequestDTO);
        cliente.setContatos(new HashSet<>());
        cliente.setEnderecos(new HashSet<>());

        // Processar e criar/associar Contato Principal
        if (clienteRequestDTO.getContato() == null) {
            throw new IllegalArgumentException("Dados de contato principal são obrigatórios para criar um cliente.");
        }
        ContatoRequestDTO contatoDto = clienteRequestDTO.getContato();
        Optional<Contato> contatoExistenteOpt = contatoRepository.findByEmail(contatoDto.getEmail());
        Contato contatoParaAssociar;
        if (contatoExistenteOpt.isPresent()) {
            contatoParaAssociar = contatoExistenteOpt.get();
            contatoMapper.updateContatoFromDto(contatoDto, contatoParaAssociar); // Atualiza dados do existente
            contatoParaAssociar = contatoRepository.save(contatoParaAssociar);
        } else {
            Contato novoContato = contatoMapper.toContato(contatoDto);
            contatoParaAssociar = contatoRepository.save(novoContato);
        }
        cliente.addContato(contatoParaAssociar);

        // Processar e criar/associar Endereco Principal
        if (clienteRequestDTO.getEndereco() == null) {
            throw new IllegalArgumentException("Dados de endereço principal são obrigatórios para criar um cliente.");
        }
        EnderecoRequestDTO enderecoDto = clienteRequestDTO.getEndereco();
        Endereco enderecoParaAssociar = enderecoGeocodingService.obterOuCriarEnderecoCompleto(
                enderecoDto.getCep(),
                String.valueOf(enderecoDto.getNumero()), // Geocoding service espera String
                enderecoDto.getComplemento()
        ).orElseThrow(() -> new RuntimeException("Não foi possível processar o endereço do cliente."));

        // Se o DTO de endereço do cliente já vier com lat/lon e você confia neles,
        // pode atualizar o 'enderecoParaAssociar' aqui, APÓS o geocoding service (que pode já ter salvo).
        // Isso é útil se o frontend fornecer coordenadas mais precisas (ex: de um clique no mapa).
        boolean enderecoAtualizadoComLatLonDoDto = false;
        if (enderecoDto.getLatitude() != null && enderecoParaAssociar.getLatitude().compareTo(enderecoDto.getLatitude()) != 0) {
            enderecoParaAssociar.setLatitude(enderecoDto.getLatitude());
            enderecoAtualizadoComLatLonDoDto = true;
        }
        if (enderecoDto.getLongitude() != null && enderecoParaAssociar.getLongitude().compareTo(enderecoDto.getLongitude()) != 0) {
            enderecoParaAssociar.setLongitude(enderecoDto.getLongitude());
            enderecoAtualizadoComLatLonDoDto = true;
        }
        if (enderecoAtualizadoComLatLonDoDto) {
            enderecoParaAssociar = enderecoRepository.save(enderecoParaAssociar); // Salva as novas lat/lon
        }

        cliente.addEndereco(enderecoParaAssociar);

        Cliente clienteSalvo = clienteRepository.save(cliente);
        return clienteMapper.toClienteResponseDTO(clienteSalvo);
    }

    @Transactional
    @CachePut(value = "clientes", key = "#id")
    @CacheEvict(value = "clientes", allEntries = true, condition = "#result != null") // Removido #root.methodName para simplificar
    public ClienteResponseDTO atualizar(Long id, ClienteRequestDTO clienteRequestDTO) {
        Cliente clienteExistente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com ID: " + id));

        if (clienteRequestDTO.getDocumento() != null &&
                !clienteExistente.getDocumento().equals(clienteRequestDTO.getDocumento())) {
            clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).ifPresent(c -> {
                if (!c.getIdCliente().equals(id)) {
                    throw new IllegalArgumentException("Outro cliente com o documento '" + clienteRequestDTO.getDocumento() + "' já existe.");
                }
            });
        }

        clienteMapper.updateClienteFromDto(clienteRequestDTO, clienteExistente);

        // Atualizar Contato Principal (se fornecido no DTO)
        if (clienteRequestDTO.getContato() != null) {
            ContatoRequestDTO contatoDto = clienteRequestDTO.getContato();
            // Lógica: Remove todos os contatos associados antigos e adiciona/atualiza o novo.
            // Isso assume que um cliente tem apenas UM contato principal gerenciado por este fluxo.
            Set<Contato> contatosAtuais = new HashSet<>(clienteExistente.getContatos());
            contatosAtuais.forEach(clienteExistente::removeContato); // Garante desassociação bidirecional

            Optional<Contato> contatoExistenteNoBancoOpt = contatoRepository.findByEmail(contatoDto.getEmail());
            Contato contatoParaAssociar;
            if (contatoExistenteNoBancoOpt.isPresent()) {
                contatoParaAssociar = contatoExistenteNoBancoOpt.get();
                contatoMapper.updateContatoFromDto(contatoDto, contatoParaAssociar);
            } else {
                contatoParaAssociar = contatoMapper.toContato(contatoDto);
            }
            contatoParaAssociar = contatoRepository.save(contatoParaAssociar);
            clienteExistente.addContato(contatoParaAssociar);
        }
        // Se clienteRequestDTO.getContato() for null, a lógica de atualização pode
        // optar por manter os contatos existentes ou removê-los.
        // A lógica atual com forEach(removeContato) já os removeria se o DTO não trouxesse um novo.

        // Atualizar Endereço Principal (se fornecido no DTO)
        if (clienteRequestDTO.getEndereco() != null) {
            EnderecoRequestDTO enderecoDto = clienteRequestDTO.getEndereco();
            // Lógica: Remove todos os endereços associados antigos e adiciona/atualiza o novo.
            Set<Endereco> enderecosAtuais = new HashSet<>(clienteExistente.getEnderecos());
            enderecosAtuais.forEach(clienteExistente::removeEndereco); // Garante desassociação bidirecional

            // Usar o geocoding service para obter ou criar o endereço.
            // Isso também garante que o endereço seja persistido/atualizado no banco.
            Endereco enderecoParaAssociar = enderecoGeocodingService.obterOuCriarEnderecoCompleto(
                    enderecoDto.getCep(),
                    String.valueOf(enderecoDto.getNumero()),
                    enderecoDto.getComplemento()
            ).orElseThrow(() -> new RuntimeException("Não foi possível processar o endereço para atualização do cliente."));

            // Se o DTO tiver lat/lon e forem diferentes do que o geocoding retornou/encontrou, atualize.
            boolean enderecoAtualizadoComLatLonDoDto = false;
            if (enderecoDto.getLatitude() != null && (enderecoParaAssociar.getLatitude() == null || enderecoParaAssociar.getLatitude().compareTo(enderecoDto.getLatitude()) != 0)) {
                enderecoParaAssociar.setLatitude(enderecoDto.getLatitude());
                enderecoAtualizadoComLatLonDoDto = true;
            }
            if (enderecoDto.getLongitude() != null && (enderecoParaAssociar.getLongitude() == null || enderecoParaAssociar.getLongitude().compareTo(enderecoDto.getLongitude()) != 0 )) {
                enderecoParaAssociar.setLongitude(enderecoDto.getLongitude());
                enderecoAtualizadoComLatLonDoDto = true;
            }
            if (enderecoAtualizadoComLatLonDoDto) {
                enderecoParaAssociar = enderecoRepository.save(enderecoParaAssociar);
            }

            clienteExistente.addEndereco(enderecoParaAssociar);
        }

        Cliente clienteAtualizado = clienteRepository.save(clienteExistente);
        return clienteMapper.toClienteResponseDTO(clienteAtualizado);
    }

    @Transactional
    @CacheEvict(value = "clientes", allEntries = true)
    public void deletar(Long id) {
        Cliente cliente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com ID: " + id + " para exclusão."));

        // A remoção das entradas nas tabelas de junção (gs_clientecontato, gs_clienteendereco)
        // será gerenciada pelo JPA devido à propriedade do relacionamento e CascadeType.MERGE/PERSIST.
        // As entidades Contato e Endereco em si não são deletadas em cascata do Cliente,
        // o que é geralmente o comportamento desejado.
        clienteRepository.deleteById(id);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\ContatoService.java   |   package br.com.fiap.gs.gsapi.service   |   class ContatoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service
package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.ContatoMapper;
import br.com.fiap.gs.gsapi.model.Contato;
import br.com.fiap.gs.gsapi.repository.ContatoRepository;
import br.com.fiap.gs.gsapi.specification.ContatoSpecification;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.dao.DataIntegrityViolationException; // IMPORTADO
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils; // Para StringUtils.hasText, embora não usado diretamente nesta versão do listarTodos

@Service
@CacheConfig(cacheNames = "contatos")
public class ContatoService {

    private final ContatoRepository contatoRepository;
    private final ContatoMapper contatoMapper;

    @Autowired
    public ContatoService(ContatoRepository contatoRepository, ContatoMapper contatoMapper) {
        this.contatoRepository = contatoRepository;
        this.contatoMapper = contatoMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable(key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString() + '-' + T(java.util.Objects).hashCode(#email) + '-' + T(java.util.Objects).hashCode(#tipoContato) + '-' + T(java.util.Objects).hashCode(#ddd)")
    public Page<ContatoResponseDTO> listarTodos(String email, String tipoContato, String ddd, Pageable pageable) {
        Specification<Contato> spec = ContatoSpecification.comFiltros(email, tipoContato, ddd);
        Page<Contato> contatosPage = contatoRepository.findAll(spec, pageable);
        return contatosPage.map(contatoMapper::toContatoResponseDTO);
    }

    @Transactional(readOnly = true)
    @Cacheable(key = "#id")
    public ContatoResponseDTO buscarPorId(Long id) {
        Contato contato = contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com ID: " + id));
        return contatoMapper.toContatoResponseDTO(contato);
    }

    @Transactional(readOnly = true)
    @Cacheable(key = "'email-' + #email")
    public ContatoResponseDTO buscarPorEmail(String email) {
        Contato contato = contatoRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com Email: " + email));
        return contatoMapper.toContatoResponseDTO(contato);
    }

    @Transactional
    @CacheEvict(cacheNames = "contatos", allEntries = true)
    public ContatoResponseDTO criar(ContatoRequestDTO contatoRequestDTO) {
        contatoRepository.findByEmail(contatoRequestDTO.getEmail()).ifPresent(c -> {
            throw new IllegalArgumentException("Contato com o email '" + contatoRequestDTO.getEmail() + "' já existe.");
        });

        Contato contato = contatoMapper.toContato(contatoRequestDTO);
        Contato contatoSalvo = contatoRepository.save(contato);
        return contatoMapper.toContatoResponseDTO(contatoSalvo);
    }

    @Transactional
    @CachePut(key = "#id")
    @CacheEvict(cacheNames = "contatos", allEntries = true, condition = "#result != null")
    public ContatoResponseDTO atualizar(Long id, ContatoRequestDTO contatoRequestDTO) {
        Contato contatoExistente = contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com ID: " + id));

        if (org.springframework.util.StringUtils.hasText(contatoRequestDTO.getEmail()) && !contatoExistente.getEmail().equalsIgnoreCase(contatoRequestDTO.getEmail())) {
            contatoRepository.findByEmail(contatoRequestDTO.getEmail()).ifPresent(c -> {
                if (!c.getIdContato().equals(id)) {
                    throw new IllegalArgumentException("Outro contato com o email '" + contatoRequestDTO.getEmail() + "' já existe.");
                }
            });
        }

        contatoMapper.updateContatoFromDto(contatoRequestDTO, contatoExistente);
        Contato contatoAtualizado = contatoRepository.save(contatoExistente);
        return contatoMapper.toContatoResponseDTO(contatoAtualizado);
    }

    @Transactional
    @CacheEvict(cacheNames = "contatos", allEntries = true)
    public void deletar(Long id) {
        Contato contatoParaDeletar = contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com ID: " + id + " para exclusão."));

        if (contatoParaDeletar.getClientes() != null && !contatoParaDeletar.getClientes().isEmpty()) {
            throw new DataIntegrityViolationException("Contato está associado a um ou mais clientes e não pode ser excluído.");
        }
        contatoRepository.deleteById(id);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\EnderecoGeocodingService.java   |   package br.com.fiap.gs.gsapi.service   |   class EnderecoGeocodingService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service
package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.client.NominatimClient;
import br.com.fiap.gs.gsapi.client.ViaCepClient;
import br.com.fiap.gs.gsapi.dto.geocoding.NominatimResponseDTO;
import br.com.fiap.gs.gsapi.dto.viacep.ViaCepResponseDTO;
import br.com.fiap.gs.gsapi.model.Endereco;
import br.com.fiap.gs.gsapi.repository.EnderecoRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal; // IMPORTAR
import java.util.Optional;

@Service
public class EnderecoGeocodingService {

    private static final Logger logger = LoggerFactory.getLogger(EnderecoGeocodingService.class);
    private final ViaCepClient viaCepClient;
    private final NominatimClient nominatimClient;
    private final EnderecoRepository enderecoRepository;

    @Autowired
    public EnderecoGeocodingService(ViaCepClient viaCepClient,
                                    NominatimClient nominatimClient,
                                    EnderecoRepository enderecoRepository) {
        this.viaCepClient = viaCepClient;
        this.nominatimClient = nominatimClient;
        this.enderecoRepository = enderecoRepository;
    }

    @Transactional
    public Optional<Endereco> obterOuCriarEnderecoCompleto(String cep, String numeroStr, String complemento) {
        String cepNumerico = cep.replaceAll("[^0-9]", "");
        int numeroParsed = parseNumero(numeroStr); // Parse o número uma vez

        Optional<Endereco> enderecoExistente = enderecoRepository.findByCepAndNumero(cepNumerico, numeroParsed);

        // Se já existe e TEM coordenadas, atualiza o complemento se necessário e retorna.
        if (enderecoExistente.isPresent() &&
                enderecoExistente.get().getLatitude() != null &&
                enderecoExistente.get().getLongitude() != null &&
                // Checa se as coordenadas não são zero (ou algum valor placeholder)
                !(enderecoExistente.get().getLatitude().compareTo(BigDecimal.ZERO) == 0 &&
                        enderecoExistente.get().getLongitude().compareTo(BigDecimal.ZERO) == 0)
        ) {
            logger.info("Endereço encontrado no banco com coordenadas para CEP {} e Número {}. ID: {}", cepNumerico, numeroStr, enderecoExistente.get().getIdEndereco());
            // Atualiza o complemento se mudou
            boolean modificado = false;
            if (complemento != null && !complemento.equals(enderecoExistente.get().getComplemento())) {
                enderecoExistente.get().setComplemento(complemento);
                modificado = true;
            } else if (complemento == null && enderecoExistente.get().getComplemento() != null && !enderecoExistente.get().getComplemento().isEmpty()) {
                // Se complemento veio nulo mas existia algo, define para vazio ou mantém. Aqui define para vazio.
                enderecoExistente.get().setComplemento("");
                modificado = true;
            }

            if (modificado) {
                return Optional.of(enderecoRepository.save(enderecoExistente.get()));
            }
            return enderecoExistente;
        }

        logger.info("Buscando dados no ViaCEP para CEP: {}", cepNumerico);
        ViaCepResponseDTO viaCepData = viaCepClient.buscarEnderecoPorCep(cepNumerico);
        if (viaCepData == null || (viaCepData.isErro() && viaCepData.getCep() == null) ) { // ViaCEP pode retornar erro:true ou tudo nulo
            logger.warn("Não foi possível obter dados do ViaCEP para o CEP: {}", cepNumerico);
            // Se o endereço já existia (mas sem coordenadas), e o ViaCEP falhou, o que fazer?
            // Poderíamos retornar o existente sem coordenadas, ou empty.
            // Por ora, se ViaCEP falhar e não tivermos dados base, retornamos empty.
            return enderecoExistente.isPresent() ? enderecoExistente : Optional.empty();
        }

        Endereco enderecoParaSalvar = enderecoExistente.orElseGet(Endereco::new);
        mapearViaCepParaEndereco(viaCepData, numeroParsed, complemento, enderecoParaSalvar);

        // Se já tínhamos um endereço (mesmo sem lat/lon), e o ViaCEP retornou dados,
        // e esses dados são diferentes do que já tínhamos (exceto lat/lon), atualizamos.
        // Essa lógica de "merge" pode ser complexa. Por ora, o mapearViaCepParaEndereco sobrescreve.

        // Tenta obter coordenadas do Nominatim
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("Thread interrompida enquanto esperava para chamar Nominatim.", e);
        }

        NominatimResponseDTO nominatimResponse = nominatimClient.buscarCoordenadasPorEndereco(
                enderecoParaSalvar.getLogradouro(),
                String.valueOf(enderecoParaSalvar.getNumero()),
                enderecoParaSalvar.getBairro(),
                enderecoParaSalvar.getLocalidade(),
                enderecoParaSalvar.getUf(),
                enderecoParaSalvar.getCep()
        ).blockFirst();

        if (nominatimResponse != null && nominatimResponse.getLatitude() != null && nominatimResponse.getLongitude() != null) {
            try {
                // ALTERADO para new BigDecimal(String)
                enderecoParaSalvar.setLatitude(new BigDecimal(nominatimResponse.getLatitude()));
                enderecoParaSalvar.setLongitude(new BigDecimal(nominatimResponse.getLongitude()));
                logger.info("Coordenadas obtidas do Nominatim para CEP {}: Lat={}, Lon={}", cepNumerico, enderecoParaSalvar.getLatitude(), enderecoParaSalvar.getLongitude());
            } catch (NumberFormatException e) {
                logger.error("Erro ao converter coordenadas (String) do Nominatim para BigDecimal: Lat='{}', Lon='{}'",
                        nominatimResponse.getLatitude(), nominatimResponse.getLongitude(), e);
                // Define como null ou mantém anterior se houver, ou lança erro se coordenadas são mandatórias.
                // Se o endereço já tinha lat/lon (improvável neste fluxo), não sobrescrever com nulo.
                // Se o DDL/entidade permite lat/lon nulos, pode-se setar para null aqui.
                // Como a entidade tem nullable=false, não podemos setar para null.
                // Uma opção é deixar como estava se já existia, ou usar ZERO (se fizer sentido),
                // ou propagar o erro para indicar que a geocodificação falhou.
                // Por ora, se falhar o parse, as coordenadas não serão atualizadas a partir do Nominatim.
                if (enderecoParaSalvar.getLatitude() == null) enderecoParaSalvar.setLatitude(BigDecimal.ZERO); // Placeholder se for obrigatório
                if (enderecoParaSalvar.getLongitude() == null) enderecoParaSalvar.setLongitude(BigDecimal.ZERO); // Placeholder se for obrigatório
            }
        } else {
            logger.warn("Não foi possível obter coordenadas do Nominatim para o endereço do CEP: {}. Usando ZERO como placeholder se obrigatório.", cepNumerico);
            // Se coordenadas são obrigatórias na entidade (nullable=false), precisamos setar algo.
            if (enderecoParaSalvar.getLatitude() == null) enderecoParaSalvar.setLatitude(BigDecimal.ZERO);
            if (enderecoParaSalvar.getLongitude() == null) enderecoParaSalvar.setLongitude(BigDecimal.ZERO);
        }

        // Garantir que lat/lon não sejam nulos se a entidade exige (como é o caso)
        if (enderecoParaSalvar.getLatitude() == null) {
            logger.warn("Latitude ainda é nula para CEP {}, definindo para ZERO como fallback.", cepNumerico);
            enderecoParaSalvar.setLatitude(BigDecimal.ZERO);
        }
        if (enderecoParaSalvar.getLongitude() == null) {
            logger.warn("Longitude ainda é nula para CEP {}, definindo para ZERO como fallback.", cepNumerico);
            enderecoParaSalvar.setLongitude(BigDecimal.ZERO);
        }


        try {
            Endereco enderecoSalvo = enderecoRepository.save(enderecoParaSalvar);
            return Optional.of(enderecoSalvo);
        } catch (Exception e) {
            logger.error("Erro ao salvar endereço para CEP {}: {}", cepNumerico, e.getMessage(), e);
            return Optional.empty();
        }
    }

    private void mapearViaCepParaEndereco(ViaCepResponseDTO viaCepData, int numero, String complemento, Endereco endereco) {
        if (viaCepData.getCep() != null) endereco.setCep(viaCepData.getCep().replaceAll("[^0-9]", ""));
        if (viaCepData.getLogradouro() != null) endereco.setLogradouro(viaCepData.getLogradouro()); else if (endereco.getLogradouro() == null) endereco.setLogradouro("");
        if (viaCepData.getBairro() != null) endereco.setBairro(viaCepData.getBairro()); else if (endereco.getBairro() == null) endereco.setBairro("");
        if (viaCepData.getLocalidade() != null) endereco.setLocalidade(viaCepData.getLocalidade()); else if (endereco.getLocalidade() == null) endereco.setLocalidade("");
        if (viaCepData.getUf() != null) endereco.setUf(viaCepData.getUf()); else if (endereco.getUf() == null) endereco.setUf("");

        endereco.setNumero(numero); // Número vem do parâmetro

        // Lógica para complemento
        if (complemento != null) {
            endereco.setComplemento(complemento);
        } else if (viaCepData.getComplemento() != null) {
            endereco.setComplemento(viaCepData.getComplemento());
        } else if (endereco.getComplemento() == null) { // Só define para "" se for nulo
            endereco.setComplemento("");
        }
        // Se DDL exige complemento NOT NULL, "" é uma forma de satisfazer.
    }

    private int parseNumero(String numeroStr) {
        if (numeroStr == null || numeroStr.trim().isEmpty()) {
            logger.warn("Número de endereço nulo ou vazio fornecido. Retornando 0.");
            return 0; // Ou lançar IllegalArgumentException se número for obrigatório
        }
        try {
            return Integer.parseInt(numeroStr.replaceAll("[^0-9]", ""));
        } catch (NumberFormatException e) {
            logger.warn("Número de endereço inválido fornecido: '{}'. Usando 0.", numeroStr, e);
            return 0; // Ou lançar IllegalArgumentException
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\EnderecoService.java   |   package br.com.fiap.gs.gsapi.service   |   class EnderecoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service
package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.EnderecoMapper;
import br.com.fiap.gs.gsapi.model.Endereco;
import br.com.fiap.gs.gsapi.repository.EnderecoRepository;
import br.com.fiap.gs.gsapi.specification.EnderecoSpecification;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import jakarta.persistence.criteria.Predicate; // IMPORTAR Predicate
import java.util.ArrayList; // IMPORTAR ArrayList
import java.util.List; // IMPORTAR List
import java.util.Optional;

@Service
@CacheConfig(cacheNames = "enderecos")
public class EnderecoService {

    private final EnderecoRepository enderecoRepository;
    private final EnderecoMapper enderecoMapper;
    private final EnderecoGeocodingService enderecoGeocodingService;

    @Autowired
    public EnderecoService(EnderecoRepository enderecoRepository,
                           EnderecoMapper enderecoMapper,
                           EnderecoGeocodingService enderecoGeocodingService) {
        this.enderecoRepository = enderecoRepository;
        this.enderecoMapper = enderecoMapper;
        this.enderecoGeocodingService = enderecoGeocodingService;
    }

    @Transactional(readOnly = true)
    @Cacheable(key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString() + '-' + T(java.util.Objects).hashCode(#cep) + '-' + T(java.util.Objects).hashCode(#logradouro) + '-' + T(java.util.Objects).hashCode(#localidade)")
    public Page<EnderecoResponseDTO> listarTodos(String cep, String logradouro, String localidade, Pageable pageable) {
        // CORREÇÃO DO WARNING: Construção dinâmica da Specification
        Specification<Endereco> spec = (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (StringUtils.hasText(cep)) {
                // Assumindo que EnderecoSpecification.cepContem retorna uma Specification<Endereco>
                // Para combiná-las, precisamos convertê-las para Predicate no contexto atual.
                predicates.add(EnderecoSpecification.cepContem(cep).toPredicate(root, query, criteriaBuilder));
            }
            if (StringUtils.hasText(logradouro)) {
                predicates.add(EnderecoSpecification.logradouroContem(logradouro).toPredicate(root, query, criteriaBuilder));
            }
            if (StringUtils.hasText(localidade)) {
                predicates.add(EnderecoSpecification.localidadeContem(localidade).toPredicate(root, query, criteriaBuilder));
            }

            if (predicates.isEmpty()) {
                return criteriaBuilder.conjunction(); // Nenhum filtro, retorna tudo
            }
            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };

        Page<Endereco> enderecosPage = enderecoRepository.findAll(spec, pageable);
        return enderecosPage.map(enderecoMapper::toEnderecoResponseDTO);
    }

    @Transactional(readOnly = true)
    @Cacheable(key = "#id")
    public EnderecoResponseDTO buscarPorId(Long id) {
        Endereco endereco = enderecoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Endereço não encontrado com ID: " + id));
        return enderecoMapper.toEnderecoResponseDTO(endereco);
    }

    @Transactional
    @CacheEvict(cacheNames = "enderecos", allEntries = true)
    public EnderecoResponseDTO criar(EnderecoRequestDTO enderecoRequestDTO) {
        // Validação de duplicidade pode ser adicionada aqui se necessário
        // Ex:
        // Optional<Endereco> existente = enderecoRepository.findByCepAndNumero(
        //     enderecoRequestDTO.getCep().replaceAll("[^0-9]", ""),
        //     enderecoRequestDTO.getNumero()
        // );
        // if (existente.isPresent()) {
        //     throw new IllegalArgumentException("Endereço com CEP " + enderecoRequestDTO.getCep() + " e número " + enderecoRequestDTO.getNumero() + " já existe.");
        // }

        Endereco endereco = enderecoMapper.toEndereco(enderecoRequestDTO);
        Endereco enderecoSalvo = enderecoRepository.save(endereco);
        return enderecoMapper.toEnderecoResponseDTO(enderecoSalvo);
    }

    @Transactional
    public EnderecoResponseDTO criarOuBuscarEnderecoGeocodificado(String cep, String numero, String complemento) {
        Endereco endereco = enderecoGeocodingService.obterOuCriarEnderecoCompleto(cep, numero, complemento)
                .orElseThrow(() -> new ResourceNotFoundException("Não foi possível obter ou criar o endereço para CEP: " + cep + " e Número: " + numero));
        return enderecoMapper.toEnderecoResponseDTO(endereco);
    }

    @Transactional
    @CachePut(key = "#id")
    @CacheEvict(cacheNames = "enderecos", allEntries = true, condition = "#result != null")
    public EnderecoResponseDTO atualizar(Long id, EnderecoRequestDTO enderecoRequestDTO) {
        Endereco enderecoExistente = enderecoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Endereço não encontrado com ID: " + id));

        enderecoMapper.updateEnderecoFromDto(enderecoRequestDTO, enderecoExistente);

        Endereco enderecoAtualizado = enderecoRepository.save(enderecoExistente);
        return enderecoMapper.toEnderecoResponseDTO(enderecoAtualizado);
    }

    @Transactional
    @CacheEvict(cacheNames = "enderecos", allEntries = true)
    public void deletar(Long id) {
        Endereco enderecoParaDeletar = enderecoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Endereço não encontrado com ID: " + id + " para exclusão."));

        if (enderecoParaDeletar.getClientes() != null && !enderecoParaDeletar.getClientes().isEmpty()) {
            throw new DataIntegrityViolationException("Endereço está associado a um ou mais clientes e não pode ser excluído.");
        }

        if(enderecoParaDeletar.getEonetEventos() != null && !enderecoParaDeletar.getEonetEventos().isEmpty()){
            throw new DataIntegrityViolationException("Endereço está associado a um ou mais eventos EONET e não pode ser excluído.");
        }

        enderecoRepository.deleteById(id);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\search\ClienteSearchCriteria.java   |   package br.com.fiap.gs.gsapi.service.search   |   class ClienteSearchCriteria
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.service.search;

import java.util.Objects;

// Classe simples para encapsular critérios de busca para Cliente
public class ClienteSearchCriteria {
    private String nome;
    private String documento;
    private String dataNascimento; // Poderia ser LocalDate se o DTO e a entidade usassem

    public ClienteSearchCriteria() {
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public String getDataNascimento() {
        return dataNascimento;
    }

    public void setDataNascimento(String dataNascimento) {
        this.dataNascimento = dataNascimento;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ClienteSearchCriteria that = (ClienteSearchCriteria) o;
        return Objects.equals(nome, that.nome) &&
                Objects.equals(documento, that.documento) &&
                Objects.equals(dataNascimento, that.dataNascimento);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nome, documento, dataNascimento);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\specification\ClienteSpecification.java   |   package br.com.fiap.gs.gsapi.specification   |   class ClienteSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.specification;

import br.com.fiap.gs.gsapi.model.Cliente;
import br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils; // Para StringUtils.hasText

import java.util.ArrayList;
import java.util.List;

public class ClienteSpecification {

    public static Specification<Cliente> fromCriteria(ClienteSearchCriteria criteria) {
        return (root, query, criteriaBuilder) -> {
            if (criteria == null) {
                return criteriaBuilder.conjunction(); // Retorna uma condição sempre verdadeira se não houver critérios
            }

            List<Predicate> predicates = new ArrayList<>();

            if (StringUtils.hasText(criteria.getNome())) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("nome")), "%" + criteria.getNome().toLowerCase() + "%"));
            }
            if (StringUtils.hasText(criteria.getDocumento())) {
                predicates.add(criteriaBuilder.equal(root.get("documento"), criteria.getDocumento()));
            }
            if (StringUtils.hasText(criteria.getDataNascimento())) {
                // Se dataNascimento fosse LocalDate, a comparação seria diferente
                // Ex: criteriaBuilder.equal(root.get("dataNascimento"), criteria.getDataNascimentoAsLocalDate());
                predicates.add(criteriaBuilder.equal(root.get("dataNascimento"), criteria.getDataNascimento()));
            }
            // Adicione outros predicados para outros campos de busca

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\specification\ContatoSpecification.java   |   package br.com.fiap.gs.gsapi.specification   |   class ContatoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.specification
package br.com.fiap.gs.gsapi.specification;

import br.com.fiap.gs.gsapi.model.Contato;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;

public class ContatoSpecification {

    public static Specification<Contato> comFiltros(String email, String tipoContato, String ddd) {
        return (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();

            if (StringUtils.hasText(email)) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("email")), "%" + email.toLowerCase() + "%"));
            }

            if (StringUtils.hasText(tipoContato)) {
                predicates.add(criteriaBuilder.equal(criteriaBuilder.lower(root.get("tipoContato")), tipoContato.toLowerCase()));
            }

            if (StringUtils.hasText(ddd)) {
                predicates.add(criteriaBuilder.equal(root.get("ddd"), ddd));
            }

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }

    // Métodos de especificação individuais (alternativa ou complemento)
    public static Specification<Contato> emailContem(String email) {
        return (root, query, criteriaBuilder) -> {
            if (!StringUtils.hasText(email)) {
                return criteriaBuilder.conjunction();
            }
            return criteriaBuilder.like(criteriaBuilder.lower(root.get("email")), "%" + email.toLowerCase() + "%");
        };
    }

    public static Specification<Contato> tipoContatoIgual(String tipoContato) {
        return (root, query, criteriaBuilder) -> {
            if (!StringUtils.hasText(tipoContato)) {
                return criteriaBuilder.conjunction();
            }
            return criteriaBuilder.equal(criteriaBuilder.lower(root.get("tipoContato")), tipoContato.toLowerCase());
        };
    }

    public static Specification<Contato> dddIgual(String ddd) {
        return (root, query, criteriaBuilder) -> {
            if (!StringUtils.hasText(ddd)) {
                return criteriaBuilder.conjunction();
            }
            return criteriaBuilder.equal(root.get("ddd"), ddd);
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\specification\EnderecoSpecification.java   |   package br.com.fiap.gs.gsapi.specification   |   class EnderecoSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.specification;

import br.com.fiap.gs.gsapi.model.Endereco;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;

public class EnderecoSpecification {

    public static Specification<Endereco> cepContem(String cep) {
        return (root, query, criteriaBuilder) -> {
            if (!StringUtils.hasText(cep)) {
                return criteriaBuilder.conjunction(); // Sempre verdadeiro se o CEP for nulo/vazio
            }
            // Remove não numéricos para busca, caso o CEP no banco também esteja limpo.
            // Se o CEP no banco pode ter "-", a busca precisa ser exata ou o campo do banco também precisa ser tratado na query.
            String cepNumerico = cep.replaceAll("[^0-9]", "");
            return criteriaBuilder.like(root.get("cep"), "%" + cepNumerico + "%");
        };
    }

    public static Specification<Endereco> logradouroContem(String logradouro) {
        return (root, query, criteriaBuilder) -> {
            if (!StringUtils.hasText(logradouro)) {
                return criteriaBuilder.conjunction();
            }
            return criteriaBuilder.like(criteriaBuilder.lower(root.get("logradouro")), "%" + logradouro.toLowerCase() + "%");
        };
    }

    public static Specification<Endereco> localidadeContem(String localidade) {
        return (root, query, criteriaBuilder) -> {
            if (!StringUtils.hasText(localidade)) {
                return criteriaBuilder.conjunction();
            }
            return criteriaBuilder.like(criteriaBuilder.lower(root.get("localidade")), "%" + localidade.toLowerCase() + "%");
        };
    }

    // Exemplo de como combinar múltiplos critérios (não usado diretamente no service.listarTodos da forma como está,
    // mas ilustra como construir uma Specification mais complexa a partir de um objeto de critério)
    // Se você tivesse um EnderecoSearchCriteriaDTO:
    /*
    public static Specification<Endereco> fromCriteria(EnderecoSearchCriteriaDTO criteria) {
        return (root, query, criteriaBuilder) -> {
            if (criteria == null) {
                return criteriaBuilder.conjunction(); 
            }

            List<Predicate> predicates = new ArrayList<>();

            if (StringUtils.hasText(criteria.getCep())) {
                predicates.add(criteriaBuilder.like(root.get("cep"), "%" + criteria.getCep().replaceAll("[^0-9]", "") + "%"));
            }
            if (StringUtils.hasText(criteria.getLogradouro())) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("logradouro")), "%" + criteria.getLogradouro().toLowerCase() + "%"));
            }
            if (StringUtils.hasText(criteria.getLocalidade())) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("localidade")), "%" + criteria.getLocalidade().toLowerCase() + "%"));
            }
            // Adicione outros predicados para outros campos de busca

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }
    */
}

