// Script: converte-classes-java-em-txt-unico (v3)
// Data de criação do arquivo de saída: 2025-05-27 10:10:18

// Estrutura de diretórios do projeto:
src/
    main/
        java/
            br/
                com/
                    fiap/
                        gs/
                            gsapi/
                                client/
                                config/
                                controller/
                                dto/
                                    geocoding/
                                    request/
                                    response/
                                    viacep/
                                exception/
                                mapper/
                                model/
                                repository/
                                service/
                                    search/
        resources/
            static/
            templates/
    test/
        java/
            br/
                com/
                    fiap/
                        gs/
                            gsapi/

// Arquivos encontrados (FQN => caminho relativo):
// br.com.fiap.gs.gsapi.GsapiApplication => main\java\br\com\fiap\gs\gsapi\GsapiApplication.java
// br.com.fiap.gs.gsapi.client.NominatimClient => main\java\br\com\fiap\gs\gsapi\client\NominatimClient.java
// br.com.fiap.gs.gsapi.client.ViaCepClient => main\java\br\com\fiap\gs\gsapi\client\ViaCepClient.java
// br.com.fiap.gs.gsapi.config.AppConfig => main\java\br\com\fiap\gs\gsapi\config\AppConfig.java
// br.com.fiap.gs.gsapi.config.CorsConfig => main\java\br\com\fiap\gs\gsapi\config\CorsConfig.java
// br.com.fiap.gs.gsapi.config.OpenApiConfig => main\java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java
// br.com.fiap.gs.gsapi.config.SwaggerBrowserLauncher => main\java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java
// br.com.fiap.gs.gsapi.controller.ClienteController => main\java\br\com\fiap\gs\gsapi\controller\ClienteController.java
// br.com.fiap.gs.gsapi.controller.EnderecoController => main\java\br\com\fiap\gs\gsapi\controller\EnderecoController.java
// br.com.fiap.gs.gsapi.dto.geocoding.NominatimResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\geocoding\NominatimResponseDTO.java
// br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.EonetEventosRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\EonetEventosRequestDTO.java
// br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.EonetEventoResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\EonetEventoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.viacep.ViaCepResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\viacep\ViaCepResponseDTO.java
// br.com.fiap.gs.gsapi.exception.GlobalExceptionHandler => main\java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java
// br.com.fiap.gs.gsapi.exception.ResourceNotFoundException => main\java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java
// br.com.fiap.gs.gsapi.mapper.ClienteMapper => main\java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java
// br.com.fiap.gs.gsapi.mapper.ContatoMapper => main\java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java
// br.com.fiap.gs.gsapi.mapper.EnderecoMapper => main\java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java
// br.com.fiap.gs.gsapi.mapper.EonetEventoMapper => main\java\br\com\fiap\gs\gsapi\mapper\EonetEventoMapper.java
// br.com.fiap.gs.gsapi.model.Cliente => main\java\br\com\fiap\gs\gsapi\model\Cliente.java
// br.com.fiap.gs.gsapi.model.Contato => main\java\br\com\fiap\gs\gsapi\model\Contato.java
// br.com.fiap.gs.gsapi.model.Endereco => main\java\br\com\fiap\gs\gsapi\model\Endereco.java
// br.com.fiap.gs.gsapi.model.EonetEventos => main\java\br\com\fiap\gs\gsapi\model\EonetEventos.java
// br.com.fiap.gs.gsapi.repository.ClienteRepository => main\java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java
// br.com.fiap.gs.gsapi.repository.ContatoRepository => main\java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java
// br.com.fiap.gs.gsapi.repository.EnderecoRepository => main\java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java
// br.com.fiap.gs.gsapi.repository.EonetEventoRepository => main\java\br\com\fiap\gs\gsapi\repository\EonetEventoRepository.java
// br.com.fiap.gs.gsapi.service.ClienteService => main\java\br\com\fiap\gs\gsapi\service\ClienteService.java
// br.com.fiap.gs.gsapi.service.EnderecoGeocodingService => main\java\br\com\fiap\gs\gsapi\service\EnderecoGeocodingService.java
// br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria => main\java\br\com\fiap\gs\gsapi\service\search\ClienteSearchCriteria.java
// br.com.fiap.gs.gsapi.service.search.ClienteSpecification => main\java\br\com\fiap\gs\gsapi\service\search\ClienteSpecification.java
// br.com.fiap.gs.gsapi.service.search.ContatoSearchCriteria => main\java\br\com\fiap\gs\gsapi\service\search\ContatoSearchCriteria.java

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\GsapiApplication.java   |   package br.com.fiap.gs.gsapi   |   class GsapiApplication
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching; // Import para habilitar o cache
// import org.springframework.data.jpa.repository.config.EnableJpaAuditing; // Opcional: para auditoria

@SpringBootApplication
@EnableCaching // Habilita o suporte a cache do Spring
// @EnableJpaAuditing // Descomente se for usar auditoria JPA (ex: @CreatedDate, @LastModifiedDate)
public class GsapiApplication {

	public static void main(String[] args) {
		SpringApplication.run(GsapiApplication.class, args);
	}

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\client\NominatimClient.java   |   package br.com.fiap.gs.gsapi.client   |   class NominatimClient
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.client
package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.geocoding.NominatimResponseDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Flux;
import reactor.util.retry.Retry;

import java.time.Duration;

@Component
public class NominatimClient {

    private static final Logger logger = LoggerFactory.getLogger(NominatimClient.class);
    private final WebClient webClient;

    // Configure no application.properties: app.geocoding.user-agent=SuaApp/1.0 (seu.email@example.com)
    // É OBRIGATÓRIO para Nominatim.
    @Value("${app.geocoding.user-agent:GSAPIDefaultApp/1.0 (fiap.gs@example.com)}")
    private String userAgent;

    private static final String NOMINATIM_BASE_URL = "https://nominatim.openstreetmap.org";

    @Autowired
    public NominatimClient(WebClient.Builder webClientBuilder) {
        // O User-Agent será definido no momento da requisição para garantir que o valor de @Value seja injetado
        this.webClient = webClientBuilder.baseUrl(NOMINATIM_BASE_URL).build();
    }

    public Flux<NominatimResponseDTO> buscarCoordenadasPorEndereco(String logradouro, String numero, String bairro, String cidade, String estado, String cep) {
        // Monta a query string de forma mais estruturada.
        // A API do Nominatim é sensível à formatação da query.
        // Usar parâmetros separados pode ser mais eficaz do que uma string única 'q'.
        logger.info("Buscando coordenadas no Nominatim para: Rua='{}', Num='{}', Bairro='{}', Cidade='{}', Estado='{}', CEP='{}'",
                logradouro, numero, bairro, cidade, estado, cep);
        logger.info("Usando User-Agent para Nominatim: {}", this.userAgent);

        return this.webClient.get()
                .uri(uriBuilder -> uriBuilder.path("/search")
                        // Parâmetros de busca estruturada
                        .queryParam("street", (numero != null && !numero.trim().isEmpty() ? numero + " " : "") + logradouro)
                        .queryParam("city", cidade)
                        .queryParam("county", bairro) // 'county' é frequentemente usado para bairro/distrito no OSM
                        .queryParam("state", estado)
                        .queryParam("country", "Brazil")
                        .queryParam("postalcode", cep)
                        // Parâmetros de controle
                        .queryParam("format", "jsonv2") // jsonv2 é geralmente mais consistente
                        .queryParam("addressdetails", "1")
                        .queryParam("limit", "1") // Pega o resultado mais relevante
                        .build())
                .header(HttpHeaders.USER_AGENT, this.userAgent) // Adiciona o User-Agent aqui
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToFlux(NominatimResponseDTO.class)
                .timeout(Duration.ofSeconds(10)) // Timeout para a requisição
                .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).maxBackoff(Duration.ofSeconds(5))
                        .filter(throwable -> throwable instanceof WebClientResponseException.TooManyRequests) // Exemplo de retry para 429
                        .doBeforeRetry(retrySignal -> logger.warn("Nominatim API rate limit atingido, tentando novamente... Tentativa {}", retrySignal.totalRetries() + 1))
                )
                .doOnError(WebClientResponseException.class, error ->
                        logger.error("Erro HTTP ao chamar Nominatim API: Status {}, Resposta: {}", error.getStatusCode(), error.getResponseBodyAsString(), error))
                .doOnError(error -> !(error instanceof WebClientResponseException), error -> // Loga outros erros
                        logger.error("Erro inesperado ao chamar Nominatim API: {}", error.getMessage(), error))
                .onErrorResume(error -> {
                    logger.warn("Falha ao buscar coordenadas no Nominatim após tentativas. Retornando vazio.");
                    return Flux.empty(); // Retorna vazio em caso de erro final para não quebrar o fluxo
                });
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\client\ViaCepClient.java   |   package br.com.fiap.gs.gsapi.client   |   class ViaCepClient
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.client
package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.viacep.ViaCepResponseDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

@Component
public class ViaCepClient {

    private static final Logger logger = LoggerFactory.getLogger(ViaCepClient.class);
    private final RestTemplate restTemplate;
    private static final String VIA_CEP_URL = "https://viacep.com.br/ws/{cep}/json/";

    @Autowired
    public ViaCepClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public ViaCepResponseDTO buscarEnderecoPorCep(String cep) {
        if (cep == null || cep.trim().isEmpty()) {
            logger.warn("Tentativa de buscar CEP nulo ou vazio.");
            return null;
        }
        // Remove caracteres não numéricos do CEP
        String cepNumerico = cep.replaceAll("[^0-9]", "");
        if (cepNumerico.length() != 8) {
            logger.warn("CEP inválido fornecido: '{}'. CEP numérico processado: '{}'. Deve conter 8 dígitos.", cep, cepNumerico);
            return null; // Ou lançar uma exceção de argumento inválido
        }

        try {
            logger.info("Buscando endereço na API ViaCEP para o CEP: {}", cepNumerico);
            ViaCepResponseDTO response = restTemplate.getForObject(VIA_CEP_URL, ViaCepResponseDTO.class, cepNumerico);

            if (response != null && response.isErro()) {
                logger.warn("CEP {} não encontrado ou inválido na API ViaCEP (retornou erro=true).", cepNumerico);
                return null; // CEP não encontrado pela API
            }
            if (response != null && response.getCep() == null) { // Outra forma de ViaCEP indicar erro para CEPs inexistentes
                logger.warn("CEP {} não resultou em dados válidos na API ViaCEP (campos nulos).", cepNumerico);
                return null;
            }

            logger.info("Endereço encontrado para o CEP {}: {}", cepNumerico, (response != null && response.getLocalidade() != null) ? response.getLocalidade() : "N/A");
            return response;
        } catch (HttpClientErrorException e) {
            logger.error("Erro HTTP ao chamar a API ViaCEP para o CEP {}: Status {} - Resposta: {}", cepNumerico, e.getStatusCode(), e.getResponseBodyAsString(), e);
            return null;
        } catch (RestClientException e) {
            logger.error("Erro de conectividade ou outro erro do RestClient ao chamar a API ViaCEP para o CEP {}: {}", cepNumerico, e.getMessage(), e);
            return null;
        } catch (Exception e) {
            logger.error("Erro inesperado ao processar a resposta da API ViaCEP para o CEP {}: {}", cepNumerico, e.getMessage(), e);
            return null;
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\AppConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class AppConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.Duration;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        // Configura o RestTemplate com um timeout e um interceptor para logging (opcional)
        // BufferingClientHttpRequestFactory é útil se você quiser logar o corpo da requisição/resposta
        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
        requestFactory.setConnectTimeout((int) Duration.ofSeconds(10).toMillis());
        requestFactory.setReadTimeout((int) Duration.ofSeconds(10).toMillis());

        return builder
                .requestFactory(() -> new BufferingClientHttpRequestFactory(requestFactory))
                // .additionalInterceptors(new LoggingClientHttpRequestInterceptor()) // Crie esta classe se quiser logar
                .build();
    }

    @Bean
    public WebClient.Builder webClientBuilder() {
        // Configurações padrão para o WebClient.Builder, se necessário
        // Ex: timeouts, codecs, etc. podem ser configurados aqui globalmente
        // ou no momento da construção do WebClient específico.
        return WebClient.builder();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\CorsConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class CorsConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;
import java.util.List;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    private final Environment environment;

    // Origens permitidas para produção (leia do application.properties)
    // Ex: cors.production.allowed.origins=https://meufrontend.com,https://outrofrontend.com
    @Value("${cors.production.allowed.origins:}")
    private String[] productionAllowedOrigins;

    // Origens permitidas para desenvolvimento (pode ser fixo ou também configurável)
    @Value("${cors.development.allowed.origins:http://localhost:3000,http://localhost:3001,http://127.0.0.1:3000,http://127.0.0.1:3001}")
    private String[] developmentAllowedOrigins;

    public CorsConfig(Environment environment) {
        this.environment = environment;
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
        String[] allowedOriginsToUse;

        if (isProdProfileActive) {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÇÃO DE CORS PARA PRODUÇÃO <<<<<<<<<<");
            if (productionAllowedOrigins != null && productionAllowedOrigins.length > 0 &&
                    Arrays.stream(productionAllowedOrigins).anyMatch(origin -> origin != null && !origin.trim().isEmpty())) {
                allowedOriginsToUse = Arrays.stream(productionAllowedOrigins)
                        .filter(origin -> origin != null && !origin.trim().isEmpty())
                        .toArray(String[]::new);
                System.out.println("Allowed Origins (prod): " + String.join(", ", allowedOriginsToUse));
            } else {
                System.out.println("WARN: Nenhuma origem de produção VÁLIDA configurada para CORS (cors.production.allowed.origins). CORS estará altamente restrito.");
                // Por segurança, defina um fallback restrito ou nenhuma origem se não configurado
                allowedOriginsToUse = new String[]{}; // Ou uma URL de fallback muito específica
            }
        } else {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÇÃO DE CORS PARA DESENVOLVIMENTO/PADRÃO <<<<<<<<<<");
            allowedOriginsToUse = developmentAllowedOrigins;
            System.out.println("Allowed Origins (dev/default): " + String.join(", ", allowedOriginsToUse));
        }

        if (allowedOriginsToUse.length > 0) {
            registry.addMapping("/**") // Aplica a todas as rotas da API
                    .allowedOrigins(allowedOriginsToUse)
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD")
                    .allowedHeaders("*") // Permite todos os cabeçalhos
                    .allowCredentials(true) // Importante se você usar cookies ou autenticação baseada em sessão
                    .maxAge(3600); // Tempo em segundos que o resultado de uma requisição pre-flight OPTIONS pode ser cacheado
        } else if (isProdProfileActive) {
            // Se em produção e nenhuma origem válida foi configurada, não adicione nenhum mapping de CORS
            // ou adicione um muito restritivo para bloquear por padrão.
            System.out.println("WARN: CORS em produção está bloqueado pois nenhuma origem válida foi configurada.");
        }
    }

    // Alternativamente, você pode usar um CorsFilter Bean se preferir uma configuração mais programática
    // ou se precisar de mais controle sobre a ordem dos filtros.
    // @Bean
    // public CorsFilter corsFilter() {
    //     UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    //     CorsConfiguration config = new CorsConfiguration();
    //     config.setAllowCredentials(true);
    //
    //     boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
    //     if (isProdProfileActive && productionAllowedOrigins != null && productionAllowedOrigins.length > 0) {
    //         config.setAllowedOrigins(Arrays.asList(productionAllowedOrigins));
    //     } else {
    //         config.setAllowedOrigins(Arrays.asList(developmentAllowedOrigins)); // Ou use allowedOriginPatterns
    //     }
    //
    //     config.addAllowedHeader("*");
    //     config.addAllowedMethod("*"); // GET, POST, PUT, DELETE, etc.
    //     source.registerCorsConfiguration("/**", config);
    //     return new CorsFilter(source);
    // }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class OpenApiConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

/**
 * Classe de configuração do Springdoc OpenAPI para definir as informações detalhadas da API.
 * Isso inclui título, versão, descrição, informações de contato e licença,
 * que serão exibidos na interface do Swagger UI.
 */
@Configuration
public class OpenApiConfig {

    private static final Logger log = LoggerFactory.getLogger(OpenApiConfig.class);

    // Você pode injetar valores do application.properties se precisar
    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    @Bean
    public OpenAPI customOpenAPI() {
        log.info("🔧 Configuração personalizada do OpenAPI inicializada.");

        // Constrói a URL base do servidor dinamicamente
        String serverUrl = "http://localhost:" + serverPort + (contextPath != null ? contextPath : "");

        return new OpenAPI()
                .info(new Info()
                        .title("GS API - Alertas de Desastres Naturais") // Título da sua API
                        .version("v1.0.0") // Versão da sua API
                        .description("""
                                **API RESTful para o Global Solution FIAP 2025**

                                Esta API fornece funcionalidades para consulta de informações sobre desastres naturais
                                e gerenciamento de alertas para usuários com base em sua localização.
                                Integração com a API EONET da NASA e serviços de geolocalização.

                                **Funcionalidades Principais:**
                                - Cadastro e gerenciamento de clientes e seus endereços.
                                - Consulta de eventos de desastres naturais (via EONET).
                                - Associação de eventos de desastres a endereços de clientes.
                                - Visualização de alertas em mapas (a ser implementado no frontend).
                                """)
                        .contact(new Contact()
                                .name("Equipe GS API") // Nome da sua equipe ou seu nome
                                .email("seu-email@fiap.com.br") // Seu email de contato
                                .url("https://github.com/seu-usuario/gs-api-repo") // URL do seu projeto no GitHub
                        )
                        .license(new License()
                                .name("Apache 2.0") // Ou a licença que você escolher
                                .url("https://www.apache.org/licenses/LICENSE-2.0.html")
                        )
                )
                .servers(List.of(
                        new Server().url(serverUrl).description("Servidor Local de Desenvolvimento")
                        // Você pode adicionar outros servidores aqui (ex: homologação, produção)
                        // new Server().url("https://api.seudominio.com/gsapi").description("Servidor de Produção")
                ));
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java   |   package br.com.fiap.gs.gsapi.config   |   class SwaggerBrowserLauncher
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.EventListener;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Componente para abrir automaticamente o Swagger UI no navegador
 * quando a aplicação inicia em um perfil de desenvolvimento.
 */
@Configuration
@Profile("dev") // Ativa este componente apenas quando o perfil 'dev' estiver ativo
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    // O caminho padrão do Swagger UI é geralmente /swagger-ui/index.html ou /swagger-ui.html
    // Verifique a propriedade springdoc.swagger-ui.path se você a customizou
    @Value("${springdoc.swagger-ui.path:/swagger-ui.html}")
    private String swaggerUiPath;

    @Value("${app.launch-swagger-on-startup:true}") // Propriedade customizada para controlar o lançamento
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automática do Swagger UI no navegador está desabilitada via app.launch-swagger-on-startup=false.");
            return;
        }

        // Constrói a URL completa, garantindo que o contextPath seja tratado corretamente
        String effectiveContextPath = (contextPath == null || "/".equals(contextPath)) ? "" : contextPath;
        String effectiveSwaggerUiPath = swaggerUiPath.startsWith("/") ? swaggerUiPath : "/" + swaggerUiPath;

        String url = "http://localhost:" + serverPort + effectiveContextPath + effectiveSwaggerUiPath;
        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI: {}", url);
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI (URL: {}): {}", url, e.getMessage(), e);
            }
        } else {
            log.warn("Abertura automática do navegador não é suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\controller\ClienteController.java   |   package br.com.fiap.gs.gsapi.controller   |   class ClienteController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.controller
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.exception.GlobalExceptionHandler; // Para referência no Swagger
import br.com.fiap.gs.gsapi.service.ClienteService;
import br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria; // Para busca por parâmetros

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springdoc.core.annotations.ParameterObject; // Para agrupar parâmetros de paginação e filtro no Swagger

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/api/v1/clientes")
@Tag(name = "Clientes", description = "Endpoints para gerenciamento de clientes e suas informações relacionadas.")
public class ClienteController {

    private final ClienteService clienteService;

    @Autowired
    public ClienteController(ClienteService clienteService) {
        this.clienteService = clienteService;
    }

    @Operation(
            summary = "Listar todos os clientes com paginação, ordenação e filtros.",
            description = "Retorna uma lista paginada de clientes. Permite filtrar por nome (parcial, case-insensitive), " +
                    "documento (exato) e data de nascimento (exato, formato YYYY-MM-DD ou como definido na entidade). " +
                    "Parâmetros de paginação padrão: `page=0`, `size=10`. Parâmetro de ordenação padrão: `sort=nome,asc`."
    )
    @Parameters({
            @Parameter(name = "page", description = "Número da página (começa em 0)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
            @Parameter(name = "size", description = "Tamanho da página", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
            @Parameter(name = "sort", description = "Critério de ordenação (ex: nome,asc ou nome,desc ou multiplos: nome,asc&sort=documento,desc)", in = ParameterIn.QUERY, schema = @Schema(type = "string", example = "nome,asc"))
            // Os parâmetros de ClienteSearchCriteria (nome, documento, dataNascimento) serão documentados automaticamente pelo @ParameterObject
    })
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de clientes encontrada.",
                    content = @Content(mediaType = "application/json",
                            schema = @Schema(implementation = Page.class))) // Idealmente, o Swagger mostraria Page<ClienteResponseDTO>
    })
    @GetMapping
    public ResponseEntity<Page<ClienteResponseDTO>> listarTodosClientes(
            @ParameterObject @Valid ClienteSearchCriteria criteria, // Parâmetros de filtro agrupados e validados
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) {
        Page<ClienteResponseDTO> clientes = clienteService.listarTodos(criteria, pageable); // CORRIGIDO: Passando criteria
        return ResponseEntity.ok(clientes);
    }

    @Operation(summary = "Buscar cliente por ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Cliente encontrado.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class))),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @GetMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> buscarClientePorId(
            @Parameter(description = "ID do cliente a ser buscado.", required = true, example = "1") @PathVariable Long id) {
        ClienteResponseDTO cliente = clienteService.buscarPorId(id);
        return ResponseEntity.ok(cliente);
    }

    @Operation(summary = "Criar um novo cliente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "Requisição inválida devido a erro de validação ou regra de negócio (ex: documento duplicado).", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PostMapping
    public ResponseEntity<ClienteResponseDTO> criarCliente(
            @Parameter(description = "Dados do cliente para criação.", required = true,
                    content = @Content(schema = @Schema(implementation = ClienteRequestDTO.class)))
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO) {
        ClienteResponseDTO clienteSalvo = clienteService.criar(clienteRequestDTO);
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(clienteSalvo.getIdCliente())
                .toUri();
        return ResponseEntity.created(location).body(clienteSalvo);
    }

    @Operation(summary = "Atualizar um cliente existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Cliente atualizado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "Requisição inválida devido a erro de validação ou regra de negócio.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class))),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PutMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> atualizarCliente(
            @Parameter(description = "ID do cliente a ser atualizado.", required = true, example = "1") @PathVariable Long id,
            @Parameter(description = "Dados do cliente para atualização.", required = true,
                    content = @Content(schema = @Schema(implementation = ClienteRequestDTO.class)))
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO) {
        ClienteResponseDTO clienteAtualizado = clienteService.atualizar(id, clienteRequestDTO);
        return ResponseEntity.ok(clienteAtualizado);
    }

    @Operation(summary = "Deletar um cliente por ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Cliente deletado com sucesso.", content = @Content),
            @ApiResponse(responseCode = "404", description = "Cliente não encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarCliente(
            @Parameter(description = "ID do cliente a ser deletado.", required = true, example = "1") @PathVariable Long id) {
        clienteService.deletar(id);
        return ResponseEntity.noContent().build();
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\controller\EnderecoController.java   |   package br.com.fiap.gs.gsapi.controller   |   class EnderecoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.controller
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.mapper.EnderecoMapper;
import br.com.fiap.gs.gsapi.model.Endereco;
import br.com.fiap.gs.gsapi.service.EnderecoGeocodingService; // Importe o novo serviço
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

@RestController
@RequestMapping("/api/v1/enderecos") // Ou um endpoint base mais apropriado
@Tag(name = "Endereços", description = "Endpoints para gerenciamento e consulta de endereços")
public class EnderecoController {

    private final EnderecoGeocodingService enderecoGeocodingService;
    private final EnderecoMapper enderecoMapper;
    // Injete outros serviços e repositórios de Endereço se tiver CRUD completo para Endereço

    @Autowired
    public EnderecoController(EnderecoGeocodingService enderecoGeocodingService, EnderecoMapper enderecoMapper) {
        this.enderecoGeocodingService = enderecoGeocodingService;
        this.enderecoMapper = enderecoMapper;
    }

    @Operation(summary = "Buscar endereço completo por CEP e número",
            description = "Busca dados do endereço usando ViaCEP e tenta obter coordenadas de geolocalização. " +
                    "O número é importante para a precisão da geolocalização.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Endereço encontrado e geocodificado (se possível)",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "CEP inválido", content = @Content),
            @ApiResponse(responseCode = "404", description = "CEP não encontrado ou endereço não pôde ser geocodificado", content = @Content)
    })
    @GetMapping("/cep/{cep}")
    public ResponseEntity<EnderecoResponseDTO> buscarEnderecoCompletoPorCep(
            @Parameter(description = "CEP a ser consultado (apenas números ou formatado)", required = true, example = "01001000")
            @PathVariable String cep,
            @Parameter(description = "Número do endereço para geolocalização mais precisa", required = true, example = "100")
            @RequestParam String numero,
            @Parameter(description = "Complemento do endereço (opcional)", example = "Apto 101")
            @RequestParam(required = false) String complemento) {

        if (cep == null || cep.replaceAll("[^0-9]", "").length() != 8) {
            return ResponseEntity.badRequest().build(); // Validação básica do CEP
        }
        if (numero == null || numero.trim().isEmpty()) {
            return ResponseEntity.badRequest().build(); // Número é crucial para geocodificação
        }

        Optional<Endereco> enderecoCompleto = enderecoGeocodingService.obterOuCriarEnderecoCompleto(cep, numero, complemento);

        return enderecoCompleto
                .map(endereco -> ResponseEntity.ok(enderecoMapper.toEnderecoResponseDTO(endereco)))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    // Aqui você adicionaria outros endpoints CRUD para Endereço, se necessário,
    // usando um EnderecoService dedicado para a lógica de negócio do Endereço.
    // Ex: POST para criar um novo endereço manualmente, PUT para atualizar, GET /id, GET (listagem), DELETE.
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\geocoding\NominatimResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.geocoding   |   class NominatimResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.geocoding
package br.com.fiap.gs.gsapi.dto.geocoding;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

// Ignora propriedades desconhecidas no JSON para evitar erros de deserialização
@JsonIgnoreProperties(ignoreUnknown = true)
public class NominatimResponseDTO {

    @JsonProperty("place_id")
    private String placeId;

    @JsonProperty("lat")
    private String latitude;

    @JsonProperty("lon")
    private String longitude;

    @JsonProperty("display_name")
    private String displayName;

    // Adicionar mais campos se necessário, como 'address' para detalhes
    // @JsonProperty("address")
    // private NominatimAddressDetailsDTO addressDetails;

    // Construtor padrão
    public NominatimResponseDTO() {
    }

    // Getters e Setters
    public String getPlaceId() { return placeId; }
    public void setPlaceId(String placeId) { this.placeId = placeId; }
    public String getLatitude() { return latitude; }
    public void setLatitude(String latitude) { this.latitude = latitude; }
    public String getLongitude() { return longitude; }
    public void setLongitude(String longitude) { this.longitude = longitude; }
    public String getDisplayName() { return displayName; }
    public void setDisplayName(String displayName) { this.displayName = displayName; }
    // public NominatimAddressDetailsDTO getAddressDetails() { return addressDetails; }
    // public void setAddressDetails(NominatimAddressDetailsDTO addressDetails) { this.addressDetails = addressDetails; }

    // DTO aninhado para detalhes do endereço, se você precisar deles
    // @JsonIgnoreProperties(ignoreUnknown = true)
    // public static class NominatimAddressDetailsDTO {
    //     private String road;
    //     private String suburb; // Bairro
    //     private String city;
    //     private String state;
    //     private String postcode;
    //     private String country;
    //     // Getters e Setters
    // }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class ClienteRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
// importe outras anotações de validação conforme necessário

public class ClienteRequestDTO {

    @NotBlank(message = "O nome não pode estar em branco")
    @Size(max = 100, message = "O nome deve ter no máximo 100 caracteres")
    private String nome;

    @NotBlank(message = "O sobrenome não pode estar em branco")
    @Size(max = 100, message = "O sobrenome deve ter no máximo 100 caracteres")
    private String sobrenome;

    @NotBlank(message = "A data de nascimento não pode estar em branco")
    @Size(max = 10, message = "A data de nascimento deve ter no máximo 10 caracteres") // Ou use @Pattern para formato
    private String dataNascimento;

    @NotBlank(message = "O documento não pode estar em branco")
    @Size(max = 18, message = "O documento deve ter no máximo 18 caracteres")
    private String documento;

    // Relacionamentos (contatos, endereços) geralmente são gerenciados
    // através de IDs em DTOs ou por endpoints separados.
    // Ex: private Set<Long> idsContatos;
    // Ou você pode aninhar CreateContatoRequestDTO etc., mas pode ficar complexo.

    public ClienteRequestDTO() {
    }

    // Construtor, Getters e Setters
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class ContatoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.request

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class ContatoRequestDTO {

    @NotBlank(message = "O DDD não pode estar em branco")
    @Size(min = 2, max = 3, message = "O DDD deve ter entre 2 e 3 caracteres")
    private String ddd;

    @NotBlank(message = "O telefone não pode estar em branco")
    @Size(min = 8, max = 15, message = "O telefone deve ter entre 8 e 15 caracteres")
    @Pattern(regexp = "^[0-9]+$", message = "O telefone deve conter apenas números")
    private String telefone;

    @Size(min = 9, max = 15, message = "O celular deve ter entre 9 e 15 caracteres")
    @Pattern(regexp = "^[0-9]+$", message = "O celular deve conter apenas números")
    private String celular; // Pode ser opcional dependendo da regra de negócio

    @Size(min = 9, max = 15, message = "O WhatsApp deve ter entre 9 e 15 caracteres")
    @Pattern(regexp = "^[0-9]+$", message = "O WhatsApp deve conter apenas números")
    private String whatsapp; // Pode ser opcional

    @NotBlank(message = "O email não pode estar em branco")
    @Email(message = "Formato de email inválido")
    @Size(max = 255, message = "O email deve ter no máximo 255 caracteres")
    private String email;

    @NotBlank(message = "O tipo de contato não pode estar em branco")
    @Size(max = 50, message = "O tipo de contato deve ter no máximo 50 caracteres")
    private String tipoContato;

    public ContatoRequestDTO() {
    }

    public ContatoRequestDTO(String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    public String getDdd() {
        return ddd;
    }

    public void setDdd(String ddd) {
        this.ddd = ddd;
    }

    public String getTelefone() {
        return telefone;
    }

    public void setTelefone(String telefone) {
        this.telefone = telefone;
    }

    public String getCelular() {
        return celular;
    }

    public void setCelular(String celular) {
        this.celular = celular;
    }

    public String getWhatsapp() {
        return whatsapp;
    }

    public void setWhatsapp(String whatsapp) {
        this.whatsapp = whatsapp;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getTipoContato() {
        return tipoContato;
    }

    public void setTipoContato(String tipoContato) {
        this.tipoContato = tipoContato;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class EnderecoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.request

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.DecimalMax;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Digits;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public class EnderecoRequestDTO {

    @NotBlank(message = "O CEP não pode estar em branco")
    @Size(min = 8, max = 9, message = "O CEP deve ter entre 8 e 9 caracteres (ex: 00000-000 ou 00000000)")
    private String cep;

    @NotNull(message = "O número não pode ser nulo")
    @Min(value = 1, message = "O número deve ser no mínimo 1")
    @Max(value = 99999, message = "O número deve ser no máximo 99999") // Conforme DDL NUMBER(5)
    private int numero;

    @NotBlank(message = "O logradouro não pode estar em branco")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres")
    private String logradouro;

    @NotBlank(message = "O bairro não pode estar em branco")
    @Size(max = 255, message = "O bairro deve ter no máximo 255 caracteres")
    private String bairro;

    @NotBlank(message = "A localidade não pode estar em branco")
    @Size(max = 100, message = "A localidade deve ter no máximo 100 caracteres")
    private String localidade;

    @NotBlank(message = "A UF não pode estar em branco")
    @Size(min = 2, max = 2, message = "A UF deve ter 2 caracteres")
    private String uf;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres")
    private String complemento; // Complemento é opcional

    @NotNull(message = "A latitude não pode ser nula")
    @DecimalMin(value = "-90.0", message = "Latitude mínima é -90.0")
    @DecimalMax(value = "90.0", message = "Latitude máxima é 90.0")
    @Digits(integer = 3, fraction = 7, message = "Latitude deve ter até 3 dígitos inteiros e 7 fracionários") // Para NUMBER(10,7)
    private Double latitude;

    @NotNull(message = "A longitude não pode ser nula")
    @DecimalMin(value = "-180.0", message = "Longitude mínima é -180.0")
    @DecimalMax(value = "180.0", message = "Longitude máxima é 180.0")
    @Digits(integer = 3, fraction = 7, message = "Longitude deve ter até 3 dígitos inteiros e 7 fracionários") // Para NUMBER(10,7)
    private Double longitude;

    public EnderecoRequestDTO() {
    }

    public EnderecoRequestDTO(String cep, int numero, String logradouro, String bairro, String localidade, String uf, String complemento, Double latitude, Double longitude) {
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public int getNumero() { return numero; }
    public void setNumero(int numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public Double getLatitude() { return latitude; }
    public void setLatitude(Double latitude) { this.latitude = latitude; }
    public Double getLongitude() { return longitude; }
    public void setLongitude(Double longitude) { this.longitude = longitude; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\EonetEventosRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class EonetEventosRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.request

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.time.Instant;

public class EonetEventosRequestDTO {

    @NotBlank(message = "O ID original da EONET (eonetApiId) não pode estar em branco.")
    @Size(max = 50, message = "O ID da EONET deve ter no máximo 50 caracteres.")
    private String eonetApiId; // O ID original da API EONET (ex: "EONET_12345")

    @NotBlank(message = "O payload JSON do evento (jsonEvento) não pode estar em branco.")
    // Não há uma anotação de tamanho padrão para CLOB em DTOs,
    // mas a validação de ser um JSON válido ocorreria na camada de serviço ou ao persistir.
    private String jsonEvento; // O JSON completo do evento

    @NotNull(message = "A data do evento/ingestão não pode ser nula.")
    private Instant data; // A coluna 'data' da sua tabela gs_eonet (TIMESTAMP WITH LOCAL TIME ZONE)

    public EonetEventosRequestDTO() {
    }

    public EonetEventosRequestDTO(String eonetApiId, String jsonEvento, Instant data) {
        this.eonetApiId = eonetApiId;
        this.jsonEvento = jsonEvento;
        this.data = data;
    }

    public String getEonetApiId() {
        return eonetApiId;
    }

    public void setEonetApiId(String eonetApiId) {
        this.eonetApiId = eonetApiId;
    }

    public String getJsonEvento() {
        return jsonEvento;
    }

    public void setJsonEvento(String jsonEvento) {
        this.jsonEvento = jsonEvento;
    }

    public Instant getData() {
        return data;
    }

    public void setData(Instant data) {
        this.data = data;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class ClienteResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

import java.util.Set;
// Supondo que você também crie ContatoResponseDTO e EnderecoResponseDTO
// import br.com.fiap.gs.gsapi.dto.ContatoResponseDTO;
// import br.com.fiap.gs.gsapi.dto.EnderecoResponseDTO;

public class ClienteResponseDTO {
    private long idCliente;
    private String nome;
    private String sobrenome;
    private String dataNascimento;
    private String documento;
    private Set<ContatoResponseDTO> contatos;   // Usar DTOs para objetos aninhados
    private Set<EnderecoResponseDTO> enderecos; // Usar DTOs para objetos aninhados

    public ClienteResponseDTO() {
    }

    // Construtor, Getters e Setters
    public long getIdCliente() { return idCliente; }
    public void setIdCliente(long idCliente) { this.idCliente = idCliente; }
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }
    public Set<ContatoResponseDTO> getContatos() { return contatos; }
    public void setContatos(Set<ContatoResponseDTO> contatos) { this.contatos = contatos; }
    public Set<EnderecoResponseDTO> getEnderecos() { return enderecos; }
    public void setEnderecos(Set<EnderecoResponseDTO> enderecos) { this.enderecos = enderecos; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class ContatoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

public class ContatoResponseDTO {
    private long idContato;
    private String ddd;
    private String telefone;
    private String celular;
    private String whatsapp;
    private String email;
    private String tipoContato;

    public ContatoResponseDTO() {
    }
    // Construtor, Getters e Setters
    public long getIdContato() { return idContato; }
    public void setIdContato(long idContato) { this.idContato = idContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class EnderecoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.response

package br.com.fiap.gs.gsapi.dto.response;

import java.util.Set;

public class EnderecoResponseDTO {
    private long idEndereco;
    private String cep;
    private int numero;
    private String logradouro;
    private String bairro;
    private String localidade;
    private String uf;
    private String complemento;
    private double latitude;
    private double longitude;
    private Set<EonetEventoResponseDTO> eonetEventos; // Assumindo que você terá um DTO para EonetEventos

    public EnderecoResponseDTO() {
    }

    // Construtor, Getters e Setters
    public long getIdEndereco() { return idEndereco; }
    public void setIdEndereco(long idEndereco) { this.idEndereco = idEndereco; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public int getNumero() { return numero; }
    public void setNumero(int numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public double getLatitude() { return latitude; }
    public void setLatitude(double latitude) { this.latitude = latitude; }
    public double getLongitude() { return longitude; }
    public void setLongitude(double longitude) { this.longitude = longitude; }
    public Set<EonetEventoResponseDTO> getEonetEventos() { return eonetEventos; }
    public void setEonetEventos(Set<EonetEventoResponseDTO> eonetEventos) { this.eonetEventos = eonetEventos; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\EonetEventoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class EonetEventoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.response

package br.com.fiap.gs.gsapi.dto.response;

import java.time.Instant;

public class EonetEventoResponseDTO {
    private long idEonet; // PK numérica interna da sua tabela gs_eonet
    private String eonetApiId; // O ID original da API EONET (ex: "EONET_12345")
    private Instant data; // A coluna 'data' da sua tabela gs_eonet (TIMESTAMP WITH LOCAL TIME ZONE)

    // Campos que seriam extraídos do JSON na camada de serviço/mapper
    private String tituloEvento;
    private String linkEvento;
    private Instant dataOcorrenciaOriginalEonet; // A data do evento conforme reportado pela EONET (pode ser diferente da sua 'data' de ingestão)
    private String categoriaPrincipal; // Exemplo: "Wildfires", "Severe Storms"

    // Não inclua o campo 'jsonEvento' (CLOB) aqui.

    public EonetEventoResponseDTO() {
    }

    // Construtor, Getters e Setters
    public long getIdEonet() { return idEonet; }
    public void setIdEonet(long idEonet) { this.idEonet = idEonet; }
    public String getEonetApiId() { return eonetApiId; }
    public void setEonetApiId(String eonetApiId) { this.eonetApiId = eonetApiId; }
    public Instant getData() { return data; }
    public void setData(Instant data) { this.data = data; }
    public String getTituloEvento() { return tituloEvento; }
    public void setTituloEvento(String tituloEvento) { this.tituloEvento = tituloEvento; }
    public String getLinkEvento() { return linkEvento; }
    public void setLinkEvento(String linkEvento) { this.linkEvento = linkEvento; }
    public Instant getDataOcorrenciaOriginalEonet() { return dataOcorrenciaOriginalEonet; }
    public void setDataOcorrenciaOriginalEonet(Instant dataOcorrenciaOriginalEonet) { this.dataOcorrenciaOriginalEonet = dataOcorrenciaOriginalEonet; }
    public String getCategoriaPrincipal() { return categoriaPrincipal; }
    public void setCategoriaPrincipal(String categoriaPrincipal) { this.categoriaPrincipal = categoriaPrincipal; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\viacep\ViaCepResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.viacep   |   class ViaCepResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.viacep
package br.com.fiap.gs.gsapi.dto.viacep;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

// Ignora propriedades desconhecidas no JSON para evitar erros de deserialização
@JsonIgnoreProperties(ignoreUnknown = true)
public class ViaCepResponseDTO {

    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade; // Cidade
    private String uf;         // Estado
    private String ibge;
    private String gia;
    private String ddd;
    private String siafi;

    @JsonProperty("erro") // Para mapear o campo "erro" do JSON para o método isErro() / setErro()
    private boolean erro; // ViaCEP retorna erro=true se o CEP não for encontrado

    // Construtor padrão
    public ViaCepResponseDTO() {
    }

    // Getters e Setters para todos os campos
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getIbge() { return ibge; }
    public void setIbge(String ibge) { this.ibge = ibge; }
    public String getGia() { return gia; }
    public void setGia(String gia) { this.gia = gia; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getSiafi() { return siafi; }
    public void setSiafi(String siafi) { this.siafi = siafi; }
    public boolean isErro() { return erro; } // Getter para boolean
    public void setErro(boolean erro) { this.erro = erro; } // Setter para boolean
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java   |   package br.com.fiap.gs.gsapi.exception   |   class GlobalExceptionHandler
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.exception
package br.com.fiap.gs.gsapi.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        logger.warn("Recurso não encontrado: {} na requisição: {}", ex.getMessage(), request.getDescription(false));
        ApiError apiError = new ApiError(HttpStatus.NOT_FOUND.value(), ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(apiError, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Object> handleIllegalArgumentException(IllegalArgumentException ex, WebRequest request) {
        logger.warn("Argumento ilegal: {} na requisição: {}", ex.getMessage(), request.getDescription(false));
        ApiError apiError = new ApiError(HttpStatus.BAD_REQUEST.value(), ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(apiError, HttpStatus.BAD_REQUEST);
    }

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers,
            HttpStatusCode status, WebRequest request) {

        logger.warn("Erro de validação: {} na requisição: {}", ex.getMessage(), request.getDescription(false));
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", status.value());
        body.put("message", "Erro de validação nos campos da requisição.");

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.toList());

        ex.getBindingResult().getGlobalErrors().forEach(globalError -> {
            errors.add(globalError.getObjectName() + ": " + globalError.getDefaultMessage());
        });

        body.put("details", errors);

        return new ResponseEntity<>(body, headers, status);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleAllUncaughtException(Exception ex, WebRequest request) {
        logger.error("Erro inesperado no servidor na requisição: " + request.getDescription(false) , ex);
        ApiError apiError = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(), "Ocorreu um erro inesperado no servidor. Tente novamente mais tarde.", LocalDateTime.now());
        return new ResponseEntity<>(apiError, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // Classe DTO interna para representar a resposta de erro padronizada
    // Adicionado timestamp para melhor rastreabilidade
    // CORRIGIDO: Tornada pública para ser acessível por outras classes (ex: Swagger schema)
    public static class ApiError {
        private int status;
        private String message;
        private LocalDateTime timestamp;

        public ApiError(int status, String message, LocalDateTime timestamp) {
            this.status = status;
            this.message = message;
            this.timestamp = timestamp;
        }
        public int getStatus() { return status; }
        public void setStatus(int status) { this.status = status; }
        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }
        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java   |   package br.com.fiap.gs.gsapi.exception   |   class ResourceNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.exception
package br.com.fiap.gs.gsapi.exception; // Pacote corrigido

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class ClienteMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.model.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(
        componentModel = "spring",
        uses = {ContatoMapper.class, EnderecoMapper.class}, // Garante que os mappers para coleções aninhadas sejam usados
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE // Ignora campos nulos do DTO ao atualizar a entidade
)
public interface ClienteMapper {

    ClienteMapper INSTANCE = Mappers.getMapper(ClienteMapper.class);

    // Mapeia Entidade Cliente para ClienteResponseDTO
    // MapStruct usará ContatoMapper e EnderecoMapper para as coleções contatos e enderecos.
    ClienteResponseDTO toClienteResponseDTO(Cliente cliente);

    List<ClienteResponseDTO> toClienteResponseDTOList(List<Cliente> clientes);

    Set<ClienteResponseDTO> toClienteResponseDTOSet(Set<Cliente> clientes);

    // Mapeia ClienteRequestDTO para Entidade Cliente
    @Mapping(target = "idCliente", ignore = true) // ID é gerado pelo banco e não deve vir do request de criação
    @Mapping(target = "contatos", ignore = true)  // Associações de contatos são tratadas na camada de serviço
    @Mapping(target = "enderecos", ignore = true) // Associações de endereços são tratadas na camada de serviço
    Cliente toCliente(ClienteRequestDTO clienteRequestDTO);

    // Para atualizar uma entidade Cliente existente com dados de um ClienteRequestDTO
    // O ID e as associações complexas não são atualizados diretamente por este método;
    // isso é geralmente tratado pela lógica de serviço.
    @Mapping(target = "idCliente", ignore = true)
    @Mapping(target = "contatos", ignore = true)
    @Mapping(target = "enderecos", ignore = true)
    void updateClienteFromDto(ClienteRequestDTO clienteRequestDTO, @MappingTarget Cliente cliente);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class ContatoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.model.Contato;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring")
public interface ContatoMapper {

    ContatoMapper INSTANCE = Mappers.getMapper(ContatoMapper.class);

    ContatoResponseDTO toContatoResponseDTO(Contato contato);

    List<ContatoResponseDTO> toContatoResponseDTOList(List<Contato> contatos);

    Set<ContatoResponseDTO> toContatoResponseDTOSet(Set<Contato> contatos);

    @Mapping(target = "idContato", ignore = true)
    @Mapping(target = "clientes", ignore = true) // Evitar referência cíclica ou mapeamento desnecessário
    Contato toContato(ContatoRequestDTO contatoRequestDTO);

    @Mapping(target = "idContato", ignore = true)
    @Mapping(target = "clientes", ignore = true)
    void updateContatoFromDto(ContatoRequestDTO contatoRequestDTO, @MappingTarget Contato contato);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class EnderecoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.model.Endereco;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring", uses = {EonetEventoMapper.class}) // Supondo EonetEventoMapper
public interface EnderecoMapper {

    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    EnderecoResponseDTO toEnderecoResponseDTO(Endereco endereco);

    List<EnderecoResponseDTO> toEnderecoResponseDTOList(List<Endereco> enderecos);

    Set<EnderecoResponseDTO> toEnderecoResponseDTOSet(Set<Endereco> enderecos);

    @Mapping(target = "idEndereco", ignore = true)
    @Mapping(target = "clientes", ignore = true)
    @Mapping(target = "eonetEventos", ignore = true) // Será tratado no serviço
    Endereco toEndereco(EnderecoRequestDTO enderecoRequestDTO);

    @Mapping(target = "idEndereco", ignore = true)
    @Mapping(target = "clientes", ignore = true)
    @Mapping(target = "eonetEventos", ignore = true)
    void updateEnderecoFromDto(EnderecoRequestDTO enderecoRequestDTO, @MappingTarget Endereco endereco);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\EonetEventoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class EonetEventoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EonetEventosRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EonetEventoResponseDTO;
import br.com.fiap.gs.gsapi.model.EonetEventos;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring")
public abstract class EonetEventoMapper {

    private static final Logger logger = LoggerFactory.getLogger(EonetEventoMapper.class);
    private final ObjectMapper objectMapper = new ObjectMapper();

    // Mapeia EonetEventosRequestDTO (que vem da sua lógica de ingestão) para a Entidade EonetEventos
    @Mapping(target = "idEonet", ignore = true) // PK numérica interna é gerada pelo banco
    @Mapping(target = "eonetApiId", source = "eonetApiId") // ID original da API EONET
    @Mapping(target = "jsonEvento", source = "jsonEvento") // JSON completo
    @Mapping(target = "data", source = "data") // Data de ingestão/evento
    @Mapping(target = "enderecosEnvolvidos", ignore = true) // Relacionamento será gerenciado separadamente
    public abstract EonetEventos toEonetEventos(EonetEventosRequestDTO requestDTO);


    // Mapeia Entidade EonetEventos para EonetEventoResponseDTO
    // Aqui é onde você extrai os dados do CLOB JSON
    @Mapping(target = "idEonet", source = "idEonet")
    @Mapping(target = "eonetApiId", source = "eonetApiId")
    @Mapping(target = "data", source = "data") // Data de ingestão/evento da sua tabela
    @Mapping(target = "tituloEvento", source = "jsonEvento", qualifiedByName = "jsonToTitulo")
    @Mapping(target = "linkEvento", source = "jsonEvento", qualifiedByName = "jsonToLink")
    @Mapping(target = "dataOcorrenciaOriginalEonet", source = "jsonEvento", qualifiedByName = "jsonToDataOcorrencia")
    @Mapping(target = "categoriaPrincipal", source = "jsonEvento", qualifiedByName = "jsonToCategoriaPrincipal")
    public abstract EonetEventoResponseDTO toEonetEventoResponseDTO(EonetEventos eonetEventos);

    public abstract List<EonetEventoResponseDTO> toEonetEventoResponseDTOList(List<EonetEventos> eonetEventos);

    public abstract Set<EonetEventoResponseDTO> toEonetEventoResponseDTOSet(Set<EonetEventos> eonetEventos);


    // Métodos auxiliares para extrair dados do JSON
    // Estes seriam chamados pelo MapStruct devido ao 'qualifiedByName'

    @Named("jsonToTitulo")
    protected String jsonToTitulo(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode titleNode = rootNode.path("title");
            return titleNode.isMissingNode() ? null : titleNode.asText();
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair título: {}", e.getMessage());
            return null;
        }
    }

    @Named("jsonToLink")
    protected String jsonToLink(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode linkNode = rootNode.path("link");
            return linkNode.isMissingNode() ? null : linkNode.asText();
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair link: {}", e.getMessage());
            return null;
        }
    }

    @Named("jsonToDataOcorrencia")
    protected Instant jsonToDataOcorrencia(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            // A data de ocorrência geralmente está dentro do primeiro objeto 'geometries'
            // Isso pode precisar de ajuste dependendo da estrutura exata que você quer priorizar
            JsonNode geometriesNode = rootNode.path("geometries");
            if (!geometriesNode.isMissingNode() && geometriesNode.isArray() && geometriesNode.size() > 0) {
                JsonNode firstGeometry = geometriesNode.get(0);
                JsonNode dateNode = firstGeometry.path("date");
                if (!dateNode.isMissingNode()) {
                    return Instant.parse(dateNode.asText());
                }
            }
        } catch (JsonProcessingException | DateTimeParseException e) {
            logger.error("Erro ao parsear JSON para extrair data de ocorrência: {}", e.getMessage());
        }
        return null;
    }

    @Named("jsonToCategoriaPrincipal")
    protected String jsonToCategoriaPrincipal(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode categoriesNode = rootNode.path("categories");
            if (!categoriesNode.isMissingNode() && categoriesNode.isArray() && categoriesNode.size() > 0) {
                JsonNode firstCategory = categoriesNode.get(0);
                JsonNode titleNode = firstCategory.path("title");
                return titleNode.isMissingNode() ? null : titleNode.asText();
            }
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair categoria principal: {}", e.getMessage());
        }
        return null;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Cliente.java   |   package br.com.fiap.gs.gsapi.model   |   class Cliente
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_cliente")
public class Cliente {

    @Id
    // Usando Coluna de Identidade (Oracle 12c+) em vez de Sequence + Trigger explícitos
    // Se o DDL gerado pelo Data Modeler usa Sequence+Trigger, mantenha as anotações @SequenceGenerator e @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Ou GenerationType.SEQUENCE se usar o DDL com sequence/trigger
    @Column(name = "id_cliente")
    private Long idCliente; // Usar Long (wrapper) para IDs é uma boa prática, permite nulo antes da persistência

    @Column(name = "nome", length = 100, nullable = false)
    private String nome;

    @Column(name = "sobrenome", length = 100, nullable = false)
    private String sobrenome;

    @Column(name = "data_nascimento", length = 10, nullable = false)
    private String dataNascimento; // Para MVP. Ideal: java.time.LocalDate

    @Column(name = "documento", length = 18, nullable = false, unique = true)
    private String documento;

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(name = "gs_clientecontato",
            joinColumns = @JoinColumn(name = "gs_cliente_id_cliente", referencedColumnName = "id_cliente"),
            inverseJoinColumns = @JoinColumn(name = "gs_contato_id_contato", referencedColumnName = "id_contato"))
    private Set<Contato> contatos = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(name = "gs_clienteendereco",
            joinColumns = @JoinColumn(name = "gs_cliente_id_cliente", referencedColumnName = "id_cliente"),
            inverseJoinColumns = @JoinColumn(name = "gs_endereco_id_endereco", referencedColumnName = "id_endereco"))
    private Set<Endereco> enderecos = new HashSet<>();

    public Cliente() {
    }

    public Cliente(String nome, String sobrenome, String dataNascimento, String documento) {
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
        this.documento = documento;
    }

    // Getters e Setters
    public Long getIdCliente() { return idCliente; }
    public void setIdCliente(Long idCliente) { this.idCliente = idCliente; }
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }
    public Set<Contato> getContatos() { return contatos; }
    public void setContatos(Set<Contato> contatos) { this.contatos = contatos; }
    public Set<Endereco> getEnderecos() { return enderecos; }
    public void setEnderecos(Set<Endereco> enderecos) { this.enderecos = enderecos; }

    // Métodos utilitários para gerenciar coleções bidirecionais
    public void addContato(Contato contato) {
        this.contatos.add(contato);
        contato.getClientesInternal().add(this); // Use um método package-private ou protected em Contato
    }
    public void removeContato(Contato contato) {
        this.contatos.remove(contato);
        contato.getClientesInternal().remove(this);
    }
    public void addEndereco(Endereco endereco) {
        this.enderecos.add(endereco);
        endereco.getClientesInternal().add(this);
    }
    public void removeEndereco(Endereco endereco) {
        this.enderecos.remove(endereco);
        endereco.getClientesInternal().remove(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cliente cliente = (Cliente) o;
        // Se o ID é nulo, a igualdade só pode ser por referência de objeto.
        // Após a persistência, o ID é a melhor forma de verificar igualdade.
        return idCliente != null && idCliente.equals(cliente.idCliente);
    }

    @Override
    public int hashCode() {
        // Se o ID é nulo, use o hashCode do objeto.
        // Após a persistência, o ID é a melhor forma.
        return idCliente != null ? Objects.hash(idCliente) : super.hashCode();
    }

    @Override
    public String toString() {
        return "Cliente{" +
                "idCliente=" + idCliente +
                ", nome='" + nome + '\'' +
                ", sobrenome='" + sobrenome + '\'' +
                ", documento='" + documento + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Contato.java   |   package br.com.fiap.gs.gsapi.model   |   class Contato
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_contato", uniqueConstraints = {
        @UniqueConstraint(name = "unq_gs_contato_email", columnNames = {"email"}) // Adicionando unique constraint para email
})
public class Contato {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_contato")
    private Long idContato;

    @Column(name = "ddd", length = 3, nullable = false)
    private String ddd;

    @Column(name = "telefone", length = 15, nullable = false)
    private String telefone;

    @Column(name = "celular", length = 15, nullable = false)
    private String celular;

    @Column(name = "whatsapp", length = 15, nullable = false)
    private String whatsapp;

    @Column(name = "email", length = 255, nullable = false)
    private String email;

    @Column(name = "tipo_contato", length = 50, nullable = false)
    private String tipoContato;

    @ManyToMany(mappedBy = "contatos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    public Contato() {
    }

    public Contato(String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    // Getters e Setters
    public Long getIdContato() { return idContato; }
    public void setIdContato(Long idContato) { this.idContato = idContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }

    // Método package-private ou protected para ser usado por Cliente
    Set<Cliente> getClientesInternal() {
        return clientes;
    }
    protected void setClientes(Set<Cliente> clientes) { // Protected para JPA e testes, não para uso público geral
        this.clientes = clientes;
    }


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Contato contato = (Contato) o;
        return idContato != null && idContato.equals(contato.idContato);
    }

    @Override
    public int hashCode() {
        return idContato != null ? Objects.hash(idContato) : super.hashCode();
    }

    @Override
    public String toString() {
        return "Contato{" +
                "idContato=" + idContato +
                ", email='" + email + '\'' +
                ", tipoContato='" + tipoContato + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Endereco.java   |   package br.com.fiap.gs.gsapi.model   |   class Endereco
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_endereco")
public class Endereco {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_endereco")
    private Long idEndereco;

    @Column(name = "cep", length = 9, nullable = false)
    private String cep;

    @Column(name = "numero", nullable = false)
    private int numero;

    @Column(name = "logradouro", length = 255, nullable = false)
    private String logradouro;

    @Column(name = "bairro", length = 255, nullable = false)
    private String bairro;

    @Column(name = "localidade", length = 100, nullable = false)
    private String localidade;

    @Column(name = "uf", length = 2, nullable = false)
    private String uf;

    @Column(name = "complemento", length = 255, nullable = false) // Seu DDL tem NOT NULL
    private String complemento;

    @Column(name = "latitude", nullable = false, precision = 10, scale = 7)
    private Double latitude; // Usar Double (wrapper)

    @Column(name = "longitude", nullable = false, precision = 10, scale = 7)
    private Double longitude; // Usar Double (wrapper)

    @ManyToMany(mappedBy = "enderecos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(name = "gs_enderecoeventos",
            joinColumns = @JoinColumn(name = "gs_endereco_id_endereco", referencedColumnName = "id_endereco"),
            inverseJoinColumns = @JoinColumn(name = "gs_eonet_id_eonet", referencedColumnName = "id_eonet")) // Refere-se à PK numérica de gs_eonet
    private Set<EonetEventos> eonetEventos = new HashSet<>();

    public Endereco() {
    }

    public Endereco(String cep, int numero, String logradouro, String bairro, String localidade, String uf, String complemento, Double latitude, Double longitude) {
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    // Getters e Setters
    public Long getIdEndereco() { return idEndereco; }
    public void setIdEndereco(Long idEndereco) { this.idEndereco = idEndereco; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public int getNumero() { return numero; }
    public void setNumero(int numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public Double getLatitude() { return latitude; }
    public void setLatitude(Double latitude) { this.latitude = latitude; }
    public Double getLongitude() { return longitude; }
    public void setLongitude(Double longitude) { this.longitude = longitude; }

    Set<Cliente> getClientesInternal() { return clientes; }
    protected void setClientes(Set<Cliente> clientes) { this.clientes = clientes; }

    public Set<EonetEventos> getEonetEventos() { return eonetEventos; }
    public void setEonetEventos(Set<EonetEventos> eonetEventos) { this.eonetEventos = eonetEventos; }

    public void addEonetEvento(EonetEventos evento) {
        this.eonetEventos.add(evento);
        evento.getEnderecosEnvolvidosInternal().add(this);
    }
    public void removeEonetEvento(EonetEventos evento) {
        this.eonetEventos.remove(evento);
        evento.getEnderecosEnvolvidosInternal().remove(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Endereco endereco = (Endereco) o;
        return idEndereco != null && idEndereco.equals(endereco.idEndereco);
    }

    @Override
    public int hashCode() {
        return idEndereco != null ? Objects.hash(idEndereco) : super.hashCode();
    }

    @Override
    public String toString() {
        return "Endereco{" +
                "idEndereco=" + idEndereco +
                ", cep='" + cep + '\'' +
                ", logradouro='" + logradouro + '\'' +
                ", numero=" + numero +
                ", localidade='" + localidade + '\'' +
                ", uf='" + uf + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\EonetEventos.java   |   package br.com.fiap.gs.gsapi.model   |   class EonetEventos
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.time.Instant;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_eonet", uniqueConstraints = {
        @UniqueConstraint(name = "unq_gs_eonet_eonet_api_id", columnNames = {"eonet_id"}) // Nome da coluna no DDL é eonet_id
})
public class EonetEventos {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_eonet")
    private Long idEonet; // PK numérica interna

    @Column(name = "eonet_id", length = 50, nullable = false) // ID original da API EONET
    private String eonetApiId;

    @Lob
    @Column(name = "json", columnDefinition = "CLOB") // DDL tem CLOB NULL
    private String jsonEvento;

    @Column(name = "data") // DDL tem TIMESTAMP WITH LOCAL TIME ZONE NULL
    private Instant data;

    @ManyToMany(mappedBy = "eonetEventos", fetch = FetchType.LAZY)
    private Set<Endereco> enderecosEnvolvidos = new HashSet<>();

    public EonetEventos() {
    }

    public EonetEventos(String eonetApiId, String jsonEvento, Instant data) {
        this.eonetApiId = eonetApiId;
        this.jsonEvento = jsonEvento;
        this.data = data;
    }

    // Getters e Setters
    public Long getIdEonet() { return idEonet; }
    public void setIdEonet(Long idEonet) { this.idEonet = idEonet; }
    public String getEonetApiId() { return eonetApiId; }
    public void setEonetApiId(String eonetApiId) { this.eonetApiId = eonetApiId; }
    public String getJsonEvento() { return jsonEvento; }
    public void setJsonEvento(String jsonEvento) { this.jsonEvento = jsonEvento; }
    public Instant getData() { return data; }
    public void setData(Instant data) { this.data = data; }

    Set<Endereco> getEnderecosEnvolvidosInternal() { return enderecosEnvolvidos; }
    protected void setEnderecosEnvolvidos(Set<Endereco> enderecosEnvolvidos) { this.enderecosEnvolvidos = enderecosEnvolvidos; }


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EonetEventos that = (EonetEventos) o;
        // Chave de negócio primária é o eonetApiId
        if (eonetApiId != null) {
            return eonetApiId.equals(that.eonetApiId);
        }
        // Se ambos eonetApiId são nulos, e os IDs gerados são nulos, são "iguais" apenas se forem a mesma instância.
        // Se os IDs gerados existem, eles devem ser usados para comparação.
        return idEonet != null && idEonet.equals(that.idEonet);
    }

    @Override
    public int hashCode() {
        // Chave de negócio primária é o eonetApiId
        return Objects.hash(eonetApiId);
    }

    @Override
    public String toString() {
        return "EonetEventos{" +
                "idEonet=" + idEonet +
                ", eonetApiId='" + eonetApiId + '\'' +
                ", data=" + data +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class ClienteRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Cliente;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long>, JpaSpecificationExecutor<Cliente> {

    // Exemplo de busca customizada (se necessário)
    Optional<Cliente> findByDocumento(String documento);

    // JpaSpecificationExecutor já permite buscas dinâmicas com Specifications
    // JpaRepository já oferece:
    // - save, saveAll
    // - findById, findAll, findAllById
    // - delete, deleteAll, deleteById
    // - count
    // - existsById
    // - findAll(Sort sort)
    // - findAll(Pageable pageable) -> para paginação
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class ContatoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Contato;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ContatoRepository extends JpaRepository<Contato, Long> {

    Optional<Contato> findByEmail(String email);
    // Adicione outros métodos de busca customizados se necessário
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class EnderecoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Endereco;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // Adicionar se precisar de buscas dinâmicas para Endereco
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface EnderecoRepository extends JpaRepository<Endereco, Long>, JpaSpecificationExecutor<Endereco> { // Adicionado JpaSpecificationExecutor

    // Método para buscar um endereço pelo CEP
    List<Endereco> findByCep(String cep);

    // Método para buscar um endereço pelo CEP e número (NECESSÁRIO PARA EnderecoGeocodingService)
    Optional<Endereco> findByCepAndNumero(String cep, int numero);

    // Adicione outros métodos de busca customizados se necessário
    // Exemplo: buscar endereços por UF
    // List<Endereco> findByUf(String uf);

    // Exemplo: buscar endereços por localidade (cidade)
    // List<Endereco> findByLocalidadeIgnoreCase(String localidade);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\EonetEventoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class EonetEventoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.EonetEventos;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.Optional;

@Repository
public interface EonetEventoRepository extends JpaRepository<EonetEventos, Long> {

    // Busca pelo ID original da API EONET (que é único)
    Optional<EonetEventos> findByEonetApiId(String eonetApiId);

    // Exemplo de busca por eventos dentro de um período de data (usando a coluna 'data' da sua tabela)
    Page<EonetEventos> findByDataBetween(Instant dataInicio, Instant dataFim, Pageable pageable);

    // Exemplo de como você poderia buscar eventos cujo JSON contenha um certo título
    // ATENÇÃO: Buscas diretas em CLOB JSON podem ser menos performáticas.
    // O ideal é ter campos extraídos e indexados para filtros comuns.
    // Esta é uma query nativa para Oracle como exemplo, pode precisar de ajustes.
    @Query(value = "SELECT * FROM gs_eonet e WHERE JSON_VALUE(e.json, '$.title') LIKE %:titulo%", nativeQuery = true)
    Page<EonetEventos> findByJsonTitleContaining(@Param("titulo") String titulo, Pageable pageable);

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\ClienteService.java   |   package br.com.fiap.gs.gsapi.service   |   class ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.ClienteMapper;
import br.com.fiap.gs.gsapi.model.Cliente;
import br.com.fiap.gs.gsapi.model.Contato; // Assumindo que você pode querer associar/criar contatos
import br.com.fiap.gs.gsapi.model.Endereco; // Assumindo que você pode querer associar/criar endereços
import br.com.fiap.gs.gsapi.repository.ClienteRepository;
import br.com.fiap.gs.gsapi.repository.ContatoRepository;
import br.com.fiap.gs.gsapi.repository.EnderecoRepository;
import br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria;
import br.com.fiap.gs.gsapi.service.search.ClienteSpecification;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@CacheConfig(cacheNames = "clientes") // Define um nome de cache padrão para os métodos desta classe
public class ClienteService {

    private final ClienteRepository clienteRepository;
    private final ContatoRepository contatoRepository; // Para buscar contatos existentes
    private final EnderecoRepository enderecoRepository; // Para buscar endereços existentes
    private final ClienteMapper clienteMapper;

    @Autowired
    public ClienteService(ClienteRepository clienteRepository,
                          ContatoRepository contatoRepository,
                          EnderecoRepository enderecoRepository,
                          ClienteMapper clienteMapper) {
        this.clienteRepository = clienteRepository;
        this.contatoRepository = contatoRepository;
        this.enderecoRepository = enderecoRepository;
        this.clienteMapper = clienteMapper;
    }

    @Transactional(readOnly = true)
    // Chave de cache mais robusta, incluindo hashCode dos critérios se não nulos
    @Cacheable(key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString() + '-' + T(java.util.Objects).hashCode(#criteria)")
    public Page<ClienteResponseDTO> listarTodos(ClienteSearchCriteria criteria, Pageable pageable) {
        Specification<Cliente> spec = ClienteSpecification.fromCriteria(criteria);
        Page<Cliente> clientesPage = clienteRepository.findAll(spec, pageable);
        return clientesPage.map(clienteMapper::toClienteResponseDTO);
    }

    @Transactional(readOnly = true)
    @Cacheable(key = "#id")
    public ClienteResponseDTO buscarPorId(Long id) {
        Cliente cliente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com ID: " + id));
        return clienteMapper.toClienteResponseDTO(cliente);
    }

    @Transactional
    @CacheEvict(allEntries = true)
    public ClienteResponseDTO criar(ClienteRequestDTO clienteRequestDTO) {
        // Validação de documento único
        clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).ifPresent(c -> {
            throw new IllegalArgumentException("Cliente com o documento '" + clienteRequestDTO.getDocumento() + "' já existe.");
        });

        Cliente cliente = clienteMapper.toCliente(clienteRequestDTO);

        // Lógica para associar contatos e endereços (exemplo)
        // Se o ClienteRequestDTO contiver IDs de contatos/endereços existentes para associar:
        // Set<Long> idsContatos = clienteRequestDTO.getIdsContatos(); // Supondo que o DTO tenha isso
        // if (idsContatos != null && !idsContatos.isEmpty()) {
        //     Set<Contato> contatosParaAssociar = new HashSet<>(contatoRepository.findAllById(idsContatos));
        //     if(contatosParaAssociar.size() != idsContatos.size()){
        //          throw new ResourceNotFoundException("Um ou mais contatos não encontrados para associação.");
        //     }
        //     cliente.setContatos(contatosParaAssociar);
        //     // Para relacionamento bidirecional, você também pode precisar adicionar o cliente ao contato
        //     // contatosParaAssociar.forEach(contato -> contato.getClientes().add(cliente));
        // }
        // Lógica similar para endereços

        Cliente clienteSalvo = clienteRepository.save(cliente);
        return clienteMapper.toClienteResponseDTO(clienteSalvo);
    }

    @Transactional
    @CachePut(key = "#id")
    @CacheEvict(allEntries = true, condition = "#result != null")
    public ClienteResponseDTO atualizar(Long id, ClienteRequestDTO clienteRequestDTO) {
        Cliente clienteExistente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com ID: " + id));

        if (clienteRequestDTO.getDocumento() != null && !clienteExistente.getDocumento().equals(clienteRequestDTO.getDocumento())) {
            clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).ifPresent(c -> {
                if (c.getIdCliente() != id) {
                    throw new IllegalArgumentException("Outro cliente com o documento '" + clienteRequestDTO.getDocumento() + "' já existe.");
                }
            });
        }

        clienteMapper.updateClienteFromDto(clienteRequestDTO, clienteExistente);

        // Lógica mais complexa para atualizar coleções (contatos, endereços)
        // Ex: remover os que não estão mais no DTO, adicionar os novos.
        // Isso geralmente requer uma lógica mais detalhada do que um simples mapeamento.

        Cliente clienteAtualizado = clienteRepository.save(clienteExistente);
        return clienteMapper.toClienteResponseDTO(clienteAtualizado);
    }

    @Transactional
    @CacheEvict(allEntries = true) // Invalida todos os caches de "clientes"
    public void deletar(Long id) {
        if (!clienteRepository.existsById(id)) {
            throw new ResourceNotFoundException("Cliente não encontrado com ID: " + id + " para exclusão.");
        }
        // Considerar a lógica de desassociação ou remoção em cascata configurada nas entidades
        clienteRepository.deleteById(id);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\EnderecoGeocodingService.java   |   package br.com.fiap.gs.gsapi.service   |   class EnderecoGeocodingService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service
package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.client.NominatimClient;
import br.com.fiap.gs.gsapi.client.ViaCepClient;
import br.com.fiap.gs.gsapi.dto.geocoding.NominatimResponseDTO;
import br.com.fiap.gs.gsapi.dto.viacep.ViaCepResponseDTO;
import br.com.fiap.gs.gsapi.model.Endereco; // Sua entidade Endereco
import br.com.fiap.gs.gsapi.repository.EnderecoRepository; // Seu repositório
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service
public class EnderecoGeocodingService {

    private static final Logger logger = LoggerFactory.getLogger(EnderecoGeocodingService.class);

    private final ViaCepClient viaCepClient;
    private final NominatimClient nominatimClient;
    private final EnderecoRepository enderecoRepository;

    @Autowired
    public EnderecoGeocodingService(ViaCepClient viaCepClient,
                                    NominatimClient nominatimClient,
                                    EnderecoRepository enderecoRepository) {
        this.viaCepClient = viaCepClient;
        this.nominatimClient = nominatimClient;
        this.enderecoRepository = enderecoRepository;
    }

    /**
     * Busca o endereço completo (com lat/lon) a partir de um CEP e número.
     * Se o endereço já existir no banco com coordenadas, retorna o existente.
     * Caso contrário, busca no ViaCEP, depois no Nominatim, e salva/atualiza no banco.
     *
     * @param cep O CEP a ser consultado.
     * @param numero O número do endereço (para geocodificação mais precisa).
     * @param complemento O complemento do endereço (opcional).
     * @return Um Optional contendo a entidade Endereco com os dados e coordenadas, ou Optional.empty() se não encontrado/falha.
     */
    @Transactional
    public Optional<Endereco> obterOuCriarEnderecoCompleto(String cep, String numeroStr, String complemento) {
        String cepNumerico = cep.replaceAll("[^0-9]", "");

        // Tenta buscar no banco um endereço que já possa ter sido geocodificado
        // Esta lógica de busca pode precisar ser mais sofisticada (ex: por um ID de cliente se for um update)
        // Por enquanto, vamos assumir que se o CEP e número batem, é o mesmo endereço.
        // Em um cenário real, você pode ter um ID de endereço se ele já existir.
        Optional<Endereco> enderecoExistente = enderecoRepository.findByCepAndNumero(cepNumerico, parseNumero(numeroStr));

        if (enderecoExistente.isPresent() && enderecoExistente.get().getLatitude() != 0 && enderecoExistente.get().getLongitude() != 0) {
            logger.info("Endereço encontrado no banco com coordenadas para CEP {} e Número {}. ID: {}", cepNumerico, numeroStr, enderecoExistente.get().getIdEndereco());
            // Se o complemento mudou, atualize
            if (complemento != null && !complemento.equals(enderecoExistente.get().getComplemento())) {
                enderecoExistente.get().setComplemento(complemento);
                return Optional.of(enderecoRepository.save(enderecoExistente.get()));
            }
            return enderecoExistente;
        }

        logger.info("Buscando dados no ViaCEP para CEP: {}", cepNumerico);
        ViaCepResponseDTO viaCepData = viaCepClient.buscarEnderecoPorCep(cepNumerico);

        if (viaCepData == null || viaCepData.isErro()) {
            logger.warn("Não foi possível obter dados do ViaCEP para o CEP: {}", cepNumerico);
            return Optional.empty();
        }

        // Prepara a entidade Endereco (nova ou a existente sem coordenadas)
        Endereco enderecoParaSalvar = enderecoExistente.orElseGet(Endereco::new);
        mapearViaCepParaEndereco(viaCepData, numeroStr, complemento, enderecoParaSalvar);

        // Tenta obter coordenadas do Nominatim
        // Lembre-se da política de uso do Nominatim (1 req/seg)
        // Em uma aplicação real, adicione um delay aqui se for chamar em loop.
        try {
            Thread.sleep(1000); // Delay de 1 segundo para respeitar o limite do Nominatim
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("Thread interrompida enquanto esperava para chamar Nominatim.", e);
        }

        NominatimResponseDTO nominatimResponse = nominatimClient.buscarCoordenadasPorEndereco(
                enderecoParaSalvar.getLogradouro(),
                String.valueOf(enderecoParaSalvar.getNumero()), // Passa o número já parseado
                enderecoParaSalvar.getBairro(),
                enderecoParaSalvar.getLocalidade(),
                enderecoParaSalvar.getUf(),
                enderecoParaSalvar.getCep()
        ).blockFirst(); // Cuidado com blockFirst() em ambientes totalmente reativos. Considere alternativas.

        if (nominatimResponse != null && nominatimResponse.getLatitude() != null && nominatimResponse.getLongitude() != null) {
            try {
                enderecoParaSalvar.setLatitude(Double.parseDouble(nominatimResponse.getLatitude()));
                enderecoParaSalvar.setLongitude(Double.parseDouble(nominatimResponse.getLongitude()));
                logger.info("Coordenadas obtidas do Nominatim para CEP {}: Lat={}, Lon={}", cepNumerico, enderecoParaSalvar.getLatitude(), enderecoParaSalvar.getLongitude());
            } catch (NumberFormatException e) {
                logger.error("Erro ao converter coordenadas do Nominatim de String para Double: Lat={}, Lon={}",
                        nominatimResponse.getLatitude(), nominatimResponse.getLongitude(), e);
                // Decide se quer salvar sem coordenadas ou retornar erro
            }
        } else {
            logger.warn("Não foi possível obter coordenadas do Nominatim para o endereço do CEP: {}", cepNumerico);
        }

        try {
            Endereco enderecoSalvo = enderecoRepository.save(enderecoParaSalvar);
            return Optional.of(enderecoSalvo);
        } catch (Exception e) {
            logger.error("Erro ao salvar endereço para CEP {}: {}", cepNumerico, e.getMessage(), e);
            return Optional.empty();
        }
    }

    private void mapearViaCepParaEndereco(ViaCepResponseDTO viaCepData, String numeroStr, String complemento, Endereco endereco) {
        endereco.setCep(viaCepData.getCep().replaceAll("[^0-9]", ""));
        endereco.setLogradouro(viaCepData.getLogradouro());
        endereco.setBairro(viaCepData.getBairro());
        endereco.setLocalidade(viaCepData.getLocalidade());
        endereco.setUf(viaCepData.getUf());
        if (numeroStr != null && !numeroStr.trim().isEmpty()) {
            endereco.setNumero(parseNumero(numeroStr));
        }
        endereco.setComplemento(complemento != null ? complemento : (viaCepData.getComplemento() != null ? viaCepData.getComplemento() : ""));
    }

    private int parseNumero(String numeroStr) {
        if (numeroStr == null || numeroStr.trim().isEmpty()) return 0; // Ou lance exceção, ou defina um padrão
        try {
            return Integer.parseInt(numeroStr.replaceAll("[^0-9]", ""));
        } catch (NumberFormatException e) {
            logger.warn("Número de endereço inválido fornecido: '{}'. Usando 0.", numeroStr);
            return 0; // Ou lance exceção
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\search\ClienteSearchCriteria.java   |   package br.com.fiap.gs.gsapi.service.search   |   class ClienteSearchCriteria
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.service.search;

import java.util.Objects;

// Classe simples para encapsular critérios de busca para Cliente
public class ClienteSearchCriteria {
    private String nome;
    private String documento;
    private String dataNascimento; // Poderia ser LocalDate se o DTO e a entidade usassem

    public ClienteSearchCriteria() {
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public String getDataNascimento() {
        return dataNascimento;
    }

    public void setDataNascimento(String dataNascimento) {
        this.dataNascimento = dataNascimento;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ClienteSearchCriteria that = (ClienteSearchCriteria) o;
        return Objects.equals(nome, that.nome) &&
                Objects.equals(documento, that.documento) &&
                Objects.equals(dataNascimento, that.dataNascimento);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nome, documento, dataNascimento);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\search\ClienteSpecification.java   |   package br.com.fiap.gs.gsapi.service.search   |   class ClienteSpecification
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.service.search;

import br.com.fiap.gs.gsapi.model.Cliente;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils; // Para StringUtils.hasText

import java.util.ArrayList;
import java.util.List;

public class ClienteSpecification {

    public static Specification<Cliente> fromCriteria(ClienteSearchCriteria criteria) {
        return (root, query, criteriaBuilder) -> {
            if (criteria == null) {
                return criteriaBuilder.conjunction(); // Retorna uma condição sempre verdadeira se não houver critérios
            }

            List<Predicate> predicates = new ArrayList<>();

            if (StringUtils.hasText(criteria.getNome())) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("nome")), "%" + criteria.getNome().toLowerCase() + "%"));
            }
            if (StringUtils.hasText(criteria.getDocumento())) {
                predicates.add(criteriaBuilder.equal(root.get("documento"), criteria.getDocumento()));
            }
            if (StringUtils.hasText(criteria.getDataNascimento())) {
                // Se dataNascimento fosse LocalDate, a comparação seria diferente
                // Ex: criteriaBuilder.equal(root.get("dataNascimento"), criteria.getDataNascimentoAsLocalDate());
                predicates.add(criteriaBuilder.equal(root.get("dataNascimento"), criteria.getDataNascimento()));
            }
            // Adicione outros predicados para outros campos de busca

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\search\ContatoSearchCriteria.java   |   package br.com.fiap.gs.gsapi.service.search   |   class ContatoSearchCriteria
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.service.search;

import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.Objects;

public class ContatoSearchCriteria {
    private String email;
    private String tipoContato;
    private String ddd;

    // Construtor padrão, Getters e Setters
    public ContatoSearchCriteria() {}

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ContatoSearchCriteria that = (ContatoSearchCriteria) o;
        return Objects.equals(email, that.email) &&
                Objects.equals(tipoContato, that.tipoContato) &&
                Objects.equals(ddd, that.ddd);
    }

    @Override
    public int hashCode() {
        return Objects.hash(email, tipoContato, ddd);
    }
}
```java
// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.service.search;

import br.com.fiap.gs.gsapi.model.Contato;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;

public class ContatoSpecification {

    public static Specification<Contato> fromCriteria(ContatoSearchCriteria criteria) {
        return (root, query, criteriaBuilder) -> {
            if (criteria == null) {
                return criteriaBuilder.conjunction();
            }
            List<Predicate> predicates = new ArrayList<>();

            if (StringUtils.hasText(criteria.getEmail())) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("email")), "%" + criteria.getEmail().toLowerCase() + "%"));
            }
            if (StringUtils.hasText(criteria.getTipoContato())) {
                predicates.add(criteriaBuilder.equal(criteriaBuilder.lower(root.get("tipoContato")), criteria.getTipoContato().toLowerCase()));
            }
            if (StringUtils.hasText(criteria.getDdd())) {
                predicates.add(criteriaBuilder.equal(root.get("ddd"), criteria.getDdd()));
            }
            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }
}

