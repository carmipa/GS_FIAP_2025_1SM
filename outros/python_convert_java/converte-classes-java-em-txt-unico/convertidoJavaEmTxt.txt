// Script: converte-classes-java-em-txt-unico (v3)
// Data de criação do arquivo de saída: 2025-05-30 10:24:49

// Estrutura de diretórios do projeto:
main/
    java/
        br/
            com/
                fiap/
                    gs/
                        gsapi/
                            client/
                            config/
                            controller/
                                alert/
                            dto/
                                alert/
                                external/
                                geo/
                                request/
                                response/
                                stats/
                            exception/
                            mapper/
                            model/
                            repository/
                            service/
                                alert/
                                notification/
                            specification/
                            utils/
    resources/
        static/
        templates/

// Arquivos encontrados (FQN => caminho relativo):
// br.com.fiap.gs.gsapi.GsapiApplication => java\br\com\fiap\gs\gsapi\GsapiApplication.java
// br.com.fiap.gs.gsapi.client.GeoCodingClient => java\br\com\fiap\gs\gsapi\client\GeoCodingClient.java
// br.com.fiap.gs.gsapi.client.NasaEonetClient => java\br\com\fiap\gs\gsapi\client\NasaEonetClient.java
// br.com.fiap.gs.gsapi.client.ViaCepClient => java\br\com\fiap\gs\gsapi\client\ViaCepClient.java
// br.com.fiap.gs.gsapi.config.AppConfig => java\br\com\fiap\gs\gsapi\config\AppConfig.java
// br.com.fiap.gs.gsapi.config.CorsConfig => java\br\com\fiap\gs\gsapi\config\CorsConfig.java
// br.com.fiap.gs.gsapi.config.OpenApiConfig => java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java
// br.com.fiap.gs.gsapi.config.SwaggerBrowserLauncher => java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java
// br.com.fiap.gs.gsapi.controller.ClienteController => java\br\com\fiap\gs\gsapi\controller\ClienteController.java
// br.com.fiap.gs.gsapi.controller.ContatoController => java\br\com\fiap\gs\gsapi\controller\ContatoController.java
// br.com.fiap.gs.gsapi.controller.EnderecoController => java\br\com\fiap\gs\gsapi\controller\EnderecoController.java
// br.com.fiap.gs.gsapi.controller.EonetController => java\br\com\fiap\gs\gsapi\controller\EonetController.java
// br.com.fiap.gs.gsapi.controller.StatsController => java\br\com\fiap\gs\gsapi\controller\StatsController.java
// br.com.fiap.gs.gsapi.controller.alert.AlertTriggerController => java\br\com\fiap\gs\gsapi\controller\alert\AlertTriggerController.java
// br.com.fiap.gs.gsapi.dto.alert.AlertableEventDTO => java\br\com\fiap\gs\gsapi\dto\alert\AlertableEventDTO.java
// br.com.fiap.gs.gsapi.dto.alert.UserAlertRequestDTO => java\br\com\fiap\gs\gsapi\dto\alert\UserAlertRequestDTO.java
// br.com.fiap.gs.gsapi.dto.external.GoogleGeocodingApiResponseDTO => java\br\com\fiap\gs\gsapi\dto\external\GoogleGeocodingApiResponseDTO.java
// br.com.fiap.gs.gsapi.dto.external.GoogleGeocodingGeometryDTO => java\br\com\fiap\gs\gsapi\dto\external\GoogleGeocodingGeometryDTO.java
// br.com.fiap.gs.gsapi.dto.external.GoogleGeocodingLocationDTO => java\br\com\fiap\gs\gsapi\dto\external\GoogleGeocodingLocationDTO.java
// br.com.fiap.gs.gsapi.dto.external.GoogleGeocodingResultDTO => java\br\com\fiap\gs\gsapi\dto\external\GoogleGeocodingResultDTO.java
// br.com.fiap.gs.gsapi.dto.external.NasaEonetApiResponseDTO => java\br\com\fiap\gs\gsapi\dto\external\NasaEonetApiResponseDTO.java
// br.com.fiap.gs.gsapi.dto.external.NasaEonetCategoryDTO => java\br\com\fiap\gs\gsapi\dto\external\NasaEonetCategoryDTO.java
// br.com.fiap.gs.gsapi.dto.external.NasaEonetEventDTO => java\br\com\fiap\gs\gsapi\dto\external\NasaEonetEventDTO.java
// br.com.fiap.gs.gsapi.dto.external.NasaEonetGeometryDTO => java\br\com\fiap\gs\gsapi\dto\external\NasaEonetGeometryDTO.java
// br.com.fiap.gs.gsapi.dto.external.NasaEonetSourceDTO => java\br\com\fiap\gs\gsapi\dto\external\NasaEonetSourceDTO.java
// br.com.fiap.gs.gsapi.dto.response.GeoCoordinatesDTO => java\br\com\fiap\gs\gsapi\dto\geo\GeoCoordinatesDTO.java
// br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO => java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO => java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.EnderecoGeoRequestDTO => java\br\com\fiap\gs\gsapi\dto\request\EnderecoGeoRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO => java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.EonetRequestDTO => java\br\com\fiap\gs\gsapi\dto\request\EonetRequestDTO.java
// br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO => java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO => java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO => java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.EonetResponseDTO => java\br\com\fiap\gs\gsapi\dto\response\EonetResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.NominatimResponseDTO => java\br\com\fiap\gs\gsapi\dto\response\NominatimResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.ViaCepResponseDTO => java\br\com\fiap\gs\gsapi\dto\response\ViaCepResponseDTO.java
// br.com.fiap.gs.gsapi.dto.stats.CategoryCountDTO => java\br\com\fiap\gs\gsapi\dto\stats\CategoryCountDTO.java
// br.com.fiap.gs.gsapi.dto.stats.TimeCountDTO => java\br\com\fiap\gs\gsapi\dto\stats\TimeCountDTO.java
// br.com.fiap.gs.gsapi.exception.GlobalExceptionHandler => java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java
// br.com.fiap.gs.gsapi.exception.ResourceNotFoundException => java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java
// br.com.fiap.gs.gsapi.exception.ServiceUnavailableException => java\br\com\fiap\gs\gsapi\exception\ServiceUnavailableException.java
// br.com.fiap.gs.gsapi.mapper.ClienteMapper => java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java
// br.com.fiap.gs.gsapi.mapper.ContatoMapper => java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java
// br.com.fiap.gs.gsapi.mapper.EnderecoMapper => java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java
// br.com.fiap.gs.gsapi.mapper.EonetMapper => java\br\com\fiap\gs\gsapi\mapper\EonetMapper.java
// br.com.fiap.gs.gsapi.model.Cliente => java\br\com\fiap\gs\gsapi\model\Cliente.java
// br.com.fiap.gs.gsapi.model.Contato => java\br\com\fiap\gs\gsapi\model\Contato.java
// br.com.fiap.gs.gsapi.model.Endereco => java\br\com\fiap\gs\gsapi\model\Endereco.java
// br.com.fiap.gs.gsapi.model.Eonet => java\br\com\fiap\gs\gsapi\model\Eonet.java
// br.com.fiap.gs.gsapi.repository.ClienteRepository => java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java
// br.com.fiap.gs.gsapi.repository.ContatoRepository => java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java
// br.com.fiap.gs.gsapi.repository.EnderecoRepository => java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java
// br.com.fiap.gs.gsapi.repository.EonetRepository => java\br\com\fiap\gs\gsapi\repository\EonetRepository.java
// br.com.fiap.gs.gsapi.service.ClienteService => java\br\com\fiap\gs\gsapi\service\ClienteService.java
// br.com.fiap.gs.gsapi.service.ContatoService => java\br\com\fiap\gs\gsapi\service\ContatoService.java
// br.com.fiap.gs.gsapi.service.EnderecoService => java\br\com\fiap\gs\gsapi\service\EnderecoService.java
// br.com.fiap.gs.gsapi.service.EonetService => java\br\com\fiap\gs\gsapi\service\EonetService.java
// br.com.fiap.gs.gsapi.service.alert.UserSpecificAlertService => java\br\com\fiap\gs\gsapi\service\alert\UserSpecificAlertService.java
// br.com.fiap.gs.gsapi.service.notification.EmailNotificationService => java\br\com\fiap\gs\gsapi\service\notification\EmailNotificationService.java
// br.com.fiap.gs.gsapi.utils.GeoUtils => java\br\com\fiap\gs\gsapi\utils\GeoUtils.java

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\GsapiApplication.java   |   package br.com.fiap.gs.gsapi   |   class GsapiApplication
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
// Não precisamos mais importar RestTemplateBuilder, RestTemplate, ou @Bean aqui para o restTemplate
// import org.springframework.boot.web.client.RestTemplateBuilder;
// import org.springframework.context.annotation.Bean;
// import org.springframework.web.client.RestTemplate;

@SpringBootApplication
@EnableCaching
public class GsapiApplication {

	public static void main(String[] args) {
		SpringApplication.run(GsapiApplication.class, args);
	}

	// O BEAN RestTemplate FOI REMOVIDO DESTA CLASSE.
	// Ele já está definido em AppConfig.java com mais configurações.
    /*
    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        return builder.build();
    }
    */
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\client\GeoCodingClient.java   |   package br.com.fiap.gs.gsapi.client   |   class GeoCodingClient
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.external.GoogleGeocodingApiResponseDTO; // DTO do Google
import br.com.fiap.gs.gsapi.exception.ServiceUnavailableException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils; // Para StringUtils.hasText
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.Collections;

@Component
public class GeoCodingClient {

    private static final Logger logger = LoggerFactory.getLogger(GeoCodingClient.class);
    private final RestTemplate restTemplate;

    @Value("${google.maps.geocoding.api.url:https://maps.googleapis.com/maps/api/geocode/json}")
    private String googleApiUrl;

    @Value("${google.maps.apikey}")
    private String googleApiKey;

    // User-Agent não é estritamente necessário para Google, mas pode ser mantido para consistência
    @Value("${app.geocoding.user-agent:GSAPI_Fiap_Project/1.0 (seuemail@example.com)}")
    private String userAgent;


    @Autowired
    public GeoCodingClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    /**
     * Busca coordenadas usando a Google Geocoding API.
     * @param addressQuery A string de endereço completa para geocodificar.
     * @param components Filtros de componentes (ex: "country:BR|postal_code:00000000"). Opcional.
     * @param language Código de linguagem para os resultados (ex: "pt-BR"). Opcional.
     * @return GoogleGeocodingApiResponseDTO contendo os resultados.
     */
    public GoogleGeocodingApiResponseDTO buscarCoordenadasPorEnderecoGoogle(String addressQuery, String components, String language) {
        if (!StringUtils.hasText(addressQuery)) {
            throw new IllegalArgumentException("Query de endereço (addressQuery) não pode ser nula ou vazia.");
        }
        if (!StringUtils.hasText(googleApiKey)) {
            logger.error("Chave da API do Google Maps não configurada (google.maps.apikey).");
            throw new ServiceUnavailableException("Configuração da API de Geocodificação do Google ausente.");
        }

        UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(googleApiUrl)
                .queryParam("address", addressQuery)
                .queryParam("key", googleApiKey);

        if (StringUtils.hasText(components)) {
            uriBuilder.queryParam("components", components);
        }
        if (StringUtils.hasText(language)) {
            uriBuilder.queryParam("language", language);
        }


        HttpHeaders headers = new HttpHeaders();
        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
        if (StringUtils.hasText(userAgent)) { // Envia User-Agent se configurado
            headers.set("User-Agent", userAgent);
        }

        HttpEntity<String> entity = new HttpEntity<>(headers);
        String url = uriBuilder.toUriString();
        logger.info("Consultando Google Geocoding API: {}", url);

        try {
            ResponseEntity<GoogleGeocodingApiResponseDTO> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    entity,
                    GoogleGeocodingApiResponseDTO.class);

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                GoogleGeocodingApiResponseDTO apiResponse = response.getBody();
                logger.info("Resposta da Google Geocoding API para query '{}': Status={}, Resultados={}",
                        addressQuery, apiResponse.getStatus(),
                        (apiResponse.getResults() != null ? apiResponse.getResults().size() : 0));

                // Não lançar exceção para "ZERO_RESULTS" aqui, deixar o serviço decidir o que fazer.
                if (!"OK".equals(apiResponse.getStatus()) && !"ZERO_RESULTS".equals(apiResponse.getStatus())) {
                    logger.error("Google Geocoding API retornou status de erro: {} - {}", apiResponse.getStatus(), apiResponse.getErrorMessage());
                    throw new ServiceUnavailableException("Google Geocoding API error: " + apiResponse.getStatus() + " - " + apiResponse.getErrorMessage());
                }
                return apiResponse;
            } else {
                logger.error("Erro ao consultar Google Geocoding API para query '{}'. Status HTTP: {}", addressQuery, response.getStatusCode());
                throw new ServiceUnavailableException("Google Geocoding API retornou status HTTP: " + response.getStatusCode());
            }
        } catch (HttpClientErrorException | HttpServerErrorException e) {
            logger.error("Erro HTTP ao consultar Google Geocoding API para query '{}': {} - {}", addressQuery, e.getStatusCode(), e.getResponseBodyAsString(), e);
            throw new ServiceUnavailableException("Erro ao comunicar com o Google Geocoding API: " + e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Erro inesperado ao consultar Google Geocoding API para query '{}': {}", addressQuery, e.getMessage(), e);
            throw new ServiceUnavailableException("Erro inesperado ao processar consulta ao Google Geocoding API.", e);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\client\NasaEonetClient.java   |   package br.com.fiap.gs.gsapi.client   |   class NasaEonetClient
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Arquivo: src/main/java/br/com/fiap/gs/gsapi/client/NasaEonetClient.java
package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.external.NasaEonetApiResponseDTO;
import br.com.fiap.gs.gsapi.dto.external.NasaEonetEventDTO;
import br.com.fiap.gs.gsapi.exception.ServiceUnavailableException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils; // Para StringUtils.hasText
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.Collections;

@Component
public class NasaEonetClient {

    private static final Logger logger = LoggerFactory.getLogger(NasaEonetClient.class);
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;

    @Value("${nasa.eonet.api.url:https://eonet.gsfc.nasa.gov/api/v3/events}")
    private String eonetApiUrl;

    @Autowired
    public NasaEonetClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
        this.objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    }

    // ***** MÉTODO MODIFICADO PARA INCLUIR startDate e endDate *****
    public NasaEonetApiResponseDTO getEvents(Integer limit, Integer days, String status, String source, String bbox, String startDate, String endDate) {
        UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(eonetApiUrl);

        if (limit != null && limit > 0) {
            uriBuilder.queryParam("limit", limit);
        }

        // Se startDate e endDate forem fornecidos, 'days' geralmente não é usado pela EONET.
        // A API EONET prioriza start/end se ambos 'days' e 'start'/'end' estiverem presentes.
        if (StringUtils.hasText(startDate)) {
            uriBuilder.queryParam("start", startDate);
        }
        if (StringUtils.hasText(endDate)) {
            uriBuilder.queryParam("end", endDate);
        }
        // Se start/end não forem usados, então 'days' pode ser aplicado.
        // Se start/end forem fornecidos, o parâmetro 'days' pode ser ignorado pela EONET ou causar comportamento inesperado.
        // Para ser seguro, só adicionamos 'days' se start e end não estiverem definidos.
        else if (days != null && days > 0) {
            uriBuilder.queryParam("days", days);
        }

        if (StringUtils.hasText(status)) {
            uriBuilder.queryParam("status", status);
        }
        if (StringUtils.hasText(source)) {
            uriBuilder.queryParam("source", source);
        }
        if (StringUtils.hasText(bbox)) {
            uriBuilder.queryParam("bbox", bbox);
        }

        HttpHeaders headers = new HttpHeaders();
        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
        headers.set("User-Agent", "GSAPI_Fiap_Project/1.0");

        HttpEntity<String> entity = new HttpEntity<>(headers);
        String url = uriBuilder.toUriString();
        logger.info("Consultando NASA EONET API: {}", url);

        try {
            ResponseEntity<NasaEonetApiResponseDTO> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    entity,
                    NasaEonetApiResponseDTO.class);

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                logger.info("Resposta da NASA EONET API para '{}': {} eventos retornados.", url,
                        response.getBody().getEvents() != null ? response.getBody().getEvents().size() : 0);
                return response.getBody();
            } else {
                logger.error("Erro ao consultar NASA EONET API. URL: {}, Status: {}", url, response.getStatusCode());
                throw new ServiceUnavailableException("Serviço NASA EONET retornou status: " + response.getStatusCode());
            }
        } catch (HttpClientErrorException | HttpServerErrorException e) {
            logger.error("Erro HTTP ao consultar NASA EONET API. URL: {}, Status: {}, Body: {}", url, e.getStatusCode(), e.getResponseBodyAsString(), e);
            throw new ServiceUnavailableException("Erro ao comunicar com o serviço NASA EONET: " + e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Erro inesperado ao consultar NASA EONET API. URL: {}: {}", url, e.getMessage(), e);
            throw new ServiceUnavailableException("Erro inesperado ao processar consulta à NASA EONET.", e);
        }
    }
    // ***** FIM DA MODIFICAÇÃO *****

    public String convertEventDtoToJsonString(NasaEonetEventDTO eventDto) {
        try {
            return objectMapper.writeValueAsString(eventDto);
        } catch (Exception e) {
            logger.error("Erro ao serializar NasaEonetEventDTO para JSON String: ID {}", eventDto != null ? eventDto.getId() : "null", e);
            return "{\"error\":\"Falha ao serializar evento para JSON\"}";
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\client\ViaCepClient.java   |   package br.com.fiap.gs.gsapi.client   |   class ViaCepClient
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.client;

// Correção: Importar ViaCepResponseDTO do pacote 'response' conforme sua estrutura
import br.com.fiap.gs.gsapi.dto.response.ViaCepResponseDTO;
import br.com.fiap.gs.gsapi.exception.ServiceUnavailableException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.RestTemplate;

@Component
public class ViaCepClient {

    private static final Logger logger = LoggerFactory.getLogger(ViaCepClient.class);
    private final RestTemplate restTemplate;

    @Value("${viacep.api.url:https://viacep.com.br/ws}")
    private String viaCepApiUrl;

    @Autowired
    public ViaCepClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public ViaCepResponseDTO buscarEnderecoPorCep(String cep) {
        if (cep == null || cep.trim().isEmpty()) {
            throw new IllegalArgumentException("CEP não pode ser nulo ou vazio.");
        }
        String cepFormatado = cep.replaceAll("[^0-9]", "");
        if (cepFormatado.length() != 8) {
            throw new IllegalArgumentException("CEP deve conter 8 dígitos numéricos.");
        }

        String url = String.format("%s/%s/json/", viaCepApiUrl, cepFormatado);
        logger.info("Consultando ViaCEP: {}", url);

        try {
            ResponseEntity<ViaCepResponseDTO> response = restTemplate.getForEntity(url, ViaCepResponseDTO.class);

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                if (response.getBody().isErro()) {
                    logger.warn("CEP {} não encontrado no ViaCEP.", cepFormatado);
                    return null;
                }
                logger.info("Resposta do ViaCEP para {}: {}", cepFormatado, response.getBody());
                return response.getBody();
            } else {
                logger.error("Erro ao consultar ViaCEP para {}. Status: {}", cepFormatado, response.getStatusCode());
                throw new ServiceUnavailableException("Serviço ViaCEP retornou status: " + response.getStatusCode());
            }
        } catch (HttpClientErrorException | HttpServerErrorException e) {
            logger.error("Erro HTTP ao consultar ViaCEP para {}: {} - {}", cepFormatado, e.getStatusCode(), e.getResponseBodyAsString(), e);
            throw new ServiceUnavailableException("Erro ao comunicar com o serviço ViaCEP: " + e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Erro inesperado ao consultar ViaCEP para {}: {}", cepFormatado, e.getMessage(), e);
            throw new ServiceUnavailableException("Erro inesperado ao processar consulta ao ViaCEP.", e);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\config\AppConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class AppConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.Duration;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        // Configura o RestTemplate com um timeout e um interceptor para logging (opcional)
        // BufferingClientHttpRequestFactory é útil se você quiser logar o corpo da requisição/resposta
        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
        requestFactory.setConnectTimeout((int) Duration.ofSeconds(10).toMillis());
        requestFactory.setReadTimeout((int) Duration.ofSeconds(10).toMillis());

        return builder
                .requestFactory(() -> new BufferingClientHttpRequestFactory(requestFactory))
                // .additionalInterceptors(new LoggingClientHttpRequestInterceptor()) // Crie esta classe se quiser logar
                .build();
    }

    @Bean
    public WebClient.Builder webClientBuilder() {
        // Configurações padrão para o WebClient.Builder, se necessário
        // Ex: timeouts, codecs, etc. podem ser configurados aqui globalmente
        // ou no momento da construção do WebClient específico.
        return WebClient.builder();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\config\CorsConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class CorsConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;
import java.util.List;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    private final Environment environment;

    // Origens permitidas para produção (leia do application.properties)
    // Ex: cors.production.allowed.origins=https://meufrontend.com,https://outrofrontend.com
    @Value("${cors.production.allowed.origins:}")
    private String[] productionAllowedOrigins;

    // Origens permitidas para desenvolvimento (pode ser fixo ou também configurável)
    @Value("${cors.development.allowed.origins:http://localhost:3000,http://localhost:3001,http://127.0.0.1:3000,http://127.0.0.1:3001}")
    private String[] developmentAllowedOrigins;

    public CorsConfig(Environment environment) {
        this.environment = environment;
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
        String[] allowedOriginsToUse;

        if (isProdProfileActive) {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÇÃO DE CORS PARA PRODUÇÃO <<<<<<<<<<");
            if (productionAllowedOrigins != null && productionAllowedOrigins.length > 0 &&
                    Arrays.stream(productionAllowedOrigins).anyMatch(origin -> origin != null && !origin.trim().isEmpty())) {
                allowedOriginsToUse = Arrays.stream(productionAllowedOrigins)
                        .filter(origin -> origin != null && !origin.trim().isEmpty())
                        .toArray(String[]::new);
                System.out.println("Allowed Origins (prod): " + String.join(", ", allowedOriginsToUse));
            } else {
                System.out.println("WARN: Nenhuma origem de produção VÁLIDA configurada para CORS (cors.production.allowed.origins). CORS estará altamente restrito.");
                // Por segurança, defina um fallback restrito ou nenhuma origem se não configurado
                allowedOriginsToUse = new String[]{}; // Ou uma URL de fallback muito específica
            }
        } else {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÇÃO DE CORS PARA DESENVOLVIMENTO/PADRÃO <<<<<<<<<<");
            allowedOriginsToUse = developmentAllowedOrigins;
            System.out.println("Allowed Origins (dev/default): " + String.join(", ", allowedOriginsToUse));
        }

        if (allowedOriginsToUse.length > 0) {
            registry.addMapping("/**") // Aplica a todas as rotas da API
                    .allowedOrigins(allowedOriginsToUse)
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD")
                    .allowedHeaders("*") // Permite todos os cabeçalhos
                    .allowCredentials(true) // Importante se você usar cookies ou autenticação baseada em sessão
                    .maxAge(3600); // Tempo em segundos que o resultado de uma requisição pre-flight OPTIONS pode ser cacheado
        } else if (isProdProfileActive) {
            // Se em produção e nenhuma origem válida foi configurada, não adicione nenhum mapping de CORS
            // ou adicione um muito restritivo para bloquear por padrão.
            System.out.println("WARN: CORS em produção está bloqueado pois nenhuma origem válida foi configurada.");
        }
    }

    // Alternativamente, você pode usar um CorsFilter Bean se preferir uma configuração mais programática
    // ou se precisar de mais controle sobre a ordem dos filtros.
    // @Bean
    // public CorsFilter corsFilter() {
    //     UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    //     CorsConfiguration config = new CorsConfiguration();
    //     config.setAllowCredentials(true);
    //
    //     boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
    //     if (isProdProfileActive && productionAllowedOrigins != null && productionAllowedOrigins.length > 0) {
    //         config.setAllowedOrigins(Arrays.asList(productionAllowedOrigins));
    //     } else {
    //         config.setAllowedOrigins(Arrays.asList(developmentAllowedOrigins)); // Ou use allowedOriginPatterns
    //     }
    //
    //     config.addAllowedHeader("*");
    //     config.addAllowedMethod("*"); // GET, POST, PUT, DELETE, etc.
    //     source.registerCorsConfiguration("/**", config);
    //     return new CorsFilter(source);
    // }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class OpenApiConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

/**
 * Classe de configuração do Springdoc OpenAPI para definir as informações detalhadas da API.
 * Isso inclui título, versão, descrição, informações de contato e licença,
 * que serão exibidos na interface do Swagger UI.
 */
@Configuration
public class OpenApiConfig {

    private static final Logger log = LoggerFactory.getLogger(OpenApiConfig.class);

    // Você pode injetar valores do application.properties se precisar
    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    @Bean
    public OpenAPI customOpenAPI() {
        log.info("🔧 Configuração personalizada do OpenAPI inicializada.");

        // Constrói a URL base do servidor dinamicamente
        String serverUrl = "http://localhost:" + serverPort + (contextPath != null ? contextPath : "");

        return new OpenAPI()
                .info(new Info()
                        .title("GS API - Alertas de Desastres Naturais") // Título da sua API
                        .version("v1.0.0") // Versão da sua API
                        .description("""
                                **API RESTful para o Global Solution FIAP 2025**

                                Esta API fornece funcionalidades para consulta de informações sobre desastres naturais
                                e gerenciamento de alertas para usuários com base em sua localização.
                                Integração com a API EONET da NASA e serviços de geolocalização.

                                **Funcionalidades Principais:**
                                - Cadastro e gerenciamento de clientes e seus endereços.
                                - Consulta de eventos de desastres naturais (via EONET).
                                - Associação de eventos de desastres a endereços de clientes.
                                - Visualização de alertas em mapas (a ser implementado no frontend).
                                """)
                        .contact(new Contact()
                                .name("Equipe GS API") // Nome da sua equipe ou seu nome
                                .email("seu-email@fiap.com.br") // Seu email de contato
                                .url("https://github.com/seu-usuario/gs-api-repo") // URL do seu projeto no GitHub
                        )
                        .license(new License()
                                .name("Apache 2.0") // Ou a licença que você escolher
                                .url("https://www.apache.org/licenses/LICENSE-2.0.html")
                        )
                )
                .servers(List.of(
                        new Server().url(serverUrl).description("Servidor Local de Desenvolvimento")
                        // Você pode adicionar outros servidores aqui (ex: homologação, produção)
                        // new Server().url("https://api.seudominio.com/gsapi").description("Servidor de Produção")
                ));
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java   |   package br.com.fiap.gs.gsapi.config   |   class SwaggerBrowserLauncher
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.EventListener;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Componente para abrir automaticamente o Swagger UI no navegador
 * quando a aplicação inicia em um perfil de desenvolvimento.
 */
@Configuration
@Profile("dev") // Ativa este componente apenas quando o perfil 'dev' estiver ativo
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    // O caminho padrão do Swagger UI é geralmente /swagger-ui/index.html ou /swagger-ui.html
    // Verifique a propriedade springdoc.swagger-ui.path se você a customizou
    @Value("${springdoc.swagger-ui.path:/swagger-ui.html}")
    private String swaggerUiPath;

    @Value("${app.launch-swagger-on-startup:true}") // Propriedade customizada para controlar o lançamento
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automática do Swagger UI no navegador está desabilitada via app.launch-swagger-on-startup=false.");
            return;
        }

        // Constrói a URL completa, garantindo que o contextPath seja tratado corretamente
        String effectiveContextPath = (contextPath == null || "/".equals(contextPath)) ? "" : contextPath;
        String effectiveSwaggerUiPath = swaggerUiPath.startsWith("/") ? swaggerUiPath : "/" + swaggerUiPath;

        String url = "http://localhost:" + serverPort + effectiveContextPath + effectiveSwaggerUiPath;
        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI: {}", url);
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI (URL: {}): {}", url, e.getMessage(), e);
            }
        } else {
            log.warn("Abertura automática do navegador não é suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\controller\ClienteController.java   |   package br.com.fiap.gs.gsapi.controller   |   class ClienteController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.service.ClienteService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/api/clientes")
@Tag(name = "Clientes", description = "Endpoints para gerenciamento de clientes")
public class ClienteController {

    private final ClienteService clienteService;

    @Autowired
    public ClienteController(ClienteService clienteService) {
        this.clienteService = clienteService;
    }

    @Operation(summary = "Lista todos os clientes de forma paginada")
    @ApiResponse(responseCode = "200", description = "Lista de clientes retornada com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class)))
    @GetMapping
    public ResponseEntity<Page<ClienteResponseDTO>> listarTodosClientes(
            @PageableDefault(size = 10, sort = {"nome"}) Pageable pageable) {
        Page<ClienteResponseDTO> clientes = clienteService.listarTodos(pageable);
        return ResponseEntity.ok(clientes);
    }

    @Operation(summary = "Busca um cliente pelo seu ID")
    @ApiResponse(responseCode = "200", description = "Cliente encontrado",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Cliente não encontrado", content = @Content)
    @GetMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> buscarClientePorId(@PathVariable Long id) {
        ClienteResponseDTO cliente = clienteService.buscarPorId(id);
        return ResponseEntity.ok(cliente);
    }

    @Operation(summary = "Busca um cliente pelo seu Documento (CPF/CNPJ)")
    @ApiResponse(responseCode = "200", description = "Cliente encontrado",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Cliente não encontrado", content = @Content)
    @GetMapping("/documento/{documento}")
    public ResponseEntity<ClienteResponseDTO> buscarClientePorDocumento(@PathVariable String documento) {
        ClienteResponseDTO cliente = clienteService.buscarPorDocumento(documento);
        return ResponseEntity.ok(cliente);
    }

    @Operation(summary = "Cria um novo cliente")
    @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class)))
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos", content = @Content)
    @PostMapping
    public ResponseEntity<ClienteResponseDTO> criarCliente(
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO,
            UriComponentsBuilder uriBuilder) {
        ClienteResponseDTO clienteSalvo = clienteService.criarCliente(clienteRequestDTO);
        URI location = uriBuilder.path("/api/clientes/{id}").buildAndExpand(clienteSalvo.getIdCliente()).toUri();
        return ResponseEntity.created(location).body(clienteSalvo);
    }

    @Operation(summary = "Atualiza um cliente existente")
    @ApiResponse(responseCode = "200", description = "Cliente atualizado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Cliente não encontrado", content = @Content)
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos", content = @Content)
    @PutMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> atualizarCliente(
            @PathVariable Long id,
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO) {
        ClienteResponseDTO clienteAtualizado = clienteService.atualizarCliente(id, clienteRequestDTO);
        return ResponseEntity.ok(clienteAtualizado);
    }

    @Operation(summary = "Deleta um cliente pelo seu ID")
    @ApiResponse(responseCode = "204", description = "Cliente deletado com sucesso")
    @ApiResponse(responseCode = "404", description = "Cliente não encontrado", content = @Content)
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarCliente(@PathVariable Long id) {
        clienteService.deletarCliente(id);
        return ResponseEntity.noContent().build();
    }

    @Operation(summary = "Pesquisa clientes por nome ou sobrenome")
    @ApiResponse(responseCode = "200", description = "Resultado da pesquisa de clientes",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class)))
    @GetMapping("/pesquisar")
    public ResponseEntity<Page<ClienteResponseDTO>> pesquisarClientes(
            @Parameter(description = "Termo para buscar no nome ou sobrenome do cliente") @RequestParam String termo,
            @PageableDefault(size = 10, sort = {"nome"}) Pageable pageable) {
        Page<ClienteResponseDTO> clientes = clienteService.pesquisarClientes(termo, pageable);
        return ResponseEntity.ok(clientes);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\controller\ContatoController.java   |   package br.com.fiap.gs.gsapi.controller   |   class ContatoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Arquivo: src/main/java/br/com/fiap/gs/gsapi/controller/ContatoController.java
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.service.ContatoService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/api/contatos")
@Tag(name = "Contatos", description = "Endpoints para gerenciamento de contatos")
public class ContatoController {

    private final ContatoService contatoService;

    @Autowired
    public ContatoController(ContatoService contatoService) {
        this.contatoService = contatoService;
    }

    @Operation(summary = "Cria um novo contato")
    @ApiResponse(responseCode = "201", description = "Contato criado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ContatoResponseDTO.class)))
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos", content = @Content)
    @PostMapping
    public ResponseEntity<ContatoResponseDTO> criarContato(
            @Valid @RequestBody ContatoRequestDTO contatoRequestDTO,
            UriComponentsBuilder uriBuilder) {
        ContatoResponseDTO contatoSalvo = contatoService.criarContato(contatoRequestDTO);
        URI location = uriBuilder.path("/api/contatos/{id}").buildAndExpand(contatoSalvo.getIdContato()).toUri();
        return ResponseEntity.created(location).body(contatoSalvo);
    }

    @Operation(summary = "Lista todos os contatos de forma paginada")
    @ApiResponse(responseCode = "200", description = "Lista de contatos retornada com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class)))
    @GetMapping
    public ResponseEntity<Page<ContatoResponseDTO>> listarTodosContatos(
            @PageableDefault(size = 10, sort = {"email"}) Pageable pageable) {
        Page<ContatoResponseDTO> contatos = contatoService.listarTodos(pageable);
        return ResponseEntity.ok(contatos);
    }

    @Operation(summary = "Busca um contato pelo seu ID")
    @ApiResponse(responseCode = "200", description = "Contato encontrado",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ContatoResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Contato não encontrado", content = @Content)
    @GetMapping("/{id}")
    public ResponseEntity<ContatoResponseDTO> buscarContatoPorId(@PathVariable Long id) {
        ContatoResponseDTO contato = contatoService.buscarPorId(id);
        return ResponseEntity.ok(contato);
    }

    @Operation(summary = "Busca um contato pelo seu email")
    @ApiResponse(responseCode = "200", description = "Contato encontrado",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ContatoResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Contato não encontrado com este email", content = @Content)
    @GetMapping("/email/{email}")
    public ResponseEntity<ContatoResponseDTO> buscarContatoPorEmail(@PathVariable String email) {
        ContatoResponseDTO contato = contatoService.buscarPorEmail(email);
        return ResponseEntity.ok(contato);
    }

    @Operation(summary = "Atualiza um contato existente")
    @ApiResponse(responseCode = "200", description = "Contato atualizado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ContatoResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Contato não encontrado", content = @Content)
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos", content = @Content)
    @PutMapping("/{id}")
    public ResponseEntity<ContatoResponseDTO> atualizarContato(
            @PathVariable Long id,
            @Valid @RequestBody ContatoRequestDTO contatoRequestDTO) {
        ContatoResponseDTO contatoAtualizado = contatoService.atualizarContato(id, contatoRequestDTO);
        return ResponseEntity.ok(contatoAtualizado);
    }

    @Operation(summary = "Deleta um contato pelo seu ID")
    @ApiResponse(responseCode = "204", description = "Contato deletado com sucesso")
    @ApiResponse(responseCode = "404", description = "Contato não encontrado", content = @Content)
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarContato(@PathVariable Long id) {
        contatoService.deletarContato(id);
        return ResponseEntity.noContent().build();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\controller\EnderecoController.java   |   package br.com.fiap.gs.gsapi.controller   |   class EnderecoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.controller;

// Correção: Importar ViaCepResponseDTO do pacote 'response'
import br.com.fiap.gs.gsapi.dto.response.ViaCepResponseDTO;
import br.com.fiap.gs.gsapi.dto.request.EnderecoGeoRequestDTO;
import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.dto.response.GeoCoordinatesDTO;
import br.com.fiap.gs.gsapi.service.EnderecoService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/api/enderecos")
@Tag(name = "Endereços", description = "Endpoints para gerenciamento de endereços")
public class EnderecoController {

    private final EnderecoService enderecoService;

    @Autowired
    public EnderecoController(EnderecoService enderecoService) {
        this.enderecoService = enderecoService;
    }

    @Operation(summary = "Lista todos os endereços de forma paginada")
    @ApiResponse(responseCode = "200", description = "Lista de endereços retornada com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class)))
    @GetMapping
    public ResponseEntity<Page<EnderecoResponseDTO>> listarTodosEnderecos(
            @PageableDefault(size = 10, sort = {"cep"}) Pageable pageable) {
        Page<EnderecoResponseDTO> enderecos = enderecoService.listarTodos(pageable);
        return ResponseEntity.ok(enderecos);
    }

    @Operation(summary = "Busca um endereço pelo seu ID")
    @ApiResponse(responseCode = "200", description = "Endereço encontrado",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Endereço não encontrado", content = @Content)
    @GetMapping("/{id}")
    public ResponseEntity<EnderecoResponseDTO> buscarEnderecoPorId(@PathVariable Long id) {
        EnderecoResponseDTO endereco = enderecoService.buscarPorId(id);
        return ResponseEntity.ok(endereco);
    }

    @Operation(summary = "Consulta dados de endereço a partir de um CEP (ViaCEP)")
    @ApiResponse(responseCode = "200", description = "Dados do CEP retornados com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ViaCepResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "CEP não encontrado ou inválido", content = @Content)
    @ApiResponse(responseCode = "400", description = "Formato de CEP inválido", content = @Content)
    @ApiResponse(responseCode = "503", description = "Serviço ViaCEP indisponível ou erro de comunicação", content = @Content)
    @GetMapping("/consultar-cep/{cep}")
    public ResponseEntity<ViaCepResponseDTO> consultarCep(
            @Parameter(description = "CEP a ser consultado (apenas números ou formato XXXXX-XXX)", example = "01001000")
            @PathVariable String cep) {
        ViaCepResponseDTO enderecoViaCep = enderecoService.consultarDadosPorCep(cep);
        return ResponseEntity.ok(enderecoViaCep);
    }

    @Operation(summary = "Calcula latitude e longitude para um endereço usando Nominatim")
    @ApiResponse(responseCode = "200", description = "Coordenadas calculadas com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = GeoCoordinatesDTO.class)))
    @ApiResponse(responseCode = "404", description = "Endereço não encontrado para geocodificação", content = @Content)
    @ApiResponse(responseCode = "400", description = "Dados de endereço insuficientes ou inválidos", content = @Content)
    @ApiResponse(responseCode = "503", description = "Serviço de geocodificação indisponível ou erro de comunicação", content = @Content)
    @PostMapping("/calcular-coordenadas")
    public ResponseEntity<GeoCoordinatesDTO> calcularCoordenadas(
            @Valid @RequestBody EnderecoGeoRequestDTO enderecoGeoRequestDTO) {
        GeoCoordinatesDTO coordenadas = enderecoService.calcularCoordenadasPorEndereco(enderecoGeoRequestDTO);
        return ResponseEntity.ok(coordenadas);
    }

    @Operation(summary = "Cria um novo endereço.")
    @ApiResponse(responseCode = "201", description = "Endereço criado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class)))
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: latitude/longitude ausentes)", content = @Content)
    @PostMapping
    public ResponseEntity<EnderecoResponseDTO> criarEndereco(
            @Valid @RequestBody EnderecoRequestDTO enderecoRequestDTO,
            UriComponentsBuilder uriBuilder) {
        EnderecoResponseDTO enderecoSalvo = enderecoService.criarEndereco(enderecoRequestDTO);
        URI location = uriBuilder.path("/api/enderecos/{id}").buildAndExpand(enderecoSalvo.getIdEndereco()).toUri();
        return ResponseEntity.created(location).body(enderecoSalvo);
    }

    @Operation(summary = "Atualiza um endereço existente")
    @ApiResponse(responseCode = "200", description = "Endereço atualizado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Endereço não encontrado", content = @Content)
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos", content = @Content)
    @PutMapping("/{id}")
    public ResponseEntity<EnderecoResponseDTO> atualizarEndereco(
            @PathVariable Long id,
            @Valid @RequestBody EnderecoRequestDTO enderecoRequestDTO) {
        EnderecoResponseDTO enderecoAtualizado = enderecoService.atualizarEndereco(id, enderecoRequestDTO);
        return ResponseEntity.ok(enderecoAtualizado);
    }

    @Operation(summary = "Deleta um endereço pelo seu ID")
    @ApiResponse(responseCode = "204", description = "Endereço deletado com sucesso")
    @ApiResponse(responseCode = "404", description = "Endereço não encontrado", content = @Content)
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarEndereco(@PathVariable Long id) {
        enderecoService.deletarEndereco(id);
        return ResponseEntity.noContent().build();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\controller\EonetController.java   |   package br.com.fiap.gs.gsapi.controller   |   class EonetController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Arquivo: src/main/java/br/com/fiap/gs/gsapi/controller/EonetController.java
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.external.NasaEonetEventDTO;
import br.com.fiap.gs.gsapi.dto.request.EonetRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EonetResponseDTO;
import br.com.fiap.gs.gsapi.service.EonetService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.web.PageableDefault;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;
import java.time.OffsetDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/eonet")
@Tag(name = "EONET Eventos", description = "Endpoints para gerenciamento de eventos EONET, incluindo sincronização e busca por proximidade na NASA API")
public class EonetController {

    private final EonetService eonetService;

    @Autowired
    public EonetController(EonetService eonetService) {
        this.eonetService = eonetService;
    }

    // ... (outros endpoints CRUD e de sincronização permanecem os mesmos) ...
    @Operation(summary = "Lista todos os eventos EONET armazenados localmente, de forma paginada")
    @GetMapping
    public ResponseEntity<Page<EonetResponseDTO>> listarTodosEventosEonetLocalmente(
            @PageableDefault(size = 10, sort = {"data"}, direction = Sort.Direction.DESC) Pageable pageable) {
        Page<EonetResponseDTO> eventos = eonetService.listarTodosEventos(pageable);
        return ResponseEntity.ok(eventos);
    }

    @Operation(summary = "Busca um evento EONET armazenado pelo seu ID interno no banco de dados")
    @GetMapping("/{idInterno}")
    public ResponseEntity<EonetResponseDTO> buscarEventoLocalPorIdInterno(@PathVariable Long idInterno) {
        EonetResponseDTO evento = eonetService.buscarEventoPorIdInterno(idInterno);
        return ResponseEntity.ok(evento);
    }

    @Operation(summary = "Busca um evento EONET armazenado pelo ID da API da NASA")
    @GetMapping("/api-id/{eonetApiId}")
    public ResponseEntity<EonetResponseDTO> buscarEventoLocalPorEonetApiId(@PathVariable String eonetApiId) {
        EonetResponseDTO evento = eonetService.buscarEventoPorEonetApiId(eonetApiId);
        return ResponseEntity.ok(evento);
    }

    @Operation(summary = "Salva manualmente um novo evento EONET no banco local")
    @ApiResponse(responseCode = "201", description = "Evento EONET salvo com sucesso")
    @PostMapping
    public ResponseEntity<EonetResponseDTO> salvarEventoEonetManualmente(
            @Valid @RequestBody EonetRequestDTO eonetRequestDTO,
            UriComponentsBuilder uriBuilder) {
        EonetResponseDTO eventoSalvo = eonetService.salvarEventoManualmente(eonetRequestDTO);
        URI location = uriBuilder.path("/api/eonet/{idInterno}").buildAndExpand(eventoSalvo.getIdEonet()).toUri();
        return ResponseEntity.created(location).body(eventoSalvo);
    }

    @Operation(summary = "Atualiza manualmente um evento EONET existente no banco local")
    @PutMapping("/{idInterno}")
    public ResponseEntity<EonetResponseDTO> atualizarEventoEonetManualmente(
            @PathVariable Long idInterno,
            @Valid @RequestBody EonetRequestDTO eonetRequestDTO) {
        EonetResponseDTO eventoAtualizado = eonetService.atualizarEventoManualmente(idInterno, eonetRequestDTO);
        return ResponseEntity.ok(eventoAtualizado);
    }

    @Operation(summary = "Deleta um evento EONET do banco local pelo seu ID interno")
    @DeleteMapping("/{idInterno}")
    public ResponseEntity<Void> deletarEventoEonetLocal(@PathVariable Long idInterno) {
        eonetService.deletarEvento(idInterno);
        return ResponseEntity.noContent().build();
    }

    @Operation(summary = "Busca eventos EONET armazenados localmente dentro de um intervalo de datas")
    @GetMapping("/por-data")
    public ResponseEntity<List<EonetResponseDTO>> buscarEventosLocaisPorIntervaloDeData(
            @Parameter(description = "Data inicial do evento (formato ISO OffsetDateTime:คณะ-MM-dd'T'HH:mm:ssXXX)", required = true, example = "2023-01-01T00:00:00-03:00")
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) OffsetDateTime dataInicial,
            @Parameter(description = "Data final do evento (formato ISO OffsetDateTime:คณะ-MM-dd'T'HH:mm:ssXXX)", required = true, example = "2023-01-31T23:59:59-03:00")
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) OffsetDateTime dataFinal) {
        List<EonetResponseDTO> eventos = eonetService.buscarEventosPorIntervaloDeData(dataInicial, dataFinal);
        return ResponseEntity.ok(eventos);
    }

    @Operation(summary = "Busca novos eventos da API da NASA EONET e os persiste/atualiza localmente.")
    @ApiResponse(responseCode = "200", description = "Sincronização concluída, retorna lista de eventos processados.",
            content = @Content(mediaType = "application/json", array = @ArraySchema(schema = @Schema(implementation = EonetResponseDTO.class))))
    @ApiResponse(responseCode = "503", description = "Serviço NASA EONET indisponível.")
    @PostMapping("/nasa/sincronizar")
    public ResponseEntity<List<EonetResponseDTO>> sincronizarEventosDaNasa(
            @Parameter(description = "Número máximo de eventos a serem buscados.") @RequestParam(required = false) Integer limit,
            @Parameter(description = "Número de dias anteriores para buscar eventos.") @RequestParam(required = false) Integer days,
            @Parameter(description = "Status dos eventos (open, closed). Padrão 'open'.") @RequestParam(required = false, defaultValue = "open") String status,
            @Parameter(description = "Fonte dos eventos (PDC, MRR).") @RequestParam(required = false) String source) {
        List<EonetResponseDTO> novosEventosProcessados = eonetService.sincronizarEventosDaNasa(limit, days, status, source);
        return ResponseEntity.ok(novosEventosProcessados);
    }

    // ***** MÉTODO MODIFICADO PARA INCLUIR startDate e endDate *****
    @Operation(summary = "Busca eventos da API EONET da NASA. Permite busca por intervalo de datas, proximidade geográfica, ou globais recentes.")
    @ApiResponse(responseCode = "200", description = "Eventos encontrados.",
            content = @Content(mediaType = "application/json", array = @ArraySchema(schema = @Schema(implementation = NasaEonetEventDTO.class))))
    @ApiResponse(responseCode = "204", description = "Nenhum evento encontrado.")
    @ApiResponse(responseCode = "400", description = "Parâmetros inválidos.")
    @GetMapping("/nasa/proximos") // O nome do endpoint é mantido por consistência, mas agora é mais flexível
    public ResponseEntity<List<NasaEonetEventDTO>> buscarEventosDaNasa(
            @Parameter(description = "Latitude do ponto central (para busca por proximidade)", example = "-23.550520")
            @RequestParam(required = false) Double latitude,

            @Parameter(description = "Longitude do ponto central (para busca por proximidade)", example = "-46.633308")
            @RequestParam(required = false) Double longitude,

            @Parameter(description = "Raio de busca em km (para busca por proximidade)", example = "100")
            @RequestParam(required = false) Double raioKm,

            @Parameter(description = "Data de início da busca (formato YYYY-MM-DD). Se usada, 'days' é ignorado.", example = "2023-01-01")
            @RequestParam(required = false) String startDate, // Formato YYYY-MM-DD

            @Parameter(description = "Data de fim da busca (formato YYYY-MM-DD). Se usada, 'days' é ignorado.", example = "2023-01-31")
            @RequestParam(required = false) String endDate,   // Formato YYYY-MM-DD

            @Parameter(description = "Número máximo de eventos a retornar")
            @RequestParam(required = false) Integer limit,

            @Parameter(description = "Número de dias passados para buscar (usado se startDate/endDate não fornecidos)")
            @RequestParam(required = false) Integer days,

            @Parameter(description = "Status dos eventos (open, closed, ou vazio para todos)")
            @RequestParam(required = false) String status,

            @Parameter(description = "Fonte dos eventos (PDC, CEMS)")
            @RequestParam(required = false) String source) {

        List<NasaEonetEventDTO> eventos = eonetService.buscarEventosEonetProximosDaAPI(
                latitude, longitude, raioKm,
                limit, days, status, source,
                startDate, endDate); // Passa os novos parâmetros

        if (eventos == null || eventos.isEmpty()) {
            return ResponseEntity.noContent().build();
        }
        return ResponseEntity.ok(eventos);
    }
    // ***** FIM DA MODIFICAÇÃO *****
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\controller\StatsController.java   |   package br.com.fiap.gs.gsapi.controller   |   class StatsController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Arquivo: src/main/java/br/com/fiap/gs/gsapi/controller/StatsController.java
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.stats.CategoryCountDTO;
import br.com.fiap.gs.gsapi.service.EonetService; // Usaremos o EonetService por enquanto
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;


import java.util.List;

@RestController
@RequestMapping("/api/stats")
@Tag(name = "Estatísticas de Desastres", description = "Endpoints para obter dados estatísticos sobre eventos EONET")
public class StatsController {

    private final EonetService eonetService; // Poderia ser um StatsService dedicado no futuro

    @Autowired
    public StatsController(EonetService eonetService) {
        this.eonetService = eonetService;
    }

    @Operation(summary = "Obtém a contagem de eventos EONET locais por categoria para um determinado período em dias.")
    @ApiResponse(responseCode = "200", description = "Estatísticas por categoria retornadas com sucesso.",
            content = @Content(mediaType = "application/json",
                    array = @ArraySchema(schema = @Schema(implementation = CategoryCountDTO.class))))
    @ApiResponse(responseCode = "400", description = "Parâmetro 'days' inválido.")
    @GetMapping("/eonet/count-by-category")
    public ResponseEntity<List<CategoryCountDTO>> getEonetCountByCategory(
            @Parameter(description = "Número de dias no passado para considerar na estatística (ex: 365 para o último ano).", required = true, example = "365")
            @RequestParam(defaultValue = "365") int days) {

        if (days <= 0) {
            // Poderia lançar uma exceção mais específica ou retornar ResponseEntity.badRequest()
            // O GlobalExceptionHandler já pega IllegalArgumentException e retorna 400.
            throw new IllegalArgumentException("O parâmetro 'days' deve ser um número positivo.");
        }
        List<CategoryCountDTO> stats = eonetService.getEventCountByCategoryLastXDays(days);
        return ResponseEntity.ok(stats);
    }

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\controller\alert\AlertTriggerController.java   |   package br.com.fiap.gs.gsapi.controller.alert   |   class AlertTriggerController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.controller.alert
package br.com.fiap.gs.gsapi.controller.alert;

import br.com.fiap.gs.gsapi.dto.alert.UserAlertRequestDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.service.alert.UserSpecificAlertService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/alerts")
@Tag(name = "Alertas de Usuário", description = "Endpoints para disparar alertas específicos para usuários")
public class AlertTriggerController {

    private static final Logger logger = LoggerFactory.getLogger(AlertTriggerController.class);
    private final UserSpecificAlertService userSpecificAlertService;

    @Autowired
    public AlertTriggerController(UserSpecificAlertService userSpecificAlertService) {
        this.userSpecificAlertService = userSpecificAlertService;
    }

    @PostMapping("/trigger-user-specific-alert")
    @Operation(summary = "Dispara um alerta para um usuário específico sobre um evento",
            description = "Recebe o ID do usuário e detalhes de um evento, busca o contato do usuário e envia uma notificação.")
    @ApiResponse(responseCode = "200", description = "Solicitação de alerta processada (não garante o envio, verifique logs).")
    @ApiResponse(responseCode = "400", description = "Requisição inválida.")
    @ApiResponse(responseCode = "404", description = "Usuário não encontrado.")
    public ResponseEntity<String> triggerAlertForUser(@Valid @RequestBody UserAlertRequestDTO requestDTO) {
        try {
            logger.info("Recebida requisição para alertar usuário ID: {} sobre evento: {}", requestDTO.getUserId(), requestDTO.getEventDetails().getTitle());
            userSpecificAlertService.processAndSendAlert(requestDTO.getUserId(), requestDTO.getEventDetails());
            return ResponseEntity.ok("Solicitação de alerta para usuário ID " + requestDTO.getUserId() + " processada.");
        } catch (ResourceNotFoundException e) {
            logger.warn("Não foi possível processar alerta: {}", e.getMessage());
            throw e; // Deixa o GlobalExceptionHandler tratar
        } catch (Exception e) {
            logger.error("Erro inesperado ao processar solicitação de alerta para usuário ID: {}", requestDTO.getUserId(), e);
            // Pode retornar um ResponseEntity.internalServerError() ou deixar o GlobalExceptionHandler
            return ResponseEntity.internalServerError().body("Erro interno ao processar a solicitação de alerta.");
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\alert\AlertableEventDTO.java   |   package br.com.fiap.gs.gsapi.dto.alert   |   class AlertableEventDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.alert
package br.com.fiap.gs.gsapi.dto.alert;

import java.time.OffsetDateTime;

public class AlertableEventDTO {
    private String eventId; // Ex: ID da EONET
    private String title;
    private String eventDate; // Pode ser String formatada ou OffsetDateTime se preferir converter
    private String link;      // Link para mais detalhes sobre o evento
    private String description; // Uma breve descrição do que será enviado no alerta

    // Construtores, Getters e Setters

    public AlertableEventDTO() {
    }

    public AlertableEventDTO(String eventId, String title, String eventDate, String link, String description) {
        this.eventId = eventId;
        this.title = title;
        this.eventDate = eventDate;
        this.link = link;
        this.description = description;
    }

    public String getEventId() {
        return eventId;
    }

    public void setEventId(String eventId) {
        this.eventId = eventId;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getEventDate() {
        return eventDate;
    }

    public void setEventDate(String eventDate) {
        this.eventDate = eventDate;
    }

    public String getLink() {
        return link;
    }

    public void setLink(String link) {
        this.link = link;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\alert\UserAlertRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.alert   |   class UserAlertRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.dto.alert
package br.com.fiap.gs.gsapi.dto.alert;

import jakarta.validation.constraints.NotNull;

public class UserAlertRequestDTO {

    @NotNull(message = "O ID do usuário não pode ser nulo.")
    private Long userId;

    @NotNull(message = "Os detalhes do evento não podem ser nulos.")
    private AlertableEventDTO eventDetails;

    // Construtores, Getters e Setters

    public UserAlertRequestDTO() {
    }

    public UserAlertRequestDTO(Long userId, AlertableEventDTO eventDetails) {
        this.userId = userId;
        this.eventDetails = eventDetails;
    }

    public Long getUserId() {
        return userId;
    }

    public void setUserId(Long userId) {
        this.userId = userId;
    }

    public AlertableEventDTO getEventDetails() {
        return eventDetails;
    }

    public void setEventDetails(AlertableEventDTO eventDetails) {
        this.eventDetails = eventDetails;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\external\GoogleGeocodingApiResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.external   |   class GoogleGeocodingApiResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.List;

@JsonIgnoreProperties(ignoreUnknown = true)
public class GoogleGeocodingApiResponseDTO {

    @JsonProperty("results")
    private List<GoogleGeocodingResultDTO> results;

    @JsonProperty("status")
    private String status; // Ex: "OK", "ZERO_RESULTS", etc.

    @JsonProperty("error_message")
    private String errorMessage;

    public GoogleGeocodingApiResponseDTO() {
    }

    // Getters e Setters
    public List<GoogleGeocodingResultDTO> getResults() {
        return results;
    }
    public void setResults(List<GoogleGeocodingResultDTO> results) {
        this.results = results;
    }
    public String getStatus() {
        return status;
    }
    public void setStatus(String status) {
        this.status = status;
    }
    public String getErrorMessage() {
        return errorMessage;
    }
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\external\GoogleGeocodingGeometryDTO.java   |   package br.com.fiap.gs.gsapi.dto.external   |   class GoogleGeocodingGeometryDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

@JsonIgnoreProperties(ignoreUnknown = true)
public class GoogleGeocodingGeometryDTO {

    @JsonProperty("location")
    private GoogleGeocodingLocationDTO location;

    public GoogleGeocodingGeometryDTO() {
    }

    // Getters e Setters
    public GoogleGeocodingLocationDTO getLocation() {
        return location;
    }
    public void setLocation(GoogleGeocodingLocationDTO location) {
        this.location = location;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\external\GoogleGeocodingLocationDTO.java   |   package br.com.fiap.gs.gsapi.dto.external   |   class GoogleGeocodingLocationDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

@JsonIgnoreProperties(ignoreUnknown = true)
public class GoogleGeocodingLocationDTO {

    @JsonProperty("lat")
    private double latitude;

    @JsonProperty("lng")
    private double longitude;

    public GoogleGeocodingLocationDTO() {
    }

    // Getters e Setters
    public double getLatitude() {
        return latitude;
    }
    public void setLatitude(double latitude) {
        this.latitude = latitude;
    }
    public double getLongitude() {
        return longitude;
    }
    public void setLongitude(double longitude) {
        this.longitude = longitude;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\external\GoogleGeocodingResultDTO.java   |   package br.com.fiap.gs.gsapi.dto.external   |   class GoogleGeocodingResultDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.List;

@JsonIgnoreProperties(ignoreUnknown = true)
public class GoogleGeocodingResultDTO {

    @JsonProperty("formatted_address")
    private String formattedAddress;

    @JsonProperty("geometry")
    private GoogleGeocodingGeometryDTO geometry;

    @JsonProperty("place_id")
    private String placeId;

    @JsonProperty("types")
    private List<String> types;

    public GoogleGeocodingResultDTO() {
    }

    // Getters e Setters
    public String getFormattedAddress() {
        return formattedAddress;
    }
    public void setFormattedAddress(String formattedAddress) {
        this.formattedAddress = formattedAddress;
    }
    public GoogleGeocodingGeometryDTO getGeometry() {
        return geometry;
    }
    public void setGeometry(GoogleGeocodingGeometryDTO geometry) {
        this.geometry = geometry;
    }
    public String getPlaceId() {
        return placeId;
    }
    public void setPlaceId(String placeId) {
        this.placeId = placeId;
    }
    public List<String> getTypes() {
        return types;
    }
    public void setTypes(List<String> types) {
        this.types = types;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\external\NasaEonetApiResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.external   |   class NasaEonetApiResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external; // Pacote correto

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.List;

@JsonIgnoreProperties(ignoreUnknown = true)
public class NasaEonetApiResponseDTO {
    @JsonProperty("title")
    private String title;
    @JsonProperty("description")
    private String description;
    @JsonProperty("link")
    private String link;
    @JsonProperty("events")
    private List<NasaEonetEventDTO> events;

    public NasaEonetApiResponseDTO() {}
    // Getters e Setters
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public String getLink() { return link; }
    public void setLink(String link) { this.link = link; }
    public List<NasaEonetEventDTO> getEvents() { return events; }
    public void setEvents(List<NasaEonetEventDTO> events) { this.events = events; }
    @Override
    public String toString() {
        return "NasaEonetApiResponseDTO{" + "title='" + title + '\'' + ", events_count=" + (events != null ? events.size() : 0) + '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\external\NasaEonetCategoryDTO.java   |   package br.com.fiap.gs.gsapi.dto.external   |   class NasaEonetCategoryDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external; // Pacote correto

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

@JsonIgnoreProperties(ignoreUnknown = true)
public class NasaEonetCategoryDTO {
    @JsonProperty("id")
    private String id;
    @JsonProperty("title")
    private String title;

    public NasaEonetCategoryDTO() {}
    // Getters e Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    @Override
    public String toString() {
        return "NasaEonetCategoryDTO{" + "id='" + id + '\'' + ", title='" + title + '\'' + '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\external\NasaEonetEventDTO.java   |   package br.com.fiap.gs.gsapi.dto.external   |   class NasaEonetEventDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external; // Pacote correto

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.OffsetDateTime;
import java.util.List;

@JsonIgnoreProperties(ignoreUnknown = true)
public class NasaEonetEventDTO {
    @JsonProperty("id")
    private String id;
    @JsonProperty("title")
    private String title;
    @JsonProperty("description")
    private String description;
    @JsonProperty("link")
    private String link;
    @JsonProperty("categories")
    private List<NasaEonetCategoryDTO> categories;
    @JsonProperty("sources")
    private List<NasaEonetSourceDTO> sources;
    @JsonProperty("geometry")
    private List<NasaEonetGeometryDTO> geometry;

    public NasaEonetEventDTO() {}
    // Getters e Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }
    public String getLink() { return link; }
    public void setLink(String link) { this.link = link; }
    public List<NasaEonetCategoryDTO> getCategories() { return categories; }
    public void setCategories(List<NasaEonetCategoryDTO> categories) { this.categories = categories; }
    public List<NasaEonetSourceDTO> getSources() { return sources; }
    public void setSources(List<NasaEonetSourceDTO> sources) { this.sources = sources; }
    public List<NasaEonetGeometryDTO> getGeometry() { return geometry; }
    public void setGeometry(List<NasaEonetGeometryDTO> geometry) { this.geometry = geometry; }
    public OffsetDateTime getPrincipalDate() {
        if (geometry != null && !geometry.isEmpty() && geometry.get(0) != null) {
            return geometry.get(0).getDate();
        }
        return null;
    }
    @Override
    public String toString() {
        return "NasaEonetEventDTO{" + "id='" + id + '\'' + ", title='" + title + '\'' + ", geometry=" + geometry + '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\external\NasaEonetGeometryDTO.java   |   package br.com.fiap.gs.gsapi.dto.external   |   class NasaEonetGeometryDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external; // Pacote correto

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.OffsetDateTime;
import java.util.List;

@JsonIgnoreProperties(ignoreUnknown = true)
public class NasaEonetGeometryDTO {
    @JsonProperty("date")
    private OffsetDateTime date;
    @JsonProperty("type")
    private String type;
    @JsonProperty("coordinates")
    private List<Object> coordinates;

    public NasaEonetGeometryDTO() {}
    // Getters e Setters
    public OffsetDateTime getDate() { return date; }
    public void setDate(OffsetDateTime date) { this.date = date; }
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    public List<Object> getCoordinates() { return coordinates; }
    public void setCoordinates(List<Object> coordinates) { this.coordinates = coordinates; }
    @Override
    public String toString() {
        return "NasaEonetGeometryDTO{" + "date=" + date + ", type='" + type + '\'' + ", coordinates=" + coordinates + '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\external\NasaEonetSourceDTO.java   |   package br.com.fiap.gs.gsapi.dto.external   |   class NasaEonetSourceDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external; // Pacote correto

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

@JsonIgnoreProperties(ignoreUnknown = true)
public class NasaEonetSourceDTO {
    @JsonProperty("id")
    private String id;
    @JsonProperty("url")
    private String url;

    public NasaEonetSourceDTO() {}
    // Getters e Setters
    public String getId() { return id; }
    public void setId(String id) { this.id = id; }
    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }
    @Override
    public String toString() {
        return "NasaEonetSourceDTO{" + "id='" + id + '\'' + ", url='" + url + '\'' + '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\geo\GeoCoordinatesDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class GeoCoordinatesDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response; // Ou br.com.fiap.gs.gsapi.dto.geo

public class GeoCoordinatesDTO {
    private double latitude;
    private double longitude;
    private String matchedAddress; // O endereço que o serviço de geocodificação identificou

    public GeoCoordinatesDTO() {
    }

    public GeoCoordinatesDTO(double latitude, double longitude, String matchedAddress) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.matchedAddress = matchedAddress;
    }

    // Getters e Setters
    public double getLatitude() {
        return latitude;
    }

    public void setLatitude(double latitude) {
        this.latitude = latitude;
    }

    public double getLongitude() {
        return longitude;
    }

    public void setLongitude(double longitude) {
        this.longitude = longitude;
    }

    public String getMatchedAddress() {
        return matchedAddress;
    }

    public void setMatchedAddress(String matchedAddress) {
        this.matchedAddress = matchedAddress;
    }

    @Override
    public String toString() {
        return "GeoCoordinatesDTO{" +
                "latitude=" + latitude +
                ", longitude=" + longitude +
                ", matchedAddress='" + matchedAddress + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class ClienteRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import java.util.List; // Para as listas de IDs
import java.util.Set; // Se preferir Set para IDs, mas List é comum para DTOs

public class ClienteRequestDTO {

    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(min = 2, max = 100, message = "O nome deve ter entre 2 e 100 caracteres.")
    private String nome;

    @NotBlank(message = "O sobrenome não pode estar em branco.")
    @Size(min = 2, max = 100, message = "O sobrenome deve ter entre 2 e 100 caracteres.")
    private String sobrenome;

    @NotBlank(message = "A data de nascimento não pode estar em branco.")
    // Aceita YYYY-MM-DD do input date HTML5 ou dd/MM/yyyy que era o pattern anterior da entidade
    @Pattern(regexp = "^(\\d{4}-\\d{2}-\\d{2}|\\d{2}/\\d{2}/\\d{4})$", message = "A data de nascimento deve estar no formato YYYY-MM-DD ou dd/MM/yyyy.")
    private String dataNascimento;

    @NotBlank(message = "O documento não pode estar em branco.")
    @Size(min = 11, max = 18, message = "O documento deve ter entre 11 e 18 caracteres.")
    private String documento;

    // IDs dos contatos e endereços existentes a serem associados
    // O frontend precisará fornecer estes IDs.
    // Pode ser uma lista vazia se não houver associações iniciais.
    private List<Long> contatosIds;
    private List<Long> enderecosIds;

    // Construtor Padrão
    public ClienteRequestDTO() {
    }

    // Construtor Completo
    public ClienteRequestDTO(String nome, String sobrenome, String dataNascimento, String documento, List<Long> contatosIds, List<Long> enderecosIds) {
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
        this.documento = documento;
        this.contatosIds = contatosIds;
        this.enderecosIds = enderecosIds;
    }

    // Getters e Setters
    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getSobrenome() {
        return sobrenome;
    }

    public void setSobrenome(String sobrenome) {
        this.sobrenome = sobrenome;
    }

    public String getDataNascimento() {
        return dataNascimento;
    }

    public void setDataNascimento(String dataNascimento) {
        this.dataNascimento = dataNascimento;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public List<Long> getContatosIds() {
        return contatosIds;
    }

    public void setContatosIds(List<Long> contatosIds) {
        this.contatosIds = contatosIds;
    }

    public List<Long> getEnderecosIds() {
        return enderecosIds;
    }

    public void setEnderecosIds(List<Long> enderecosIds) {
        this.enderecosIds = enderecosIds;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class ContatoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class ContatoRequestDTO {

    @NotBlank(message = "O DDD não pode estar em branco.")
    @Size(min = 2, max = 3, message = "O DDD deve ter entre 2 e 3 caracteres.")
    private String ddd;

    @NotBlank(message = "O telefone não pode estar em branco.")
    @Size(min = 8, max = 15, message = "O telefone deve ter entre 8 e 15 caracteres.")
    @Pattern(regexp = "^[0-9]+$", message = "O telefone deve conter apenas números.")
    private String telefone;

    @NotBlank(message = "O celular não pode estar em branco.")
    @Size(min = 9, max = 15, message = "O celular deve ter entre 9 e 15 caracteres.")
    @Pattern(regexp = "^[0-9]+$", message = "O celular deve conter apenas números.")
    private String celular;

    @NotBlank(message = "O WhatsApp não pode estar em branco.")
    @Size(min = 9, max = 15, message = "O WhatsApp deve ter entre 9 e 15 caracteres.")
    @Pattern(regexp = "^[0-9]+$", message = "O WhatsApp deve conter apenas números.")
    private String whatsapp;

    @NotBlank(message = "O e-mail não pode estar em branco.")
    @Email(message = "O e-mail deve ser válido.")
    @Size(max = 255, message = "O e-mail não pode exceder 255 caracteres.")
    private String email;

    @NotBlank(message = "O tipo de contato não pode estar em branco.")
    @Size(max = 50, message = "O tipo de contato não pode exceder 50 caracteres.")
    private String tipoContato;

    // Getters e Setters
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\request\EnderecoGeoRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class EnderecoGeoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class EnderecoGeoRequestDTO {

    @NotBlank(message = "Logradouro é obrigatório para geocodificação.")
    @Size(max = 255)
    private String logradouro;

    @Size(max = 10) // Número pode ser opcional ou parte do logradouro para Nominatim
    private String numero;

    @NotBlank(message = "Cidade (Localidade) é obrigatória para geocodificação.")
    @Size(max = 100)
    private String cidade; // Localidade

    @NotBlank(message = "UF (Estado) é obrigatória para geocodificação.")
    @Size(min = 2, max = 2)
    private String uf;

    @Size(max = 100) // Bairro pode ajudar na precisão
    private String bairro;

    @Size(max = 9) // CEP pode ajudar na precisão
    private String cep;

    // Construtor padrão
    public EnderecoGeoRequestDTO() {}

    // Getters e Setters
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getNumero() { return numero; }
    public void setNumero(String numero) { this.numero = numero; }
    public String getCidade() { return cidade; }
    public void setCidade(String cidade) { this.cidade = cidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class EnderecoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Digits;


public class EnderecoRequestDTO {

    @NotBlank(message = "O CEP não pode estar em branco.")
    @Pattern(regexp = "^\\d{5}-?\\d{3}$", message = "O CEP deve estar no formato XXXXX-XXX ou XXXXXXXX.")
    private String cep;

    @NotNull(message = "O número não pode ser nulo.")
    // @Digits(integer = 5, fraction = 0, message = "O número deve ser um inteiro de até 5 dígitos.") // Se fosse string
    private Integer numero; // NUMBER(5)

    @NotBlank(message = "O logradouro não pode estar em branco.")
    @Size(max = 255, message = "O logradouro não pode exceder 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O bairro não pode estar em branco.")
    @Size(max = 255, message = "O bairro não pode exceder 255 caracteres.")
    private String bairro;

    @NotBlank(message = "A localidade (cidade) não pode estar em branco.")
    @Size(max = 100, message = "A localidade não pode exceder 100 caracteres.")
    private String localidade;

    @NotBlank(message = "A UF não pode estar em branco.")
    @Size(min = 2, max = 2, message = "A UF deve ter 2 caracteres.")
    private String uf;

    @NotBlank(message = "O complemento não pode estar em branco.") // DDL diz NOT NULL
    @Size(max = 255, message = "O complemento não pode exceder 255 caracteres.")
    private String complemento;

    // Latitude e Longitude serão preenchidas pelo ViaCEP/outra API,
    // então não são obrigatórias na requisição inicial do usuário,
    // mas podem ser enviadas se já conhecidas.
    @NotNull(message = "Latitude não pode ser nula.")
    @Digits(integer = 3, fraction = 7, message = "Latitude inválida.") // ex: -90.1234567
    private Double latitude;

    @NotNull(message = "Longitude não pode ser nula.")
    @Digits(integer = 4, fraction = 7, message = "Longitude inválida.") // ex: -180.1234567
    private Double longitude;


    // Getters e Setters
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public Integer getNumero() { return numero; }
    public void setNumero(Integer numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public Double getLatitude() { return latitude; }
    public void setLatitude(Double latitude) { this.latitude = latitude; }
    public Double getLongitude() { return longitude; }
    public void setLongitude(Double longitude) { this.longitude = longitude; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\request\EonetRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class EonetRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request; // Ajuste o pacote conforme sua estrutura

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.time.OffsetDateTime;

public class EonetRequestDTO {

    // O JSON pode ser grande, então não há @Size aqui,
    // mas pode ser @NotNull se o JSON sempre for esperado na criação.
    // Se o JSON for opcional na criação, remova @NotNull.
    @NotNull(message = "O conteúdo JSON não pode ser nulo.")
    private String json; // Para o campo CLOB

    // A data do evento pode ser opcional ou obrigatória dependendo do seu caso de uso.
    // Se for obrigatória na criação:
    @NotNull(message = "A data do evento não pode ser nula.")
    private OffsetDateTime data;

    @NotBlank(message = "O ID da API EONET não pode estar em branco.")
    @Size(max = 50, message = "O ID da API EONET não pode exceder 50 caracteres.")
    private String eonetIdApi; // ID único do evento vindo da API da NASA

    // Construtor Padrão
    public EonetRequestDTO() {
    }

    // Construtor Completo (opcional)
    public EonetRequestDTO(String json, OffsetDateTime data, String eonetIdApi) {
        this.json = json;
        this.data = data;
        this.eonetIdApi = eonetIdApi;
    }

    // Getters e Setters
    public String getJson() {
        return json;
    }

    public void setJson(String json) {
        this.json = json;
    }

    public OffsetDateTime getData() {
        return data;
    }

    public void setData(OffsetDateTime data) {
        this.data = data;
    }

    public String getEonetIdApi() {
        return eonetIdApi;
    }

    public void setEonetIdApi(String eonetIdApi) {
        this.eonetIdApi = eonetIdApi;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class ClienteResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

import br.com.fiap.gs.gsapi.model.Cliente;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;

import java.util.Set;
import java.util.stream.Collectors;

public class ClienteResponseDTO {

    private Long idCliente;
    private String nome;
    private String sobrenome;
    private String dataNascimento;
    private String documento;
    private Set<ContatoResponseDTO> contatos;
    private Set<EnderecoResponseDTO> enderecos;

    // Construtor Padrão
    public ClienteResponseDTO() {
    }

    // Construtor para facilitar a conversão da Entidade para DTO
    public ClienteResponseDTO(Cliente cliente) {
        this.idCliente = cliente.getIdCliente();
        this.nome = cliente.getNome();
        this.sobrenome = cliente.getSobrenome();
        this.dataNascimento = cliente.getDataNascimento();
        this.documento = cliente.getDocumento();
        if (cliente.getContatos() != null) {
            this.contatos = cliente.getContatos().stream()
                    .map(ContatoResponseDTO::new)
                    .collect(Collectors.toSet());
        }
        if (cliente.getEnderecos() != null) {
            this.enderecos = cliente.getEnderecos().stream()
                    .map(EnderecoResponseDTO::new)
                    .collect(Collectors.toSet());
        }
    }

    // Construtor com todos os campos (mantido para consistência, se usado em outros lugares)
    public ClienteResponseDTO(Long idCliente, String nome, String sobrenome, String dataNascimento, String documento, Set<ContatoResponseDTO> contatos, Set<EnderecoResponseDTO> enderecos) {
        this.idCliente = idCliente;
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
        this.documento = documento;
        this.contatos = contatos;
        this.enderecos = enderecos;
    }

    // Getters e Setters (completos)
    public Long getIdCliente() { return idCliente; }
    public void setIdCliente(Long idCliente) { this.idCliente = idCliente; }
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }
    public Set<ContatoResponseDTO> getContatos() { return contatos; }
    public void setContatos(Set<ContatoResponseDTO> contatos) { this.contatos = contatos; }
    public Set<EnderecoResponseDTO> getEnderecos() { return enderecos; }
    public void setEnderecos(Set<EnderecoResponseDTO> enderecos) { this.enderecos = enderecos; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class ContatoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

import br.com.fiap.gs.gsapi.model.Contato; // Import da entidade

public class ContatoResponseDTO {
    private Long idContato;
    private String ddd;
    private String telefone;
    private String celular;
    private String whatsapp;
    private String email;
    private String tipoContato;

    public ContatoResponseDTO() {}

    // CONSTRUTOR ADICIONADO que aceita a entidade Contato
    public ContatoResponseDTO(Contato contato) {
        if (contato != null) {
            this.idContato = contato.getIdContato();
            this.ddd = contato.getDdd();
            this.telefone = contato.getTelefone();
            this.celular = contato.getCelular();
            this.whatsapp = contato.getWhatsapp();
            this.email = contato.getEmail();
            this.tipoContato = contato.getTipoContato();
        }
    }

    // Construtor com todos os campos (mantido se usado em outro lugar)
    public ContatoResponseDTO(Long idContato, String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.idContato = idContato;
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    // Getters e Setters
    public Long getIdContato() { return idContato; }
    public void setIdContato(Long idContato) { this.idContato = idContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class EnderecoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

import br.com.fiap.gs.gsapi.model.Endereco; // Import da entidade

public class EnderecoResponseDTO {
    private Long idEndereco;
    private String cep;
    private Integer numero;
    private String logradouro;
    private String bairro;
    private String localidade;
    private String uf;
    private String complemento;
    private Double latitude;
    private Double longitude;

    public EnderecoResponseDTO() {}

    // CONSTRUTOR ADICIONADO que aceita a entidade Endereco
    public EnderecoResponseDTO(Endereco endereco) {
        if (endereco != null) {
            this.idEndereco = endereco.getIdEndereco();
            this.cep = endereco.getCep();
            this.numero = endereco.getNumero();
            this.logradouro = endereco.getLogradouro();
            this.bairro = endereco.getBairro();
            this.localidade = endereco.getLocalidade();
            this.uf = endereco.getUf();
            this.complemento = endereco.getComplemento();
            this.latitude = endereco.getLatitude();
            this.longitude = endereco.getLongitude();
        }
    }

    // Construtor com todos os campos (mantido se usado em outro lugar)
    public EnderecoResponseDTO(Long idEndereco, String cep, Integer numero, String logradouro, String bairro, String localidade, String uf, String complemento, Double latitude, Double longitude) {
        this.idEndereco = idEndereco;
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    // Getters e Setters
    public Long getIdEndereco() { return idEndereco; }
    public void setIdEndereco(Long idEndereco) { this.idEndereco = idEndereco; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public Integer getNumero() { return numero; }
    public void setNumero(Integer numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public Double getLatitude() { return latitude; }
    public void setLatitude(Double latitude) { this.latitude = latitude; }
    public Double getLongitude() { return longitude; }
    public void setLongitude(Double longitude) { this.longitude = longitude; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\response\EonetResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class EonetResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response; // Ajuste o pacote conforme sua estrutura

import br.com.fiap.gs.gsapi.model.Eonet; // Import necessário para o construtor
import java.time.OffsetDateTime;

public class EonetResponseDTO {

    private Long idEonet; // ID interno do seu banco
    private String json;
    private OffsetDateTime data;
    private String eonetIdApi; // ID da API da NASA

    // Construtor Padrão
    public EonetResponseDTO() {
    }

    // Construtor para facilitar a conversão da Entidade para DTO
    public EonetResponseDTO(Eonet eonet) {
        this.idEonet = eonet.getIdEonet();
        this.json = eonet.getJson(); // Pode ser necessário truncar ou tratar se for muito grande para logs
        this.data = eonet.getData();
        this.eonetIdApi = eonet.getEonetIdApi();
    }

    // Getters e Setters
    public Long getIdEonet() {
        return idEonet;
    }

    public void setIdEonet(Long idEonet) {
        this.idEonet = idEonet;
    }

    public String getJson() {
        return json;
    }

    public void setJson(String json) {
        this.json = json;
    }

    public OffsetDateTime getData() {
        return data;
    }

    public void setData(OffsetDateTime data) {
        this.data = data;
    }

    public String getEonetIdApi() {
        return eonetIdApi;
    }

    public void setEonetIdApi(String eonetIdApi) {
        this.eonetIdApi = eonetIdApi;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\response\NominatimResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class NominatimResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response; // <-- PACOTE CORRIGIDO

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

@JsonIgnoreProperties(ignoreUnknown = true)
public class NominatimResponseDTO {

    @JsonProperty("place_id")
    private long placeId;

    @JsonProperty("licence")
    private String licence;

    @JsonProperty("osm_type")
    private String osmType;

    @JsonProperty("osm_id")
    private long osmId;

    @JsonProperty("lat")
    private String latitude;

    @JsonProperty("lon")
    private String longitude;

    @JsonProperty("display_name")
    private String displayName;

    @JsonProperty("boundingbox")
    private String[] boundingBox;

    // Construtor padrão
    public NominatimResponseDTO() {
    }

    // Getters e Setters
    public long getPlaceId() {
        return placeId;
    }

    public void setPlaceId(long placeId) {
        this.placeId = placeId;
    }

    public String getLicence() {
        return licence;
    }

    public void setLicence(String licence) {
        this.licence = licence;
    }

    public String getOsmType() {
        return osmType;
    }

    public void setOsmType(String osmType) {
        this.osmType = osmType;
    }

    public long getOsmId() {
        return osmId;
    }

    public void setOsmId(long osmId) {
        this.osmId = osmId;
    }

    public String getLatitude() {
        return latitude;
    }

    public void setLatitude(String latitude) {
        this.latitude = latitude;
    }

    public String getLongitude() {
        return longitude;
    }

    public void setLongitude(String longitude) {
        this.longitude = longitude;
    }

    public String getDisplayName() {
        return displayName;
    }

    public void setDisplayName(String displayName) {
        this.displayName = displayName;
    }

    public String[] getBoundingBox() {
        return boundingBox;
    }

    public void setBoundingBox(String[] boundingBox) {
        this.boundingBox = boundingBox;
    }

    @Override
    public String toString() {
        return "NominatimResponseDTO{" +
                "latitude='" + latitude + '\'' +
                ", longitude='" + longitude + '\'' +
                ", displayName='" + displayName + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\response\ViaCepResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class ViaCepResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response; // <-- PACOTE CORRIGIDO

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true)
public class ViaCepResponseDTO {

    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade; // Cidade
    private String uf;
    private String ibge;
    private String gia;
    private String ddd;
    private String siafi;
    private boolean erro;

    // Construtores
    public ViaCepResponseDTO() {
    }

    // Getters e Setters
    public String getCep() {
        return cep;
    }

    public void setCep(String cep) {
        this.cep = cep;
    }

    public String getLogradouro() {
        return logradouro;
    }

    public void setLogradouro(String logradouro) {
        this.logradouro = logradouro;
    }

    public String getComplemento() {
        return complemento;
    }

    public void setComplemento(String complemento) {
        this.complemento = complemento;
    }

    public String getBairro() {
        return bairro;
    }

    public void setBairro(String bairro) {
        this.bairro = bairro;
    }

    public String getLocalidade() {
        return localidade;
    }

    public void setLocalidade(String localidade) {
        this.localidade = localidade;
    }

    public String getUf() {
        return uf;
    }

    public void setUf(String uf) {
        this.uf = uf;
    }

    public String getIbge() {
        return ibge;
    }

    public void setIbge(String ibge) {
        this.ibge = ibge;
    }

    public String getGia() {
        return gia;
    }

    public void setGia(String gia) {
        this.gia = gia;
    }

    public String getDdd() {
        return ddd;
    }

    public void setDdd(String ddd) {
        this.ddd = ddd;
    }

    public String getSiafi() {
        return siafi;
    }

    public void setSiafi(String siafi) {
        this.siafi = siafi;
    }

    public boolean isErro() {
        return erro;
    }

    public void setErro(boolean erro) {
        this.erro = erro;
    }

    @Override
    public String toString() {
        return "ViaCepResponseDTO{" +
                "cep='" + cep + '\'' +
                ", logradouro='" + logradouro + '\'' +
                ", complemento='" + complemento + '\'' +
                ", bairro='" + bairro + '\'' +
                ", localidade='" + localidade + '\'' +
                ", uf='" + uf + '\'' +
                ", ibge='" + ibge + '\'' +
                ", gia='" + gia + '\'' +
                ", ddd='" + ddd + '\'' +
                ", siafi='" + siafi + '\'' +
                ", erro=" + erro +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\stats\CategoryCountDTO.java   |   package br.com.fiap.gs.gsapi.dto.stats   |   class CategoryCountDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Arquivo: src/main/java/br/com/fiap/gs/gsapi/dto/stats/CategoryCountDTO.java
package br.com.fiap.gs.gsapi.dto.stats;

public class CategoryCountDTO {
    private String categoryTitle;
    private long count;

    public CategoryCountDTO() {
    }

    public CategoryCountDTO(String categoryTitle, long count) {
        this.categoryTitle = categoryTitle;
        this.count = count;
    }

    // Getters e Setters
    public String getCategoryTitle() {
        return categoryTitle;
    }

    public void setCategoryTitle(String categoryTitle) {
        this.categoryTitle = categoryTitle;
    }

    public long getCount() {
        return count;
    }

    public void setCount(long count) {
        this.count = count;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\dto\stats\TimeCountDTO.java   |   package br.com.fiap.gs.gsapi.dto.stats   |   class TimeCountDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Arquivo: src/main/java/br/com/fiap/gs/gsapi/dto/stats/TimeCountDTO.java
package br.com.fiap.gs.gsapi.dto.stats;

public class TimeCountDTO {
    private String timeLabel;
    private Long count; // Assegure que é Long (wrapper)

    // Construtor padrão (JPA/Hibernate podem precisar em alguns cenários, bom ter)
    public TimeCountDTO() {
    }

    // Construtor que a query JPQL usará - DEVE ser (String, Long)
    public TimeCountDTO(String timeLabel, Long count) {
        this.timeLabel = timeLabel;
        this.count = count;
    }

    // Getters
    public String getTimeLabel() {
        return timeLabel;
    }

    public Long getCount() {
        return count;
    }

    // Setters (Opcionais para DTOs de resposta, mas incluídos por completude)
    public void setTimeLabel(String timeLabel) {
        this.timeLabel = timeLabel;
    }

    public void setCount(Long count) {
        this.count = count;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java   |   package br.com.fiap.gs.gsapi.exception   |   class GlobalExceptionHandler
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// No seu arquivo br/com/fiap/gs/gsapi/exception/GlobalExceptionHandler.java

package br.com.fiap.gs.gsapi.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.MissingServletRequestParameterException; // << IMPORTAR
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    // ... (seus outros handlers existentes: ResourceNotFoundException, MethodArgumentNotValidException, etc.)

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(
            ResourceNotFoundException ex, WebRequest request) {
        logger.warn("Recurso não encontrado: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "Not Found");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, WebRequest request) {
        logger.warn("Erro de validação nos argumentos: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request - Validation Error");
        body.put("path", request.getDescription(false).replace("uri=", ""));
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.toList());
        body.put("messages", errors);
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Object> handleIllegalArgumentException(
            IllegalArgumentException ex, WebRequest request) {
        logger.warn("Argumento ilegal ou requisição inválida: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<Object> handleIllegalStateException(
            IllegalStateException ex, WebRequest request) {
        logger.warn("Estado ilegal para a operação: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.CONFLICT.value());
        body.put("error", "Conflict");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(ServiceUnavailableException.class)
    public ResponseEntity<Object> handleServiceUnavailableException(
            ServiceUnavailableException ex, WebRequest request) {
        logger.error("Serviço externo indisponível ou erro de comunicação: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.SERVICE_UNAVAILABLE.value());
        body.put("error", "Service Unavailable");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));
        return new ResponseEntity<>(body, HttpStatus.SERVICE_UNAVAILABLE);
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<Object> handleTypeMismatch(MethodArgumentTypeMismatchException ex, WebRequest request) {
        String paramName = ex.getName();
        Object paramValue = ex.getValue();
        String requiredType = ex.getRequiredType() != null ? ex.getRequiredType().getSimpleName() : "Desconhecido";

        String logMessage = String.format(
                "Falha na conversão de tipo do parâmetro da requisição: Nome=''%s'', Valor Recebido=''%s'', Tipo Esperado=''%s''. Erro: %s",
                paramName, paramValue, requiredType, ex.getMessage()
        );
        logger.warn(logMessage);

        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request - Invalid Parameter Type");
        body.put("message", "O valor '" + paramValue + "' fornecido para o parâmetro '" + paramName + "' não é válido. Tipo esperado: " + requiredType + ".");
        body.put("path", request.getDescription(false).replace("uri=", ""));

        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    // ***** NOVO HANDLER ADICIONADO PARA MissingServletRequestParameterException *****
    @ExceptionHandler(MissingServletRequestParameterException.class)
    public ResponseEntity<Object> handleMissingServletRequestParameter(
            MissingServletRequestParameterException ex, WebRequest request) {
        logger.warn("Parâmetro obrigatório da requisição ausente: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request - Missing Parameter");
        body.put("message", "O parâmetro obrigatório '" + ex.getParameterName() + "' do tipo '" + ex.getParameterType() + "' não foi encontrado na requisição.");
        body.put("path", request.getDescription(false).replace("uri=", ""));
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }
    // ***** FIM DO NOVO HANDLER *****

    @ExceptionHandler(Exception.class) // Handler genérico para outros erros 500
    public ResponseEntity<Object> handleGenericException(
            Exception ex, WebRequest request) {
        logger.error("Erro inesperado na aplicação: ", ex);
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        body.put("error", "Internal Server Error");
        body.put("message", "Ocorreu um erro inesperado. Por favor, tente novamente mais tarde ou contate o suporte se o problema persistir.");
        body.put("path", request.getDescription(false).replace("uri=", ""));

        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java   |   package br.com.fiap.gs.gsapi.exception   |   class ResourceNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND) // Mapeia esta exceção para o status HTTP 404 Not Found
public class ResourceNotFoundException extends RuntimeException {

    /**
     * Construtor que aceita uma mensagem para a exceção.
     * @param message A mensagem detalhando a causa da exceção.
     */
    public ResourceNotFoundException(String message) {
        super(message);
    }

    /**
     * Construtor que aceita uma mensagem e a causa original da exceção.
     * @param message A mensagem detalhando a causa da exceção.
     * @param cause A causa original (outra exceção que levou a esta).
     */
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\exception\ServiceUnavailableException.java   |   package br.com.fiap.gs.gsapi.exception   |   class ServiceUnavailableException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.SERVICE_UNAVAILABLE)
public class ServiceUnavailableException extends RuntimeException {
    public ServiceUnavailableException(String message) {
        super(message);
    }

    public ServiceUnavailableException(String message, Throwable cause) {
        super(message, cause);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class ClienteMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.model.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget; // Import necessário para @MappingTarget
// Não são necessários @Named ou @Context para esta versão simplificada.

@Mapper(componentModel = "spring", uses = {ContatoMapper.class, EnderecoMapper.class})
public interface ClienteMapper {

    // Para converter Entidade Cliente para ClienteResponseDTO
    // MapStruct usará ContatoMapper e EnderecoMapper para as coleções 'contatos' e 'enderecos'
    // devido à cláusula 'uses'.
    @Mapping(source = "contatos", target = "contatos")
    @Mapping(source = "enderecos", target = "enderecos")
    ClienteResponseDTO toResponseDTO(Cliente cliente);

    // Para converter ClienteRequestDTO para uma NOVA Entidade Cliente
    @Mapping(target = "idCliente", ignore = true) // ID é gerado pelo banco
    @Mapping(target = "contatos", ignore = true)  // Será tratado no ClienteService (busca por IDs de contatosIds)
    @Mapping(target = "enderecos", ignore = true) // Será tratado no ClienteService (busca por IDs de enderecosIds)
    Cliente toEntity(ClienteRequestDTO clienteRequestDTO);

    // Para ATUALIZAR uma Entidade Cliente existente com dados de ClienteRequestDTO
    @Mapping(target = "idCliente", ignore = true) // Não atualiza o ID
    @Mapping(target = "contatos", ignore = true)  // Associações de contatos são tratadas no serviço
    @Mapping(target = "enderecos", ignore = true) // Associações de endereços são tratadas no serviço
    // Os campos nome, sobrenome, dataNascimento, documento serão mapeados automaticamente
    // de ClienteRequestDTO para Cliente se os nomes e tipos forem compatíveis.
    void updateClienteFromDto(ClienteRequestDTO dto, @MappingTarget Cliente cliente);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class ContatoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.model.Contato;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring")
public interface ContatoMapper {

    ContatoMapper INSTANCE = Mappers.getMapper(ContatoMapper.class);

    ContatoResponseDTO toResponseDTO(Contato contato);

    Set<ContatoResponseDTO> toResponseDTOSet(Set<Contato> contatos); // Para coleções

    List<ContatoResponseDTO> toResponseDTOList(List<Contato> contatos); // Para coleções

    @Mapping(target = "idContato", ignore = true) // ID é gerado pelo banco
    @Mapping(target = "clientes", ignore = true) // Lado inverso, gerenciado pelo Cliente
    Contato toEntity(ContatoRequestDTO contatoRequestDTO);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class EnderecoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.model.Endereco;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring")
public interface EnderecoMapper {

    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    EnderecoResponseDTO toResponseDTO(Endereco endereco);

    Set<EnderecoResponseDTO> toResponseDTOSet(Set<Endereco> enderecos); // Para coleções

    List<EnderecoResponseDTO> toResponseDTOList(List<Endereco> enderecos); // Para coleções

    @Mapping(target = "idEndereco", ignore = true) // ID é gerado pelo banco
    @Mapping(target = "clientes", ignore = true)    // Lado inverso, gerenciado pelo Cliente
    @Mapping(target = "eventosEonet", ignore = true) // Relacionamento gerenciado aqui ou via serviço dedicado
    Endereco toEntity(EnderecoRequestDTO enderecoRequestDTO);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\mapper\EonetMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class EonetMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EonetRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EonetResponseDTO;
import br.com.fiap.gs.gsapi.model.Eonet;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

@Mapper(componentModel = "spring")
public interface EonetMapper {

    EonetMapper INSTANCE = Mappers.getMapper(EonetMapper.class);

    EonetResponseDTO toResponseDTO(Eonet eonet);

    @Mapping(target = "idEonet", ignore = true)
    @Mapping(target = "enderecos", ignore = true) // Relacionamento gerenciado pelo Endereco
    Eonet toEntity(EonetRequestDTO eonetRequestDTO);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\model\Cliente.java   |   package br.com.fiap.gs.gsapi.model   |   class Cliente
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "tb_cliente3")
public class Cliente {

    @Id
    @SequenceGenerator(name = "cliente_seq", sequenceName = "tb_cliente3_id_cliente_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "cliente_seq")
    @Column(name = "id_cliente")
    private Long idCliente; // Mapeia para id_cliente NUMBER NOT NULL [cite: 2]

    @Column(name = "nome", nullable = false, length = 100)
    private String nome; // Mapeia para nome VARCHAR2(100) NOT NULL [cite: 2]

    @Column(name = "sobrenome", nullable = false, length = 100)
    private String sobrenome; // Mapeia para sobrenome VARCHAR2(100) NOT NULL [cite: 1]

    @Column(name = "data_nascimento", nullable = false, length = 10)
    private String dataNascimento; // Mapeia para data_nascimento VARCHAR2(10) NOT NULL [cite: 1]

    @Column(name = "documento", nullable = false, length = 18)
    private String documento; // Mapeia para documento VARCHAR2(18) NOT NULL [cite: 1]

    @ManyToMany(fetch = FetchType.LAZY,
            cascade = {
                    CascadeType.PERSIST,
                    CascadeType.MERGE
            })
    @JoinTable(name = "tb_clientecontato3", // Tabela de junção [cite: 4]
            joinColumns = { @JoinColumn(name = "tb_cliente3_id_cliente") }, // FK para tb_cliente3 [cite: 4, 17]
            inverseJoinColumns = { @JoinColumn(name = "tb_contato3_id_contato") }) // FK para tb_contato3 [cite: 4, 18]
    private Set<Contato> contatos = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY,
            cascade = {
                    CascadeType.PERSIST,
                    CascadeType.MERGE
            })
    @JoinTable(name = "tb_clienteendereco3", // Tabela de junção [cite: 6]
            joinColumns = { @JoinColumn(name = "tb_cliente3_id_cliente") }, // FK para tb_cliente3 [cite: 6, 19]
            inverseJoinColumns = { @JoinColumn(name = "tb_endereco3_id_endereco") }) // FK para tb_endereco3 [cite: 6, 20]
    private Set<Endereco> enderecos = new HashSet<>();

    // Construtor padrão (exigido pela JPA)
    public Cliente() {
    }

    // Construtor para criar um novo cliente
    public Cliente(String nome, String sobrenome, String dataNascimento, String documento) {
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
        this.documento = documento;
    }

    // Getters e Setters
    public Long getIdCliente() {
        return idCliente;
    }

    public void setIdCliente(Long idCliente) {
        this.idCliente = idCliente;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getSobrenome() {
        return sobrenome;
    }

    public void setSobrenome(String sobrenome) {
        this.sobrenome = sobrenome;
    }

    public String getDataNascimento() {
        return dataNascimento;
    }

    public void setDataNascimento(String dataNascimento) {
        this.dataNascimento = dataNascimento;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public Set<Contato> getContatos() {
        return contatos;
    }

    public void setContatos(Set<Contato> contatos) {
        this.contatos = contatos;
    }

    public Set<Endereco> getEnderecos() {
        return enderecos;
    }

    public void setEnderecos(Set<Endereco> enderecos) {
        this.enderecos = enderecos;
    }

    // Métodos auxiliares para gerenciar relacionamentos (opcional, mas útil)
    public void addContato(Contato contato) {
        this.contatos.add(contato);
        // Se Contato tivesse uma referência de volta para Cliente, você adicionaria aqui:
        // contato.getClientesInternal().add(this);
    }

    public void removeContato(Contato contato) {
        this.contatos.remove(contato);
        // contato.getClientesInternal().remove(this);
    }

    public void addEndereco(Endereco endereco) {
        this.enderecos.add(endereco);
        // endereco.getClientesInternal().add(this);
    }

    public void removeEndereco(Endereco endereco) {
        this.enderecos.remove(endereco);
        // endereco.getClientesInternal().remove(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cliente cliente = (Cliente) o;
        return Objects.equals(idCliente, cliente.idCliente);
    }

    @Override
    public int hashCode() {
        return Objects.hash(idCliente);
    }

    @Override
    public String toString() {
        return "Cliente{" +
                "idCliente=" + idCliente +
                ", nome='" + nome + '\'' +
                ", sobrenome='" + sobrenome + '\'' +
                ", dataNascimento='" + dataNascimento + '\'' +
                ", documento='" + documento + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\model\Contato.java   |   package br.com.fiap.gs.gsapi.model   |   class Contato
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "tb_contato3")
public class Contato {

    @Id
    @SequenceGenerator(name = "contato_seq", sequenceName = "tb_contato3_id_contato_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "contato_seq")
    @Column(name = "id_contato")
    private Long idContato; // Mapeia para id_contato NUMBER NOT NULL [cite: 8]

    @Column(name = "ddd", nullable = false, length = 3)
    private String ddd; // Mapeia para ddd VARCHAR2(3) NOT NULL [cite: 8]

    @Column(name = "telefone", nullable = false, length = 15)
    private String telefone; // Mapeia para telefone VARCHAR2(15) NOT NULL [cite: 8]

    @Column(name = "celular", nullable = false, length = 15)
    private String celular; // Mapeia para celular VARCHAR2(15) NOT NULL [cite: 8]

    @Column(name = "whatsapp", nullable = false, length = 15)
    private String whatsapp; // Mapeia para whatsapp VARCHAR2(15) NOT NULL [cite: 8]

    @Column(name = "email", nullable = false, length = 255)
    private String email; // Mapeia para email VARCHAR2(255) NOT NULL [cite: 8]

    @Column(name = "tipo_contato", nullable = false, length = 50)
    private String tipoContato; // Mapeia para tipo_contato VARCHAR2(50) NOT NULL [cite: 8]

    @ManyToMany(mappedBy = "contatos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    // Construtor padrão
    public Contato() {
    }

    // Construtor para criar um novo contato
    public Contato(String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    // Getters e Setters
    public Long getIdContato() {
        return idContato;
    }

    public void setIdContato(Long idContato) {
        this.idContato = idContato;
    }

    public String getDdd() {
        return ddd;
    }

    public void setDdd(String ddd) {
        this.ddd = ddd;
    }

    public String getTelefone() {
        return telefone;
    }

    public void setTelefone(String telefone) {
        this.telefone = telefone;
    }

    public String getCelular() {
        return celular;
    }

    public void setCelular(String celular) {
        this.celular = celular;
    }

    public String getWhatsapp() {
        return whatsapp;
    }

    public void setWhatsapp(String whatsapp) {
        this.whatsapp = whatsapp;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getTipoContato() {
        return tipoContato;
    }

    public void setTipoContato(String tipoContato) {
        this.tipoContato = tipoContato;
    }

    public Set<Cliente> getClientes() {
        return clientes;
    }

    public void setClientes(Set<Cliente> clientes) {
        this.clientes = clientes;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Contato contato = (Contato) o;
        return Objects.equals(idContato, contato.idContato);
    }

    @Override
    public int hashCode() {
        return Objects.hash(idContato);
    }

    @Override
    public String toString() {
        return "Contato{" +
                "idContato=" + idContato +
                ", ddd='" + ddd + '\'' +
                ", telefone='" + telefone + '\'' +
                ", celular='" + celular + '\'' +
                ", whatsapp='" + whatsapp + '\'' +
                ", email='" + email + '\'' +
                ", tipoContato='" + tipoContato + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\model\Endereco.java   |   package br.com.fiap.gs.gsapi.model   |   class Endereco
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "tb_endereco3")
public class Endereco {

    @Id
    @SequenceGenerator(name = "endereco_seq", sequenceName = "tb_endereco3_id_endereco_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "endereco_seq")
    @Column(name = "id_endereco")
    private Long idEndereco;

    @Column(name = "cep", nullable = false, length = 9)
    private String cep;

    @Column(name = "numero", nullable = false)
    private Integer numero; // DDL: NUMBER(5)

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro;

    @Column(name = "bairro", nullable = false, length = 255)
    private String bairro;

    @Column(name = "localidade", nullable = false, length = 100)
    private String localidade;

    @Column(name = "uf", nullable = false, length = 2)
    private String uf;

    @Column(name = "complemento", nullable = false, length = 255)
    private String complemento;

    // CORREÇÃO APLICADA AQUI:
    @Column(name = "latitude", nullable = false, columnDefinition = "NUMBER(10,7)")
    private Double latitude;

    // CORREÇÃO APLICADA AQUI:
    @Column(name = "longitude", nullable = false, columnDefinition = "NUMBER(10,7)")
    private Double longitude;

    @ManyToMany(mappedBy = "enderecos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY,
            cascade = {
                    CascadeType.PERSIST,
                    CascadeType.MERGE
            })
    @JoinTable(name = "tb_enderecoeventos3",
            joinColumns = { @JoinColumn(name = "tb_endereco3_id_endereco") },
            inverseJoinColumns = { @JoinColumn(name = "tb_eonet3_id_eonet") })
    private Set<Eonet> eventosEonet = new HashSet<>();

    // Construtor padrão
    public Endereco() {
    }

    // Construtor para criar um novo endereço
    public Endereco(String cep, Integer numero, String logradouro, String bairro, String localidade, String uf, String complemento, Double latitude, Double longitude) {
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    // Getters e Setters
    public Long getIdEndereco() {
        return idEndereco;
    }

    public void setIdEndereco(Long idEndereco) {
        this.idEndereco = idEndereco;
    }

    public String getCep() {
        return cep;
    }

    public void setCep(String cep) {
        this.cep = cep;
    }

    public Integer getNumero() {
        return numero;
    }

    public void setNumero(Integer numero) {
        this.numero = numero;
    }

    public String getLogradouro() {
        return logradouro;
    }

    public void setLogradouro(String logradouro) {
        this.logradouro = logradouro;
    }

    public String getBairro() {
        return bairro;
    }

    public void setBairro(String bairro) {
        this.bairro = bairro;
    }

    public String getLocalidade() {
        return localidade;
    }

    public void setLocalidade(String localidade) {
        this.localidade = localidade;
    }

    public String getUf() {
        return uf;
    }

    public void setUf(String uf) {
        this.uf = uf;
    }

    public String getComplemento() {
        return complemento;
    }

    public void setComplemento(String complemento) {
        this.complemento = complemento;
    }

    public Double getLatitude() {
        return latitude;
    }

    public void setLatitude(Double latitude) {
        this.latitude = latitude;
    }

    public Double getLongitude() {
        return longitude;
    }

    public void setLongitude(Double longitude) {
        this.longitude = longitude;
    }

    public Set<Cliente> getClientes() {
        return clientes;
    }

    public void setClientes(Set<Cliente> clientes) {
        this.clientes = clientes;
    }

    public Set<Eonet> getEventosEonet() {
        return eventosEonet;
    }

    public void setEventosEonet(Set<Eonet> eventosEonet) {
        this.eventosEonet = eventosEonet;
    }

    public void addEventoEonet(Eonet evento) {
        this.eventosEonet.add(evento);
    }

    public void removeEventoEonet(Eonet evento) {
        this.eventosEonet.remove(evento);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Endereco endereco = (Endereco) o;
        return Objects.equals(idEndereco, endereco.idEndereco);
    }

    @Override
    public int hashCode() {
        return Objects.hash(idEndereco);
    }

    @Override
    public String toString() {
        return "Endereco{" +
                "idEndereco=" + idEndereco +
                ", cep='" + cep + '\'' +
                ", numero=" + numero +
                ", logradouro='" + logradouro + '\'' +
                ", bairro='" + bairro + '\'' +
                ", localidade='" + localidade + '\'' +
                ", uf='" + uf + '\'' +
                ", complemento='" + complemento + '\'' +
                ", latitude=" + latitude +
                ", longitude=" + longitude +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\model\Eonet.java   |   package br.com.fiap.gs.gsapi.model   |   class Eonet
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Lob;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import java.time.OffsetDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "tb_eonet3")
public class Eonet {

    @Id
    @SequenceGenerator(name = "eonet_seq", sequenceName = "tb_eonet3_id_eonet_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "eonet_seq")
    @Column(name = "id_eonet")
    private Long idEonet; // Mapeia para id_eonet NUMBER NOT NULL [cite: 15]

    @Lob // Indica que é um Large Object (CLOB neste caso)
    @Column(name = "json", columnDefinition = "CLOB") // Mapeia para json CLOB NULL [cite: 15]
    private String json;

    @Column(name = "data") // Mapeia para data TIMESTAMP WITH LOCAL TIME ZONE NULL [cite: 15]
    private OffsetDateTime data;

    @Column(name = "eonet_id", nullable = false, length = 50)
    private String eonetIdApi; // Mapeia para eonet_id VARCHAR2(50) NOT NULL [cite: 15]

    @ManyToMany(mappedBy = "eventosEonet", fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>();

    // Construtor padrão
    public Eonet() {
    }

    // Construtor para criar um novo evento EONET
    public Eonet(String json, OffsetDateTime data, String eonetIdApi) {
        this.json = json;
        this.data = data;
        this.eonetIdApi = eonetIdApi;
    }

    // Outro construtor, caso json e data sejam opcionais na criação inicial
    public Eonet(String eonetIdApi) {
        this.eonetIdApi = eonetIdApi;
    }

    // Getters e Setters
    public Long getIdEonet() {
        return idEonet;
    }

    public void setIdEonet(Long idEonet) {
        this.idEonet = idEonet;
    }

    public String getJson() {
        return json;
    }

    public void setJson(String json) {
        this.json = json;
    }

    public OffsetDateTime getData() {
        return data;
    }

    public void setData(OffsetDateTime data) {
        this.data = data;
    }

    public String getEonetIdApi() {
        return eonetIdApi;
    }

    public void setEonetIdApi(String eonetIdApi) {
        this.eonetIdApi = eonetIdApi;
    }

    public Set<Endereco> getEnderecos() {
        return enderecos;
    }

    public void setEnderecos(Set<Endereco> enderecos) {
        this.enderecos = enderecos;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Eonet eonet = (Eonet) o;
        return Objects.equals(idEonet, eonet.idEonet);
    }

    @Override
    public int hashCode() {
        return Objects.hash(idEonet);
    }

    @Override
    public String toString() {
        return "Eonet{" +
                "idEonet=" + idEonet +
                ", json='" + (json != null && json.length() > 50 ? json.substring(0, 50) + "..." : json) + '\'' +
                ", data=" + data +
                ", eonetIdApi='" + eonetIdApi + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class ClienteRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Cliente;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long> {

    /**
     * Busca um cliente pelo seu documento (CPF/CNPJ).
     * @param documento O número do documento.
     * @return Um Optional contendo o cliente se encontrado, ou vazio caso contrário.
     */
    Optional<Cliente> findByDocumento(String documento);

    /**
     * Busca clientes cujo nome contenha a string fornecida, ignorando maiúsculas/minúsculas,
     * com suporte a paginação.
     * @param nome Parte do nome a ser buscado.
     * @param pageable Objeto de paginação.
     * @return Uma página de clientes que correspondem ao critério.
     */
    Page<Cliente> findByNomeContainingIgnoreCase(String nome, Pageable pageable);

    /**
     * Exemplo de busca customizada usando JPQL para encontrar clientes
     * por parte do nome ou sobrenome, ignorando maiúsculas/minúsculas, com paginação.
     * @param termo O termo a ser buscado no nome ou sobrenome.
     * @param pageable Objeto de paginação.
     * @return Uma página de clientes que correspondem ao critério.
     */
    @Query("SELECT c FROM Cliente c WHERE lower(c.nome) LIKE lower(concat('%', :termo, '%')) OR lower(c.sobrenome) LIKE lower(concat('%', :termo, '%'))")
    Page<Cliente> searchByNomeOrSobrenome(@Param("termo") String termo, Pageable pageable);

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class ContatoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Contato;
import org.springframework.data.domain.Page; // Import necessário
import org.springframework.data.domain.Pageable; // Import necessário
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ContatoRepository extends JpaRepository<Contato, Long> {

    /**
     * Busca um contato pelo seu endereço de e-mail.
     * @param email O e-mail a ser buscado.
     * @return Um Optional contendo o contato se encontrado.
     */
    Optional<Contato> findByEmail(String email);

    /**
     * Busca contatos por tipo, ignorando maiúsculas/minúsculas. (Versão que retorna Lista)
     * @param tipoContato O tipo de contato (ex: "COMERCIAL", "PESSOAL").
     * @return Uma lista de contatos que correspondem ao tipo.
     */
    List<Contato> findByTipoContatoIgnoreCase(String tipoContato); // Método original que retorna List

    /**
     * Busca contatos por tipo, ignorando maiúsculas/minúsculas, com suporte a paginação.
     * @param tipoContato O tipo de contato (ex: "COMERCIAL", "PESSOAL").
     * @param pageable Objeto de paginação.
     * @return Uma página de contatos que correspondem ao tipo.
     */
    Page<Contato> findByTipoContatoIgnoreCase(String tipoContato, Pageable pageable); // Novo método com Pageable
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class EnderecoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Endereco;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface EnderecoRepository extends JpaRepository<Endereco, Long> {

    /**
     * Busca endereços por CEP.
     * @param cep O CEP a ser buscado.
     * @return Uma lista de endereços que correspondem ao CEP.
     */
    List<Endereco> findByCep(String cep);

    /**
     * Busca um endereço específico pela combinação de logradouro e número.
     * @param logradouro O logradouro do endereço.
     * @param numero O número do endereço.
     * @return Um Optional contendo o endereço se encontrado.
     */
    Optional<Endereco> findByLogradouroAndNumero(String logradouro, Integer numero);

    /**
     * Busca endereços por UF (Estado), com suporte a paginação.
     * @param uf A sigla do Estado (UF).
     * @param pageable Objeto de paginação.
     * @return Uma página de endereços que correspondem à UF.
     */
    Page<Endereco> findByUfIgnoreCase(String uf, Pageable pageable);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\repository\EonetRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class EonetRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Arquivo: src/main/java/br/com/fiap/gs/gsapi/repository/EonetRepository.java
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Eonet;
import org.springframework.data.jpa.repository.JpaRepository;
// Não são necessárias importações de DTOs de stats aqui se as queries que os usavam foram removidas
// import org.springframework.data.jpa.repository.Query;
// import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface EonetRepository extends JpaRepository<Eonet, Long> {

    Optional<Eonet> findByEonetIdApi(String eonetIdApi);

    List<Eonet> findByDataBetween(OffsetDateTime dataInicial, OffsetDateTime dataFinal);

    // Os métodos countEventsByYearMonthRaw e findEventCountsByYearRaw foram removidos.
    // Se você tinha as versões com TO_CHAR e SELECT NEW, elas também foram removidas.
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\service\ClienteService.java   |   package br.com.fiap.gs.gsapi.service   |   class ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.ClienteMapper;
// Não precisamos mais de ContatoMapper e EnderecoMapper injetados aqui para lógica de aninhados
// import br.com.fiap.gs.gsapi.mapper.ContatoMapper;
// import br.com.fiap.gs.gsapi.mapper.EnderecoMapper;
import br.com.fiap.gs.gsapi.model.Cliente;
import br.com.fiap.gs.gsapi.model.Contato;
import br.com.fiap.gs.gsapi.model.Endereco;
import br.com.fiap.gs.gsapi.repository.ClienteRepository;
import br.com.fiap.gs.gsapi.repository.ContatoRepository;
import br.com.fiap.gs.gsapi.repository.EnderecoRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class ClienteService {

    private final ClienteRepository clienteRepository;
    private final ContatoRepository contatoRepository;
    private final EnderecoRepository enderecoRepository;
    private final ClienteMapper clienteMapper;

    @Autowired
    public ClienteService(ClienteRepository clienteRepository,
                          ContatoRepository contatoRepository,
                          EnderecoRepository enderecoRepository,
                          ClienteMapper clienteMapper) {
        this.clienteRepository = clienteRepository;
        this.contatoRepository = contatoRepository;
        this.enderecoRepository = enderecoRepository;
        this.clienteMapper = clienteMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "clientes", key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<ClienteResponseDTO> listarTodos(Pageable pageable) {
        Page<Cliente> clientesPage = clienteRepository.findAll(pageable);
        return clientesPage.map(clienteMapper::toResponseDTO);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "clienteById", key = "#id")
    public ClienteResponseDTO buscarPorId(Long id) {
        Cliente cliente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com o ID: " + id));
        return clienteMapper.toResponseDTO(cliente);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "clienteByDocumento", key = "#documento")
    public ClienteResponseDTO buscarPorDocumento(String documento) {
        Cliente cliente = clienteRepository.findByDocumento(documento)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com o documento: " + documento));
        return clienteMapper.toResponseDTO(cliente);
    }

    @Transactional
    @CacheEvict(value = {"clientes", "clienteById", "clienteByDocumento", "clientesSearch"}, allEntries = true)
    public ClienteResponseDTO criarCliente(ClienteRequestDTO clienteRequestDTO) {
        if (clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).isPresent()) {
            throw new IllegalArgumentException("Já existe um cliente cadastrado com o documento: " + clienteRequestDTO.getDocumento());
        }

        Cliente cliente = clienteMapper.toEntity(clienteRequestDTO);

        if (clienteRequestDTO.getContatosIds() != null && !clienteRequestDTO.getContatosIds().isEmpty()) {
            Set<Contato> contatos = new HashSet<>(contatoRepository.findAllById(clienteRequestDTO.getContatosIds()));
            if (contatos.size() != clienteRequestDTO.getContatosIds().size()) {
                Set<Long> foundIds = contatos.stream().map(Contato::getIdContato).collect(Collectors.toSet());
                Set<Long> notFoundIds = clienteRequestDTO.getContatosIds().stream()
                        .filter(id -> !foundIds.contains(id))
                        .collect(Collectors.toSet());
                throw new ResourceNotFoundException("Um ou mais IDs de Contato não foram encontrados: " + notFoundIds);
            }
            cliente.setContatos(contatos);
        } else {
            cliente.setContatos(new HashSet<>());
        }

        if (clienteRequestDTO.getEnderecosIds() != null && !clienteRequestDTO.getEnderecosIds().isEmpty()) {
            Set<Endereco> enderecos = new HashSet<>(enderecoRepository.findAllById(clienteRequestDTO.getEnderecosIds()));
            if (enderecos.size() != clienteRequestDTO.getEnderecosIds().size()) {
                Set<Long> foundIds = enderecos.stream().map(Endereco::getIdEndereco).collect(Collectors.toSet());
                Set<Long> notFoundIds = clienteRequestDTO.getEnderecosIds().stream()
                        .filter(id -> !foundIds.contains(id))
                        .collect(Collectors.toSet());
                throw new ResourceNotFoundException("Um ou mais IDs de Endereço não foram encontrados: " + notFoundIds);
            }
            cliente.setEnderecos(enderecos);
        } else {
            cliente.setEnderecos(new HashSet<>());
        }

        Cliente clienteSalvo = clienteRepository.save(cliente);
        return clienteMapper.toResponseDTO(clienteSalvo);
    }

    @Transactional
    @CachePut(value = "clienteById", key = "#id")
    @CacheEvict(value = {"clientes", "clienteByDocumento", "clientesSearch"}, allEntries = true)
    public ClienteResponseDTO atualizarCliente(Long id, ClienteRequestDTO clienteRequestDTO) {
        Cliente clienteExistente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com o ID: " + id));

        if (!clienteExistente.getDocumento().equals(clienteRequestDTO.getDocumento()) &&
                clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).filter(c -> !c.getIdCliente().equals(id)).isPresent()) {
            throw new IllegalArgumentException("Já existe outro cliente cadastrado com o documento: " + clienteRequestDTO.getDocumento());
        }

        clienteMapper.updateClienteFromDto(clienteRequestDTO, clienteExistente);

        if (clienteRequestDTO.getContatosIds() != null) {
            if (clienteRequestDTO.getContatosIds().isEmpty()){
                clienteExistente.getContatos().clear();
            } else {
                Set<Contato> contatos = new HashSet<>(contatoRepository.findAllById(clienteRequestDTO.getContatosIds()));
                if (contatos.size() != clienteRequestDTO.getContatosIds().size()) {
                    Set<Long> foundIds = contatos.stream().map(Contato::getIdContato).collect(Collectors.toSet());
                    Set<Long> notFoundIds = clienteRequestDTO.getContatosIds().stream()
                            .filter(contactId -> !foundIds.contains(contactId))
                            .collect(Collectors.toSet());
                    throw new ResourceNotFoundException("Um ou mais IDs de Contato fornecidos para atualização não foram encontrados: " + notFoundIds);
                }
                clienteExistente.setContatos(contatos);
            }
        } else { // Se contatosIds for nulo, não altera os contatos existentes (ou pode optar por limpar, dependendo da regra)
            // clienteExistente.getContatos().clear(); // Descomente se nulo deve limpar
        }


        if (clienteRequestDTO.getEnderecosIds() != null) {
            if (clienteRequestDTO.getEnderecosIds().isEmpty()){
                clienteExistente.getEnderecos().clear();
            } else {
                Set<Endereco> enderecos = new HashSet<>(enderecoRepository.findAllById(clienteRequestDTO.getEnderecosIds()));
                if (enderecos.size() != clienteRequestDTO.getEnderecosIds().size()) {
                    Set<Long> foundIds = enderecos.stream().map(Endereco::getIdEndereco).collect(Collectors.toSet());
                    Set<Long> notFoundIds = clienteRequestDTO.getEnderecosIds().stream()
                            .filter(addressId -> !foundIds.contains(addressId))
                            .collect(Collectors.toSet());
                    throw new ResourceNotFoundException("Um ou mais IDs de Endereço fornecidos para atualização não foram encontrados: " + notFoundIds);
                }
                clienteExistente.setEnderecos(enderecos);
            }
        } else { // Se enderecosIds for nulo, não altera os endereços existentes
            // clienteExistente.getEnderecos().clear(); // Descomente se nulo deve limpar
        }

        Cliente clienteAtualizado = clienteRepository.save(clienteExistente);
        return clienteMapper.toResponseDTO(clienteAtualizado);
    }

    @Transactional
    @CacheEvict(value = {"clientes", "clienteById", "clienteByDocumento", "clientesSearch"}, allEntries = true)
    public void deletarCliente(Long id) {
        if (!clienteRepository.existsById(id)) {
            throw new ResourceNotFoundException("Cliente não encontrado com o ID: " + id);
        }
        clienteRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "clientesSearch", key = "#termo + '-' + #pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<ClienteResponseDTO> pesquisarClientes(String termo, Pageable pageable) {
        Page<Cliente> clientesPage = clienteRepository.searchByNomeOrSobrenome(termo, pageable);
        return clientesPage.map(clienteMapper::toResponseDTO);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\service\ContatoService.java   |   package br.com.fiap.gs.gsapi.service   |   class ContatoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.ContatoMapper;
import br.com.fiap.gs.gsapi.model.Contato;
import br.com.fiap.gs.gsapi.repository.ContatoRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class ContatoService {

    private final ContatoRepository contatoRepository;
    private final ContatoMapper contatoMapper; // Mapper injetado

    @Autowired
    public ContatoService(ContatoRepository contatoRepository, ContatoMapper contatoMapper) { // Construtor
        this.contatoRepository = contatoRepository;
        this.contatoMapper = contatoMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatos", key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<ContatoResponseDTO> listarTodos(Pageable pageable) {
        Page<Contato> contatosPage = contatoRepository.findAll(pageable);
        return contatosPage.map(contatoMapper::toResponseDTO); // Usando o mapper
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatoById", key = "#id")
    public ContatoResponseDTO buscarPorId(Long id) {
        Contato contato = contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com o ID: " + id));
        return contatoMapper.toResponseDTO(contato); // Usando o mapper
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatoByEmail", key = "#email")
    public ContatoResponseDTO buscarPorEmail(String email) {
        Contato contato = contatoRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com o e-mail: " + email));
        return contatoMapper.toResponseDTO(contato);
    }

    @Transactional
    @CacheEvict(value = {"contatos", "contatoById", "contatoByEmail"}, allEntries = true)
    public ContatoResponseDTO criarContato(ContatoRequestDTO contatoRequestDTO) {
        // Validação de e-mail duplicado (exemplo de regra de negócio)
        if (contatoRepository.findByEmail(contatoRequestDTO.getEmail()).isPresent()) {
            throw new IllegalArgumentException("Já existe um contato cadastrado com o e-mail: " + contatoRequestDTO.getEmail());
        }

        Contato contato = contatoMapper.toEntity(contatoRequestDTO); // Usando o mapper
        // A associação com Cliente é feita através do ClienteService ou por endpoints específicos
        // de associação, não diretamente aqui na criação isolada de um contato.
        Contato contatoSalvo = contatoRepository.save(contato);
        return contatoMapper.toResponseDTO(contatoSalvo); // Usando o mapper
    }

    @Transactional
    @CachePut(value = "contatoById", key = "#id")
    @CacheEvict(value = {"contatos", "contatoByEmail"}, allEntries = true)
    public ContatoResponseDTO atualizarContato(Long id, ContatoRequestDTO contatoRequestDTO) {
        Contato contatoExistente = contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com o ID: " + id));

        // Validação para não alterar o e-mail para um já existente em outro contato
        if (!contatoExistente.getEmail().equalsIgnoreCase(contatoRequestDTO.getEmail()) &&
                contatoRepository.findByEmail(contatoRequestDTO.getEmail()).isPresent()) {
            throw new IllegalArgumentException("Já existe outro contato cadastrado com o e-mail: " + contatoRequestDTO.getEmail());
        }

        // Atualiza os campos da entidade existente
        // Poderia usar MapStruct com @MappingTarget: contatoMapper.updateEntityFromDto(contatoRequestDTO, contatoExistente);
        contatoExistente.setDdd(contatoRequestDTO.getDdd());
        contatoExistente.setTelefone(contatoRequestDTO.getTelefone());
        contatoExistente.setCelular(contatoRequestDTO.getCelular());
        contatoExistente.setWhatsapp(contatoRequestDTO.getWhatsapp());
        contatoExistente.setEmail(contatoRequestDTO.getEmail());
        contatoExistente.setTipoContato(contatoRequestDTO.getTipoContato());

        Contato contatoAtualizado = contatoRepository.save(contatoExistente);
        return contatoMapper.toResponseDTO(contatoAtualizado); // Usando o mapper
    }

    @Transactional
    @CacheEvict(value = {"contatos", "contatoById", "contatoByEmail"}, allEntries = true)
    public void deletarContato(Long id) {
        Contato contato = contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com o ID: " + id));

        // Antes de deletar, é importante considerar as associações com Cliente.
        // A exclusão de um Contato aqui removerá o registro da tb_contato3. [cite: 8]
        // As entradas na tabela de junção tb_clientecontato3 [cite: 4] que referenciam este contato
        // também devem ser removidas. O provedor JPA (Hibernate) geralmente cuida disso
        // se o relacionamento ManyToMany for corretamente configurado (especialmente do lado do Cliente).
        // Se um contato for deletado, os Clientes associados não serão deletados, apenas a associação será desfeita.
        if (!contato.getClientes().isEmpty()) {
            // Poderia lançar uma exceção se a regra de negócio impedir deletar contato associado,
            // ou desassociar programaticamente (embora a JPA deva cuidar disso ao remover da coleção em Cliente ou pela FK).
            // Ex: throw new IllegalStateException("Não é possível deletar contato pois está associado a clientes.");
            // Ou, limpar as associações nos clientes se necessário (geralmente não é feito aqui).
        }
        contatoRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatosPorTipo", key = "#tipoContato + '-' + #pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<ContatoResponseDTO> buscarPorTipoContato(String tipoContato, Pageable pageable) {
        // Supondo que você crie um método no ContatoRepository:
        // Page<Contato> findByTipoContatoIgnoreCase(String tipoContato, Pageable pageable);
        // Se não, pode ser List<Contato> e você faz a paginação manualmente (menos ideal)
        // ou ajusta o repositório.
        // Por ora, vou usar o método que retorna List e adaptar, ou sugerir a criação do método paginável.
        // Para este exemplo, vou assumir que você adicionará o método paginável ao repositório:
        // Page<Contato> contatosPage = contatoRepository.findByTipoContatoIgnoreCase(tipoContato, pageable);
        // return contatosPage.map(contatoMapper::toResponseDTO);

        // Se o método no repositório for List<Contato> findByTipoContatoIgnoreCase(String tipoContato);
        List<ContatoResponseDTO> listaContatos = contatoRepository.findByTipoContatoIgnoreCase(tipoContato)
                .stream()
                .map(contatoMapper::toResponseDTO)
                .collect(Collectors.toList());
        // A conversão para Page aqui seria manual e mais complexa. É melhor ter o método paginado no repositório.
        // Se você adicionar Page<Contato> findByTipoContatoIgnoreCase(String tipoContato, Pageable pageable)
        // no ContatoRepository, o código acima (comentado) é o ideal.
        // Por enquanto, vou deixar como está, mas recomendo o ajuste no repositório para paginação correta.

        // Para fins de exemplo e para não falhar, se o método no repo for List:
        // Este retorno não é paginado, mas demonstra a busca.
        // return new PageImpl<>(listaContatos, pageable, listaContatos.size());
        // O ideal é:
        // Page<Contato> page = contatoRepository.findByTipoContatoIgnoreCase(tipoContato, pageable);
        // return page.map(contatoMapper::toResponseDTO);
        // Para isso, o ContatoRepository precisaria de:
        // Page<Contato> findByTipoContatoIgnoreCase(String tipoContato, Pageable pageable);
        // Vou assumir que você adicionará esse método ao ContatoRepository.
        // Se não for adicionado, este método do serviço precisará de ajustes ou não suportará paginação corretamente.
        // throw new UnsupportedOperationException("Paginable findByTipoContatoIgnoreCase não implementado no repositório.");

        // Assumindo que ContatoRepository.findByTipoContatoIgnoreCase(tipoContato, pageable) existe:
        Page<Contato> contatosPage = contatoRepository.findByTipoContatoIgnoreCase(tipoContato, pageable); // Supondo que este método foi adicionado ao ContatoRepository
        return contatosPage.map(contatoMapper::toResponseDTO);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\service\EnderecoService.java   |   package br.com.fiap.gs.gsapi.service   |   class EnderecoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.client.GeoCodingClient;
import br.com.fiap.gs.gsapi.client.ViaCepClient;
import br.com.fiap.gs.gsapi.dto.external.GoogleGeocodingApiResponseDTO;
import br.com.fiap.gs.gsapi.dto.external.GoogleGeocodingResultDTO;
import br.com.fiap.gs.gsapi.dto.response.ViaCepResponseDTO;
import br.com.fiap.gs.gsapi.dto.request.EnderecoGeoRequestDTO;
import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.dto.response.GeoCoordinatesDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.exception.ServiceUnavailableException;
import br.com.fiap.gs.gsapi.mapper.EnderecoMapper;
import br.com.fiap.gs.gsapi.model.Endereco;
import br.com.fiap.gs.gsapi.repository.EnderecoRepository;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;
// Removido import java.util.Map; pois UF_PARA_NOME_ESTADO não é mais usado com Google

@Service
public class EnderecoService {

    private static final Logger logger = LoggerFactory.getLogger(EnderecoService.class);

    private final EnderecoRepository enderecoRepository;
    private final EnderecoMapper enderecoMapper;
    private final ViaCepClient viaCepClient;
    private final GeoCodingClient geoCodingClient;

    @Autowired
    public EnderecoService(EnderecoRepository enderecoRepository,
                           EnderecoMapper enderecoMapper,
                           ViaCepClient viaCepClient,
                           GeoCodingClient geoCodingClient) {
        this.enderecoRepository = enderecoRepository;
        this.enderecoMapper = enderecoMapper;
        this.viaCepClient = viaCepClient;
        this.geoCodingClient = geoCodingClient;
    }

    // ... (métodos listarTodos, buscarPorId, criarEndereco, atualizarEndereco, deletarEndereco, formatarCep, consultarDadosPorCep permanecem os mesmos) ...
    // Cole-os da sua versão funcional anterior ou da minha última resposta completa para EnderecoService.
    @Transactional(readOnly = true)
    @Cacheable(value = "enderecos", key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<EnderecoResponseDTO> listarTodos(Pageable pageable) {
        Page<Endereco> enderecosPage = enderecoRepository.findAll(pageable);
        return enderecosPage.map(enderecoMapper::toResponseDTO);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "enderecoById", key = "#id")
    public EnderecoResponseDTO buscarPorId(Long id) {
        Endereco endereco = enderecoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Endereço não encontrado com o ID: " + id));
        return enderecoMapper.toResponseDTO(endereco);
    }

    @Transactional
    @CacheEvict(value = {"enderecos", "enderecoById", "enderecosPorCep"}, allEntries = true)
    public EnderecoResponseDTO criarEndereco(EnderecoRequestDTO enderecoRequestDTO) {
        Endereco endereco = enderecoMapper.toEntity(enderecoRequestDTO);
        endereco.setCep(formatarCep(endereco.getCep()));
        if (endereco.getUf() != null) {
            endereco.setUf(endereco.getUf().toUpperCase());
        }
        if (enderecoRequestDTO.getLatitude() == null || enderecoRequestDTO.getLongitude() == null || enderecoRequestDTO.getLatitude() == 0 || enderecoRequestDTO.getLongitude() == 0) {
            throw new IllegalArgumentException("Latitude e Longitude são obrigatórias e devem ser válidas para criar um endereço.");
        }
        Endereco enderecoSalvo = enderecoRepository.save(endereco);
        return enderecoMapper.toResponseDTO(enderecoSalvo);
    }

    @Transactional
    @CachePut(value = "enderecoById", key = "#id")
    @CacheEvict(value = {"enderecos", "enderecosPorCep"}, allEntries = true)
    public EnderecoResponseDTO atualizarEndereco(Long id, EnderecoRequestDTO enderecoRequestDTO) {
        Endereco enderecoExistente = enderecoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Endereço não encontrado com o ID: " + id));
        enderecoExistente.setCep(formatarCep(enderecoRequestDTO.getCep()));
        enderecoExistente.setNumero(enderecoRequestDTO.getNumero());
        enderecoExistente.setLogradouro(enderecoRequestDTO.getLogradouro());
        enderecoExistente.setBairro(enderecoRequestDTO.getBairro());
        enderecoExistente.setLocalidade(enderecoRequestDTO.getLocalidade());
        if (enderecoRequestDTO.getUf() != null) {
            enderecoExistente.setUf(enderecoRequestDTO.getUf().toUpperCase());
        }
        enderecoExistente.setComplemento(enderecoRequestDTO.getComplemento());
        if (enderecoRequestDTO.getLatitude() == null || enderecoRequestDTO.getLongitude() == null || enderecoRequestDTO.getLatitude() == 0 || enderecoRequestDTO.getLongitude() == 0) {
            throw new IllegalArgumentException("Latitude e Longitude são obrigatórias e devem ser válidas para atualizar um endereço.");
        }
        enderecoExistente.setLatitude(enderecoRequestDTO.getLatitude());
        enderecoExistente.setLongitude(enderecoRequestDTO.getLongitude());
        Endereco enderecoAtualizado = enderecoRepository.save(enderecoExistente);
        return enderecoMapper.toResponseDTO(enderecoAtualizado);
    }

    @Transactional
    @CacheEvict(value = {"enderecos", "enderecoById", "enderecosPorCep"}, allEntries = true)
    public void deletarEndereco(Long id) {
        if (!enderecoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Endereço não encontrado com o ID: " + id);
        }
        enderecoRepository.deleteById(id);
    }

    private String formatarCep(String cep) {
        if (cep != null) {
            return cep.replaceAll("[^0-9]", "");
        }
        return null;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "viacepConsulta", key = "#cep")
    public ViaCepResponseDTO consultarDadosPorCep(String cep) {
        String cepFormatado = formatarCep(cep);
        if (cepFormatado == null || cepFormatado.length() != 8) {
            throw new IllegalArgumentException("Formato de CEP inválido. Use 8 dígitos numéricos.");
        }
        ViaCepResponseDTO viaCepData = viaCepClient.buscarEnderecoPorCep(cepFormatado);
        if (viaCepData == null || viaCepData.isErro()) {
            throw new ResourceNotFoundException("CEP " + cepFormatado + " não encontrado ou inválido.");
        }
        return viaCepData;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "geoCoordenadasGoogle", key = "#enderecoGeoRequestDTO.toString()")
    public GeoCoordinatesDTO calcularCoordenadasPorEndereco(EnderecoGeoRequestDTO enderecoGeoRequestDTO) {
        // Construir a string de endereço para a API do Google de forma mais simples
        StringBuilder addressBuilder = new StringBuilder();
        if (StringUtils.hasText(enderecoGeoRequestDTO.getLogradouro())) {
            addressBuilder.append(enderecoGeoRequestDTO.getLogradouro());
        }
        if (StringUtils.hasText(enderecoGeoRequestDTO.getNumero())) {
            addressBuilder.append(", ").append(enderecoGeoRequestDTO.getNumero());
        }
        // Bairro pode ou não ajudar, às vezes é melhor omitir para Google se logradouro é preciso
        // if (StringUtils.hasText(enderecoGeoRequestDTO.getBairro())) {
        //     addressBuilder.append(", ").append(enderecoGeoRequestDTO.getBairro());
        // }
        if (StringUtils.hasText(enderecoGeoRequestDTO.getCidade())) {
            addressBuilder.append(", ").append(enderecoGeoRequestDTO.getCidade());
        }
        if (StringUtils.hasText(enderecoGeoRequestDTO.getUf())) {
            addressBuilder.append(" - ").append(enderecoGeoRequestDTO.getUf());
        }
        // CEP pode ser usado no components ou na query principal.
        // if (StringUtils.hasText(enderecoGeoRequestDTO.getCep())) {
        //     addressBuilder.append(", ").append(formatarCep(enderecoGeoRequestDTO.getCep()));
        // }
        // Adicionar país é uma boa prática para desambiguação, mas o 'components' já faz isso.
        // addressBuilder.append(", Brasil");

        String addressQuery = addressBuilder.toString().replaceFirst("^, ", "").trim();

        if (!StringUtils.hasText(addressQuery) || !StringUtils.hasText(enderecoGeoRequestDTO.getCidade()) || !StringUtils.hasText(enderecoGeoRequestDTO.getUf())) {
            throw new IllegalArgumentException("Dados de endereço insuficientes para geocodificação (requer pelo menos logradouro/número, cidade e UF, ou cidade e UF).");
        }

        String components = "country:BR";
        if (StringUtils.hasText(enderecoGeoRequestDTO.getCep())) {
            components += "|postal_code:" + formatarCep(enderecoGeoRequestDTO.getCep());
        }
        // Você pode também adicionar 'administrative_area' para o estado e 'locality' para a cidade aqui
        // if (StringUtils.hasText(enderecoGeoRequestDTO.getUf())) {
        //    components += "|administrative_area:" + enderecoGeoRequestDTO.getUf();
        // }
        // if (StringUtils.hasText(enderecoGeoRequestDTO.getCidade())) {
        //    components += "|locality:" + enderecoGeoRequestDTO.getCidade();
        // }

        logger.info("Iniciando geocodificação com Google para endereço: '{}', componentes: '{}'", addressQuery, components);
        GoogleGeocodingApiResponseDTO googleResponse = geoCodingClient.buscarCoordenadasPorEnderecoGoogle(addressQuery, components, "pt-BR");

        if (googleResponse == null || !"OK".equals(googleResponse.getStatus()) || googleResponse.getResults() == null || googleResponse.getResults().isEmpty()) {
            String status = googleResponse != null ? googleResponse.getStatus() : "Resposta Nula da API";
            String errorMessage = googleResponse != null ? googleResponse.getErrorMessage() : "Nenhuma informação de erro detalhada.";
            logger.warn("Google Geocoding API não retornou resultados válidos para o endereço '{}'. Status: {}. Mensagem: {}", addressQuery, status, errorMessage);

            // Tentar uma query ainda mais simples (apenas cidade, estado, país) se a primeira falhou com ZERO_RESULTS
            if ("ZERO_RESULTS".equals(status) && StringUtils.hasText(enderecoGeoRequestDTO.getCidade()) && StringUtils.hasText(enderecoGeoRequestDTO.getUf())) {
                String simplerAddressQuery = String.join(", ", enderecoGeoRequestDTO.getCidade(), enderecoGeoRequestDTO.getUf(), "Brasil");
                String simplerComponents = "country:BR"; // Mantém a restrição de país
                logger.info("Tentando fallback com query mais simples para Google: '{}', componentes: '{}'", simplerAddressQuery, simplerComponents);
                googleResponse = geoCodingClient.buscarCoordenadasPorEnderecoGoogle(simplerAddressQuery, simplerComponents, "pt-BR");

                if (googleResponse == null || !"OK".equals(googleResponse.getStatus()) || googleResponse.getResults() == null || googleResponse.getResults().isEmpty()) {
                    status = googleResponse != null ? googleResponse.getStatus() : "Resposta Nula da API (fallback)";
                    errorMessage = googleResponse != null ? googleResponse.getErrorMessage() : "Nenhuma informação de erro detalhada (fallback).";
                    logger.warn("Fallback da Google Geocoding API também falhou. Status: {}. Mensagem: {}", status, errorMessage);
                    throw new ResourceNotFoundException("Não foi possível encontrar coordenadas para o endereço fornecido via Google. Status da API: " + status);
                }
            } else {
                throw new ResourceNotFoundException("Não foi possível encontrar coordenadas para o endereço fornecido via Google. Status da API: " + status);
            }
        }

        GoogleGeocodingResultDTO bestResult = googleResponse.getResults().get(0);

        if (bestResult.getGeometry() == null || bestResult.getGeometry().getLocation() == null) {
            logger.warn("Resultado do Google Geocoding API sem geometria ou localização para o endereço '{}'.", addressQuery);
            throw new ResourceNotFoundException("Resultado da geocodificação do Google inválido (sem geometria/localização).");
        }

        double latitude = bestResult.getGeometry().getLocation().getLatitude();
        double longitude = bestResult.getGeometry().getLocation().getLongitude();
        String formattedAddress = bestResult.getFormattedAddress();

        logger.info("Coordenadas encontradas via Google para query '{}': Lat={}, Lon={}, Endereço Formatado='{}'",
                addressQuery, latitude, longitude, formattedAddress);
        return new GeoCoordinatesDTO(latitude, longitude, formattedAddress);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\service\EonetService.java   |   package br.com.fiap.gs.gsapi.service   |   class EonetService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Arquivo: src/main/java/br/com/fiap/gs/gsapi/service/EonetService.java
package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.client.NasaEonetClient;
import br.com.fiap.gs.gsapi.dto.external.NasaEonetApiResponseDTO;
import br.com.fiap.gs.gsapi.dto.external.NasaEonetCategoryDTO;
import br.com.fiap.gs.gsapi.dto.external.NasaEonetEventDTO;
import br.com.fiap.gs.gsapi.dto.request.EonetRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EonetResponseDTO;
import br.com.fiap.gs.gsapi.dto.stats.CategoryCountDTO;
// import br.com.fiap.gs.gsapi.dto.stats.TimeCountDTO; // Removido se getEventsOverTime for removido
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.EonetMapper;
import br.com.fiap.gs.gsapi.model.Eonet;
import br.com.fiap.gs.gsapi.repository.EonetRepository;
import br.com.fiap.gs.gsapi.utils.GeoUtils;

import com.fasterxml.jackson.databind.ObjectMapper;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.OffsetDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Service
public class EonetService {

    private static final Logger logger = LoggerFactory.getLogger(EonetService.class);

    private final EonetRepository eonetRepository;
    private final EonetMapper eonetMapper;
    private final NasaEonetClient nasaEonetClient;
    private final ObjectMapper objectMapper;

    @Autowired
    public EonetService(EonetRepository eonetRepository,
                        EonetMapper eonetMapper,
                        NasaEonetClient nasaEonetClient,
                        ObjectMapper objectMapper) {
        this.eonetRepository = eonetRepository;
        this.eonetMapper = eonetMapper;
        this.nasaEonetClient = nasaEonetClient;
        this.objectMapper = objectMapper;
    }

    // ... (métodos listarTodosEventos, buscarEventoPorIdInterno, etc. permanecem os mesmos) ...
    @Transactional(readOnly = true)
    @Cacheable(value = "eonetEventos", key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<EonetResponseDTO> listarTodosEventos(Pageable pageable) {
        Page<Eonet> eventosPage = eonetRepository.findAll(pageable);
        return eventosPage.map(eonetMapper::toResponseDTO);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "eonetEventoById", key = "#id")
    public EonetResponseDTO buscarEventoPorIdInterno(Long id) {
        Eonet evento = eonetRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Evento EONET não encontrado com o ID interno: " + id));
        return eonetMapper.toResponseDTO(evento);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "eonetEventoByApiId", key = "#eonetApiId")
    public EonetResponseDTO buscarEventoPorEonetApiId(String eonetApiId) {
        Eonet evento = eonetRepository.findByEonetIdApi(eonetApiId)
                .orElseThrow(() -> new ResourceNotFoundException("Evento EONET não encontrado com o ID da API: " + eonetApiId));
        return eonetMapper.toResponseDTO(evento);
    }

    @Transactional
    @CacheEvict(value = {"eonetEventos", "eonetEventoById", "eonetEventoByApiId", "eonetEventosPorData", "eonetStatsCountByCategory", "eventosProximosDaAPI"}, allEntries = true) // Removido "eonetStatsEventsOverTime"
    public EonetResponseDTO salvarEventoManualmente(EonetRequestDTO eonetRequestDTO) {
        eonetRepository.findByEonetIdApi(eonetRequestDTO.getEonetIdApi()).ifPresent(existingEvent -> {
            throw new IllegalArgumentException("Já existe um evento EONET registrado com o API ID: " + eonetRequestDTO.getEonetIdApi());
        });
        Eonet evento = eonetMapper.toEntity(eonetRequestDTO);
        Eonet eventoSalvo = eonetRepository.save(evento);
        return eonetMapper.toResponseDTO(eventoSalvo);
    }

    @Transactional
    @CachePut(value = "eonetEventoById", key = "#idInterno")
    @CacheEvict(value = {"eonetEventos", "eonetEventoByApiId", "eonetEventosPorData", "eonetStatsCountByCategory", "eventosProximosDaAPI"}, allEntries = true) // Removido "eonetStatsEventsOverTime"
    public EonetResponseDTO atualizarEventoManualmente(Long idInterno, EonetRequestDTO eonetRequestDTO) {
        Eonet eventoExistente = eonetRepository.findById(idInterno)
                .orElseThrow(() -> new ResourceNotFoundException("Evento EONET não encontrado com o ID interno: " + idInterno));

        if (!eventoExistente.getEonetIdApi().equals(eonetRequestDTO.getEonetIdApi())) {
            eonetRepository.findByEonetIdApi(eonetRequestDTO.getEonetIdApi()).ifPresent(anotherEvent -> {
                if (!anotherEvent.getIdEonet().equals(idInterno)) {
                    throw new IllegalArgumentException("Já existe outro evento EONET registrado com o API ID: " + eonetRequestDTO.getEonetIdApi());
                }
            });
        }
        eventoExistente.setEonetIdApi(eonetRequestDTO.getEonetIdApi());
        eventoExistente.setJson(eonetRequestDTO.getJson());
        eventoExistente.setData(eonetRequestDTO.getData());
        Eonet eventoAtualizado = eonetRepository.save(eventoExistente);
        return eonetMapper.toResponseDTO(eventoAtualizado);
    }

    @Transactional
    @CacheEvict(value = {"eonetEventos", "eonetEventoById", "eonetEventoByApiId", "eonetEventosPorData", "eonetStatsCountByCategory", "eventosProximosDaAPI"}, allEntries = true) // Removido "eonetStatsEventsOverTime"
    public void deletarEvento(Long idInterno) {
        if (!eonetRepository.existsById(idInterno)) {
            throw new ResourceNotFoundException("Evento EONET não encontrado com o ID interno: " + idInterno);
        }
        eonetRepository.deleteById(idInterno);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "eonetEventosPorData", key = "#dataInicial.toString() + '-' + #dataFinal.toString()")
    public List<EonetResponseDTO> buscarEventosPorIntervaloDeData(OffsetDateTime dataInicial, OffsetDateTime dataFinal) {
        if (dataInicial == null || dataFinal == null || dataInicial.isAfter(dataFinal)) {
            throw new IllegalArgumentException("Datas inválidas para busca. Data inicial deve ser anterior à data final.");
        }
        List<Eonet> eventos = eonetRepository.findByDataBetween(dataInicial, dataFinal);
        return eventos.stream()
                .map(eonetMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    @Transactional
    @CacheEvict(value = {"eonetEventos", "eonetEventoById", "eonetEventoByApiId", "eonetEventosPorData", "eonetStatsCountByCategory", "eventosProximosDaAPI", "eonetStatsEventsOverTime"}, allEntries = true) // Removido "eonetStatsEventsOverTime"
    public List<EonetResponseDTO> sincronizarEventosDaNasa(Integer limit, Integer days, String status, String source) {
        logger.info("Iniciando sincronização de eventos da NASA EONET. Limite: {}, Dias: {}, Status: {}, Fonte: {}",
                limit, days, status, source);

        NasaEonetApiResponseDTO respostaDaApi = nasaEonetClient.getEvents(limit, days, status, source, null, null, null);
        List<EonetResponseDTO> eventosSalvosOuAtualizados = new ArrayList<>();

        if (respostaDaApi != null && respostaDaApi.getEvents() != null) {
            for (NasaEonetEventDTO eventoDtoDaApi : respostaDaApi.getEvents()) {
                if (eventoDtoDaApi.getId() == null) {
                    logger.warn("Evento da API EONET recebido sem ID, pulando: {}", eventoDtoDaApi.getTitle());
                    continue;
                }
                Eonet eventoParaSalvar = eonetRepository.findByEonetIdApi(eventoDtoDaApi.getId())
                        .orElse(new Eonet());
                eventoParaSalvar.setEonetIdApi(eventoDtoDaApi.getId());
                String eventoJsonString = nasaEonetClient.convertEventDtoToJsonString(eventoDtoDaApi);
                eventoParaSalvar.setJson(eventoJsonString);
                OffsetDateTime principalDate = null;
                if (eventoDtoDaApi.getGeometry() != null && !eventoDtoDaApi.getGeometry().isEmpty() && eventoDtoDaApi.getGeometry().get(0) != null) {
                    principalDate = eventoDtoDaApi.getGeometry().get(0).getDate();
                }
                eventoParaSalvar.setData(principalDate != null ? principalDate : OffsetDateTime.now());
                Eonet eonetSalvo = eonetRepository.save(eventoParaSalvar);
                eventosSalvosOuAtualizados.add(eonetMapper.toResponseDTO(eonetSalvo));
            }
            logger.info("{} eventos da NASA EONET processados. {} salvos/atualizados.",
                    respostaDaApi.getEvents().size(), eventosSalvosOuAtualizados.size());
        } else {
            logger.warn("Nenhum evento recebido da API da NASA EONET para os parâmetros fornecidos.");
        }
        return eventosSalvosOuAtualizados;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "eventosProximosDaAPI", key = "{#latitude, #longitude, #raioKm, #limit, #days, #status, #source, #startDate, #endDate}")
    public List<NasaEonetEventDTO> buscarEventosEonetProximosDaAPI(
            Double latitude, Double longitude, Double raioKm,
            Integer limit, Integer days, String status, String source,
            String startDate, String endDate) {

        String bbox = null;
        Integer effectiveDays = days;

        if (StringUtils.hasText(startDate) || StringUtils.hasText(endDate)) {
            logger.info("Buscando eventos EONET por intervalo de datas: Start='{}', End='{}'", startDate, endDate);
            effectiveDays = null;
        } else if (latitude != null && longitude != null && raioKm != null && raioKm > 0) {
            logger.info("Buscando eventos EONET próximos a Lat: {}, Lon: {}, Raio: {}km", latitude, longitude, raioKm);
            bbox = GeoUtils.calcularBoundingBox(latitude, longitude, raioKm);
            logger.info("Bounding Box calculado: {}", bbox);
        } else {
            logger.info("Buscando eventos EONET globais.");
        }

        String effectiveStatus = status;
        if (bbox == null && !StringUtils.hasText(startDate) && !StringUtils.hasText(endDate) && !StringUtils.hasText(status)) {
            effectiveStatus = "";
            logger.info("Nenhum status especificado para busca global, usando status 'all' (vazio).");
        }

        NasaEonetApiResponseDTO respostaDaApi = nasaEonetClient.getEvents(limit, effectiveDays, effectiveStatus, source, bbox, startDate, endDate);

        if (respostaDaApi != null && respostaDaApi.getEvents() != null) {
            logger.info("{} eventos encontrados na API da NASA para os critérios fornecidos.", respostaDaApi.getEvents().size());
            return respostaDaApi.getEvents();
        }

        logger.info("Nenhum evento encontrado na API da NASA para os critérios fornecidos (respostaDaApi ou eventos nulos).");
        return Collections.emptyList();
    }

    // Método para contagem por categoria (permanece, pois usa JSON parsing em Java)
    @Transactional(readOnly = true)
    @Cacheable(value = "eonetStatsCountByCategory", key = "#daysAgo")
    public List<CategoryCountDTO> getEventCountByCategoryLastXDays(int daysAgo) {
        if (daysAgo <= 0) {
            throw new IllegalArgumentException("O número de dias ('daysAgo') deve ser positivo.");
        }
        OffsetDateTime dataFinal = OffsetDateTime.now();
        OffsetDateTime dataInicial = dataFinal.minus(daysAgo, ChronoUnit.DAYS);
        logger.info("Calculando estatísticas de eventos por categoria de {} até {}", dataInicial, dataFinal);
        List<Eonet> eventosNoPeriodo = eonetRepository.findByDataBetween(dataInicial, dataFinal);
        logger.info("Estatísticas: {} eventos locais encontrados entre {} e {} para contagem por categoria.", eventosNoPeriodo.size(), dataInicial, dataFinal);

        Map<String, Long> categoryCounts = eventosNoPeriodo.stream()
                .filter(eonet -> StringUtils.hasText(eonet.getJson()))
                .map(eonet -> {
                    try {
                        NasaEonetEventDTO eventoDetalhes = objectMapper.readValue(eonet.getJson(), NasaEonetEventDTO.class);
                        return eventoDetalhes.getCategories();
                    } catch (Exception e) {
                        logger.error("Erro ao parsear JSON do evento local ID {}: {}. JSON: {}",
                                eonet.getEonetIdApi() != null ? eonet.getEonetIdApi() : "ID_API_NULL", // Adicionado null check
                                e.getMessage(),
                                eonet.getJson().substring(0, Math.min(eonet.getJson().length(), 200)));
                        return Collections.<NasaEonetCategoryDTO>emptyList();
                    }
                })
                .filter(categories -> categories != null && !categories.isEmpty())
                .flatMap(List::stream)
                .map(NasaEonetCategoryDTO::getTitle)
                .filter(StringUtils::hasText)
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));

        return categoryCounts.entrySet().stream()
                .map(entry -> new CategoryCountDTO(entry.getKey(), entry.getValue()))
                .sorted((c1, c2) -> Long.compare(c2.getCount(), c1.getCount()))
                .collect(Collectors.toList());
    }

    // O método getEventsOverTime que dependia das queries Raw foi REMOVIDO.
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\service\alert\UserSpecificAlertService.java   |   package br.com.fiap.gs.gsapi.service.alert   |   class UserSpecificAlertService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service.alert
package br.com.fiap.gs.gsapi.service.alert;

import br.com.fiap.gs.gsapi.dto.alert.AlertableEventDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.model.Cliente; // Usando a entidade Cliente existente
import br.com.fiap.gs.gsapi.model.Contato; // Para pegar o email do contato principal
import br.com.fiap.gs.gsapi.repository.ClienteRepository; // Usando o repositório existente
import br.com.fiap.gs.gsapi.service.notification.EmailNotificationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Comparator;
import java.util.Optional;

@Service
public class UserSpecificAlertService {

    private static final Logger logger = LoggerFactory.getLogger(UserSpecificAlertService.class);

    private final ClienteRepository clienteRepository;
    private final EmailNotificationService emailNotificationService;

    @Autowired
    public UserSpecificAlertService(ClienteRepository clienteRepository,
                                    EmailNotificationService emailNotificationService) {
        this.clienteRepository = clienteRepository;
        this.emailNotificationService = emailNotificationService;
    }

    @Transactional(readOnly = true) // readOnly = true pois apenas lê e envia email (envio de email é externo)
    public void processAndSendAlert(Long userId, AlertableEventDTO eventDetails) {
        logger.info("Processando alerta para usuário ID: {} sobre evento: {}", userId, eventDetails.getTitle());

        Cliente usuario = clienteRepository.findById(userId)
                .orElseThrow(() -> {
                    logger.warn("Usuário com ID: {} não encontrado para envio de alerta.", userId);
                    return new ResourceNotFoundException("Usuário com ID: " + userId + " não encontrado.");
                });

        // Tenta obter o e-mail do primeiro contato ou do contato marcado como principal (se houver tal lógica)
        // Por simplicidade, pegaremos o primeiro e-mail encontrado.
        Optional<String> recipientEmailOpt = usuario.getContatos().stream()
                .filter(contato -> contato.getEmail() != null && !contato.getEmail().isEmpty())
                .map(Contato::getEmail)
                // Poderia adicionar uma lógica para priorizar contato "Principal" se existir esse campo.
                // .sorted(Comparator.comparing(contato -> "Principal".equalsIgnoreCase(contato.getTipoContato()) ? 0 : 1)) 
                .findFirst();

        if (recipientEmailOpt.isPresent()) {
            String recipientEmail = recipientEmailOpt.get();
            String userName = usuario.getNome(); // Ou nome completo se preferir

            // Preenchendo a descrição do evento para o email, caso não venha do frontend
            String eventDescriptionForEmail = eventDetails.getDescription();
            if (eventDescriptionForEmail == null || eventDescriptionForEmail.isEmpty()) {
                eventDescriptionForEmail = "Um evento natural foi detectado nas proximidades.";
            }
            AlertableEventDTO emailEventDetails = new AlertableEventDTO(
                    eventDetails.getEventId(),
                    eventDetails.getTitle(),
                    eventDetails.getEventDate(),
                    eventDetails.getLink(),
                    eventDescriptionForEmail
            );

            emailNotificationService.sendEventAlertEmail(recipientEmail, userName, emailEventDetails);
        } else {
            logger.warn("Usuário ID: {} ({}) não possui um e-mail de contato válido cadastrado. Alerta não enviado.", userId, usuario.getNome());
            // Poderia lançar uma exceção customizada ou apenas logar, dependendo da política de negócios.
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\service\notification\EmailNotificationService.java   |   package br.com.fiap.gs.gsapi.service.notification   |   class EmailNotificationService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.service.notification
package br.com.fiap.gs.gsapi.service.notification;

import br.com.fiap.gs.gsapi.dto.alert.AlertableEventDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.MailException;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;

@Service
public class EmailNotificationService {

    private static final Logger logger = LoggerFactory.getLogger(EmailNotificationService.class);
    private final JavaMailSender mailSender;

    @Autowired
    public EmailNotificationService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void sendEventAlertEmail(String recipientEmail, String userName, AlertableEventDTO eventDetails) {
        if (recipientEmail == null || recipientEmail.isEmpty()) {
            logger.warn("Não foi possível enviar email de alerta: destinatário de email nulo ou vazio para o usuário {}", userName);
            return;
        }

        try {
            SimpleMailMessage message = new SimpleMailMessage();
            message.setTo(recipientEmail);
            message.setSubject("GS Alerta Desastres: Novo Evento Próximo à Sua Localização!");

            StringBuilder emailBody = new StringBuilder();
            emailBody.append("Olá, ").append(userName).append("!\n\n");
            emailBody.append("Detectamos um evento de desastre natural próximo a uma de suas localizações cadastradas:\n\n");
            emailBody.append("Evento: ").append(eventDetails.getTitle()).append("\n");
            if (eventDetails.getEventDate() != null && !eventDetails.getEventDate().isEmpty()) {
                emailBody.append("Data do Evento: ").append(eventDetails.getEventDate()).append("\n");
            }
            if (eventDetails.getDescription() != null && !eventDetails.getDescription().isEmpty()) {
                emailBody.append("Descrição: ").append(eventDetails.getDescription()).append("\n");
            }
            if (eventDetails.getLink() != null && !eventDetails.getLink().isEmpty()) {
                emailBody.append("Mais informações em: ").append(eventDetails.getLink()).append("\n");
            }
            emailBody.append("\nPor favor, tome as precauções necessárias.\n\n");
            emailBody.append("Atenciosamente,\nEquipe GS Alerta Desastres");

            message.setText(emailBody.toString());

            // Você precisará configurar o remetente no application.properties (spring.mail.username)
            // message.setFrom("seu-email@example.com"); // Opcional se já configurado globalmente

            mailSender.send(message);
            logger.info("Email de alerta enviado com sucesso para {} sobre o evento {}", recipientEmail, eventDetails.getEventId());

        } catch (MailException e) {
            logger.error("Falha ao enviar email de alerta para {}: {}", recipientEmail, e.getMessage(), e);
            // Considerar adicionar uma lógica de retentativa ou notificar um administrador
        } catch (Exception e) {
            logger.error("Erro inesperado ao tentar enviar email de alerta para {}: {}", recipientEmail, e.getMessage(), e);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// java\br\com\fiap\gs\gsapi\utils\GeoUtils.java   |   package br.com.fiap.gs.gsapi.utils   |   class GeoUtils
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.utils;

import java.util.Locale;

public class GeoUtils {

    private static final double EARTH_RADIUS_KM = 6371.0;

    /**
     * Calcula uma bounding box aproximada dadas coordenadas centrais e um raio.
     * A API EONET espera o formato: W,S,E,N (minLon, minLat, maxLon, maxLat)
     *
     * @param centerLat Latitude central em graus.
     * @param centerLon Longitude central em graus.
     * @param radiusKm  Raio em quilômetros.
     * @return String da bounding box no formato "minLon,minLat,maxLon,maxLat".
     */
    public static String calcularBoundingBox(double centerLat, double centerLon, double radiusKm) {
        if (radiusKm <= 0) {
            throw new IllegalArgumentException("O raio deve ser positivo.");
        }

        // Converter latitude e longitude de graus para radianos
        double latRad = Math.toRadians(centerLat);
        double lonRad = Math.toRadians(centerLon);

        // Raio angular (distância angular do centro ao canto da "caixa")
        // Isso é uma simplificação; para maior precisão, cálculos esféricos mais complexos são necessários.
        // Esta abordagem trata o raio como a distância do centro aos lados N, S, E, O.
        double angularRadiusLatitude = radiusKm / EARTH_RADIUS_KM;
        double angularRadiusLongitude = radiusKm / (EARTH_RADIUS_KM * Math.cos(latRad)); // Ajuste para longitude baseado na latitude

        // Calcular latitudes mínimas e máximas
        double minLat = centerLat - Math.toDegrees(angularRadiusLatitude);
        double maxLat = centerLat + Math.toDegrees(angularRadiusLatitude);

        // Calcular longitudes mínimas e máximas
        double minLon = centerLon - Math.toDegrees(angularRadiusLongitude);
        double maxLon = centerLon + Math.toDegrees(angularRadiusLongitude);

        // Garantir que as latitudes estão dentro dos limites (-90 a +90)
        minLat = Math.max(minLat, -90.0);
        maxLat = Math.min(maxLat, 90.0);

        // Lidar com o cruzamento do meridiano de 180 graus para longitudes (simplificado)
        // Nota: EONET parece lidar bem com longitudes fora de +/-180 se a caixa cruzar o dateline,
        // mas é bom manter dentro do possível ou testar o comportamento específico da API.
        // Para esta implementação, não vamos complicar com o cruzamento do dateline.
        minLon = Math.max(minLon, -180.0); // Ajuste para não ir abaixo de -180
        maxLon = Math.min(maxLon, 180.0);   // Ajuste para não ir acima de 180

        // Formato EONET: W,S,E,N (Oeste, Sul, Leste, Norte)
        // minLon, minLat, maxLon, maxLat
        return String.format(Locale.US, "%.5f,%.5f,%.5f,%.5f", minLon, minLat, maxLon, maxLat);
    }
}

