// Script: converte-classes-java-em-txt-unico (v3)
// Data de criaÃ§Ã£o do arquivo de saÃ­da: 2025-05-27 10:10:18

// Estrutura de diretÃ³rios do projeto:
src/
    main/
        java/
            br/
                com/
                    fiap/
                        gs/
                            gsapi/
                                client/
                                config/
                                controller/
                                dto/
                                    geocoding/
                                    request/
                                    response/
                                    viacep/
                                exception/
                                mapper/
                                model/
                                repository/
                                service/
                                    search/
        resources/
            static/
            templates/
    test/
        java/
            br/
                com/
                    fiap/
                        gs/
                            gsapi/

// Arquivos encontrados (FQN => caminho relativo):
// br.com.fiap.gs.gsapi.GsapiApplication => main\java\br\com\fiap\gs\gsapi\GsapiApplication.java
// br.com.fiap.gs.gsapi.client.NominatimClient => main\java\br\com\fiap\gs\gsapi\client\NominatimClient.java
// br.com.fiap.gs.gsapi.client.ViaCepClient => main\java\br\com\fiap\gs\gsapi\client\ViaCepClient.java
// br.com.fiap.gs.gsapi.config.AppConfig => main\java\br\com\fiap\gs\gsapi\config\AppConfig.java
// br.com.fiap.gs.gsapi.config.CorsConfig => main\java\br\com\fiap\gs\gsapi\config\CorsConfig.java
// br.com.fiap.gs.gsapi.config.OpenApiConfig => main\java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java
// br.com.fiap.gs.gsapi.config.SwaggerBrowserLauncher => main\java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java
// br.com.fiap.gs.gsapi.controller.ClienteController => main\java\br\com\fiap\gs\gsapi\controller\ClienteController.java
// br.com.fiap.gs.gsapi.controller.EnderecoController => main\java\br\com\fiap\gs\gsapi\controller\EnderecoController.java
// br.com.fiap.gs.gsapi.dto.geocoding.NominatimResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\geocoding\NominatimResponseDTO.java
// br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java
// br.com.fiap.gs.gsapi.dto.request.EonetEventosRequestDTO => main\java\br\com\fiap\gs\gsapi\dto\request\EonetEventosRequestDTO.java
// br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.response.EonetEventoResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\response\EonetEventoResponseDTO.java
// br.com.fiap.gs.gsapi.dto.viacep.ViaCepResponseDTO => main\java\br\com\fiap\gs\gsapi\dto\viacep\ViaCepResponseDTO.java
// br.com.fiap.gs.gsapi.exception.GlobalExceptionHandler => main\java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java
// br.com.fiap.gs.gsapi.exception.ResourceNotFoundException => main\java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java
// br.com.fiap.gs.gsapi.mapper.ClienteMapper => main\java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java
// br.com.fiap.gs.gsapi.mapper.ContatoMapper => main\java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java
// br.com.fiap.gs.gsapi.mapper.EnderecoMapper => main\java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java
// br.com.fiap.gs.gsapi.mapper.EonetEventoMapper => main\java\br\com\fiap\gs\gsapi\mapper\EonetEventoMapper.java
// br.com.fiap.gs.gsapi.model.Cliente => main\java\br\com\fiap\gs\gsapi\model\Cliente.java
// br.com.fiap.gs.gsapi.model.Contato => main\java\br\com\fiap\gs\gsapi\model\Contato.java
// br.com.fiap.gs.gsapi.model.Endereco => main\java\br\com\fiap\gs\gsapi\model\Endereco.java
// br.com.fiap.gs.gsapi.model.EonetEventos => main\java\br\com\fiap\gs\gsapi\model\EonetEventos.java
// br.com.fiap.gs.gsapi.repository.ClienteRepository => main\java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java
// br.com.fiap.gs.gsapi.repository.ContatoRepository => main\java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java
// br.com.fiap.gs.gsapi.repository.EnderecoRepository => main\java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java
// br.com.fiap.gs.gsapi.repository.EonetEventoRepository => main\java\br\com\fiap\gs\gsapi\repository\EonetEventoRepository.java
// br.com.fiap.gs.gsapi.service.ClienteService => main\java\br\com\fiap\gs\gsapi\service\ClienteService.java
// br.com.fiap.gs.gsapi.service.EnderecoGeocodingService => main\java\br\com\fiap\gs\gsapi\service\EnderecoGeocodingService.java
// br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria => main\java\br\com\fiap\gs\gsapi\service\search\ClienteSearchCriteria.java
// br.com.fiap.gs.gsapi.service.search.ClienteSpecification => main\java\br\com\fiap\gs\gsapi\service\search\ClienteSpecification.java
// br.com.fiap.gs.gsapi.service.search.ContatoSearchCriteria => main\java\br\com\fiap\gs\gsapi\service\search\ContatoSearchCriteria.java

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\GsapiApplication.java   |   package br.com.fiap.gs.gsapi   |   class GsapiApplication
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.gs.gsapi;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching; // Import para habilitar o cache
// import org.springframework.data.jpa.repository.config.EnableJpaAuditing; // Opcional: para auditoria

@SpringBootApplication
@EnableCaching // Habilita o suporte a cache do Spring
// @EnableJpaAuditing // Descomente se for usar auditoria JPA (ex: @CreatedDate, @LastModifiedDate)
public class GsapiApplication {

	public static void main(String[] args) {
		SpringApplication.run(GsapiApplication.class, args);
	}

}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\client\NominatimClient.java   |   package br.com.fiap.gs.gsapi.client   |   class NominatimClient
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.client
package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.geocoding.NominatimResponseDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Flux;
import reactor.util.retry.Retry;

import java.time.Duration;

@Component
public class NominatimClient {

    private static final Logger logger = LoggerFactory.getLogger(NominatimClient.class);
    private final WebClient webClient;

    // Configure no application.properties: app.geocoding.user-agent=SuaApp/1.0 (seu.email@example.com)
    // Ã‰ OBRIGATÃ“RIO para Nominatim.
    @Value("${app.geocoding.user-agent:GSAPIDefaultApp/1.0 (fiap.gs@example.com)}")
    private String userAgent;

    private static final String NOMINATIM_BASE_URL = "https://nominatim.openstreetmap.org";

    @Autowired
    public NominatimClient(WebClient.Builder webClientBuilder) {
        // O User-Agent serÃ¡ definido no momento da requisiÃ§Ã£o para garantir que o valor de @Value seja injetado
        this.webClient = webClientBuilder.baseUrl(NOMINATIM_BASE_URL).build();
    }

    public Flux<NominatimResponseDTO> buscarCoordenadasPorEndereco(String logradouro, String numero, String bairro, String cidade, String estado, String cep) {
        // Monta a query string de forma mais estruturada.
        // A API do Nominatim Ã© sensÃ­vel Ã  formataÃ§Ã£o da query.
        // Usar parÃ¢metros separados pode ser mais eficaz do que uma string Ãºnica 'q'.
        logger.info("Buscando coordenadas no Nominatim para: Rua='{}', Num='{}', Bairro='{}', Cidade='{}', Estado='{}', CEP='{}'",
                logradouro, numero, bairro, cidade, estado, cep);
        logger.info("Usando User-Agent para Nominatim: {}", this.userAgent);

        return this.webClient.get()
                .uri(uriBuilder -> uriBuilder.path("/search")
                        // ParÃ¢metros de busca estruturada
                        .queryParam("street", (numero != null && !numero.trim().isEmpty() ? numero + " " : "") + logradouro)
                        .queryParam("city", cidade)
                        .queryParam("county", bairro) // 'county' Ã© frequentemente usado para bairro/distrito no OSM
                        .queryParam("state", estado)
                        .queryParam("country", "Brazil")
                        .queryParam("postalcode", cep)
                        // ParÃ¢metros de controle
                        .queryParam("format", "jsonv2") // jsonv2 Ã© geralmente mais consistente
                        .queryParam("addressdetails", "1")
                        .queryParam("limit", "1") // Pega o resultado mais relevante
                        .build())
                .header(HttpHeaders.USER_AGENT, this.userAgent) // Adiciona o User-Agent aqui
                .accept(MediaType.APPLICATION_JSON)
                .retrieve()
                .bodyToFlux(NominatimResponseDTO.class)
                .timeout(Duration.ofSeconds(10)) // Timeout para a requisiÃ§Ã£o
                .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)).maxBackoff(Duration.ofSeconds(5))
                        .filter(throwable -> throwable instanceof WebClientResponseException.TooManyRequests) // Exemplo de retry para 429
                        .doBeforeRetry(retrySignal -> logger.warn("Nominatim API rate limit atingido, tentando novamente... Tentativa {}", retrySignal.totalRetries() + 1))
                )
                .doOnError(WebClientResponseException.class, error ->
                        logger.error("Erro HTTP ao chamar Nominatim API: Status {}, Resposta: {}", error.getStatusCode(), error.getResponseBodyAsString(), error))
                .doOnError(error -> !(error instanceof WebClientResponseException), error -> // Loga outros erros
                        logger.error("Erro inesperado ao chamar Nominatim API: {}", error.getMessage(), error))
                .onErrorResume(error -> {
                    logger.warn("Falha ao buscar coordenadas no Nominatim apÃ³s tentativas. Retornando vazio.");
                    return Flux.empty(); // Retorna vazio em caso de erro final para nÃ£o quebrar o fluxo
                });
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\client\ViaCepClient.java   |   package br.com.fiap.gs.gsapi.client   |   class ViaCepClient
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.client
package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.viacep.ViaCepResponseDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

@Component
public class ViaCepClient {

    private static final Logger logger = LoggerFactory.getLogger(ViaCepClient.class);
    private final RestTemplate restTemplate;
    private static final String VIA_CEP_URL = "https://viacep.com.br/ws/{cep}/json/";

    @Autowired
    public ViaCepClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public ViaCepResponseDTO buscarEnderecoPorCep(String cep) {
        if (cep == null || cep.trim().isEmpty()) {
            logger.warn("Tentativa de buscar CEP nulo ou vazio.");
            return null;
        }
        // Remove caracteres nÃ£o numÃ©ricos do CEP
        String cepNumerico = cep.replaceAll("[^0-9]", "");
        if (cepNumerico.length() != 8) {
            logger.warn("CEP invÃ¡lido fornecido: '{}'. CEP numÃ©rico processado: '{}'. Deve conter 8 dÃ­gitos.", cep, cepNumerico);
            return null; // Ou lanÃ§ar uma exceÃ§Ã£o de argumento invÃ¡lido
        }

        try {
            logger.info("Buscando endereÃ§o na API ViaCEP para o CEP: {}", cepNumerico);
            ViaCepResponseDTO response = restTemplate.getForObject(VIA_CEP_URL, ViaCepResponseDTO.class, cepNumerico);

            if (response != null && response.isErro()) {
                logger.warn("CEP {} nÃ£o encontrado ou invÃ¡lido na API ViaCEP (retornou erro=true).", cepNumerico);
                return null; // CEP nÃ£o encontrado pela API
            }
            if (response != null && response.getCep() == null) { // Outra forma de ViaCEP indicar erro para CEPs inexistentes
                logger.warn("CEP {} nÃ£o resultou em dados vÃ¡lidos na API ViaCEP (campos nulos).", cepNumerico);
                return null;
            }

            logger.info("EndereÃ§o encontrado para o CEP {}: {}", cepNumerico, (response != null && response.getLocalidade() != null) ? response.getLocalidade() : "N/A");
            return response;
        } catch (HttpClientErrorException e) {
            logger.error("Erro HTTP ao chamar a API ViaCEP para o CEP {}: Status {} - Resposta: {}", cepNumerico, e.getStatusCode(), e.getResponseBodyAsString(), e);
            return null;
        } catch (RestClientException e) {
            logger.error("Erro de conectividade ou outro erro do RestClient ao chamar a API ViaCEP para o CEP {}: {}", cepNumerico, e.getMessage(), e);
            return null;
        } catch (Exception e) {
            logger.error("Erro inesperado ao processar a resposta da API ViaCEP para o CEP {}: {}", cepNumerico, e.getMessage(), e);
            return null;
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\config\AppConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class AppConfig
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.Duration;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        // Configura o RestTemplate com um timeout e um interceptor para logging (opcional)
        // BufferingClientHttpRequestFactory Ã© Ãºtil se vocÃª quiser logar o corpo da requisiÃ§Ã£o/resposta
        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
        requestFactory.setConnectTimeout((int) Duration.ofSeconds(10).toMillis());
        requestFactory.setReadTimeout((int) Duration.ofSeconds(10).toMillis());

        return builder
                .requestFactory(() -> new BufferingClientHttpRequestFactory(requestFactory))
                // .additionalInterceptors(new LoggingClientHttpRequestInterceptor()) // Crie esta classe se quiser logar
                .build();
    }

    @Bean
    public WebClient.Builder webClientBuilder() {
        // ConfiguraÃ§Ãµes padrÃ£o para o WebClient.Builder, se necessÃ¡rio
        // Ex: timeouts, codecs, etc. podem ser configurados aqui globalmente
        // ou no momento da construÃ§Ã£o do WebClient especÃ­fico.
        return WebClient.builder();
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\config\CorsConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class CorsConfig
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;
import java.util.List;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    private final Environment environment;

    // Origens permitidas para produÃ§Ã£o (leia do application.properties)
    // Ex: cors.production.allowed.origins=https://meufrontend.com,https://outrofrontend.com
    @Value("${cors.production.allowed.origins:}")
    private String[] productionAllowedOrigins;

    // Origens permitidas para desenvolvimento (pode ser fixo ou tambÃ©m configurÃ¡vel)
    @Value("${cors.development.allowed.origins:http://localhost:3000,http://localhost:3001,http://127.0.0.1:3000,http://127.0.0.1:3001}")
    private String[] developmentAllowedOrigins;

    public CorsConfig(Environment environment) {
        this.environment = environment;
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
        String[] allowedOriginsToUse;

        if (isProdProfileActive) {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÃ‡ÃƒO DE CORS PARA PRODUÃ‡ÃƒO <<<<<<<<<<");
            if (productionAllowedOrigins != null && productionAllowedOrigins.length > 0 &&
                    Arrays.stream(productionAllowedOrigins).anyMatch(origin -> origin != null && !origin.trim().isEmpty())) {
                allowedOriginsToUse = Arrays.stream(productionAllowedOrigins)
                        .filter(origin -> origin != null && !origin.trim().isEmpty())
                        .toArray(String[]::new);
                System.out.println("Allowed Origins (prod): " + String.join(", ", allowedOriginsToUse));
            } else {
                System.out.println("WARN: Nenhuma origem de produÃ§Ã£o VÃLIDA configurada para CORS (cors.production.allowed.origins). CORS estarÃ¡ altamente restrito.");
                // Por seguranÃ§a, defina um fallback restrito ou nenhuma origem se nÃ£o configurado
                allowedOriginsToUse = new String[]{}; // Ou uma URL de fallback muito especÃ­fica
            }
        } else {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÃ‡ÃƒO DE CORS PARA DESENVOLVIMENTO/PADRÃƒO <<<<<<<<<<");
            allowedOriginsToUse = developmentAllowedOrigins;
            System.out.println("Allowed Origins (dev/default): " + String.join(", ", allowedOriginsToUse));
        }

        if (allowedOriginsToUse.length > 0) {
            registry.addMapping("/**") // Aplica a todas as rotas da API
                    .allowedOrigins(allowedOriginsToUse)
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD")
                    .allowedHeaders("*") // Permite todos os cabeÃ§alhos
                    .allowCredentials(true) // Importante se vocÃª usar cookies ou autenticaÃ§Ã£o baseada em sessÃ£o
                    .maxAge(3600); // Tempo em segundos que o resultado de uma requisiÃ§Ã£o pre-flight OPTIONS pode ser cacheado
        } else if (isProdProfileActive) {
            // Se em produÃ§Ã£o e nenhuma origem vÃ¡lida foi configurada, nÃ£o adicione nenhum mapping de CORS
            // ou adicione um muito restritivo para bloquear por padrÃ£o.
            System.out.println("WARN: CORS em produÃ§Ã£o estÃ¡ bloqueado pois nenhuma origem vÃ¡lida foi configurada.");
        }
    }

    // Alternativamente, vocÃª pode usar um CorsFilter Bean se preferir uma configuraÃ§Ã£o mais programÃ¡tica
    // ou se precisar de mais controle sobre a ordem dos filtros.
    // @Bean
    // public CorsFilter corsFilter() {
    //     UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    //     CorsConfiguration config = new CorsConfiguration();
    //     config.setAllowCredentials(true);
    //
    //     boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
    //     if (isProdProfileActive && productionAllowedOrigins != null && productionAllowedOrigins.length > 0) {
    //         config.setAllowedOrigins(Arrays.asList(productionAllowedOrigins));
    //     } else {
    //         config.setAllowedOrigins(Arrays.asList(developmentAllowedOrigins)); // Ou use allowedOriginPatterns
    //     }
    //
    //     config.addAllowedHeader("*");
    //     config.addAllowedMethod("*"); // GET, POST, PUT, DELETE, etc.
    //     source.registerCorsConfiguration("/**", config);
    //     return new CorsFilter(source);
    // }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java   |   package br.com.fiap.gs.gsapi.config   |   class OpenApiConfig
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

/**
 * Classe de configuraÃ§Ã£o do Springdoc OpenAPI para definir as informaÃ§Ãµes detalhadas da API.
 * Isso inclui tÃ­tulo, versÃ£o, descriÃ§Ã£o, informaÃ§Ãµes de contato e licenÃ§a,
 * que serÃ£o exibidos na interface do Swagger UI.
 */
@Configuration
public class OpenApiConfig {

    private static final Logger log = LoggerFactory.getLogger(OpenApiConfig.class);

    // VocÃª pode injetar valores do application.properties se precisar
    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    @Bean
    public OpenAPI customOpenAPI() {
        log.info("ðŸ”§ ConfiguraÃ§Ã£o personalizada do OpenAPI inicializada.");

        // ConstrÃ³i a URL base do servidor dinamicamente
        String serverUrl = "http://localhost:" + serverPort + (contextPath != null ? contextPath : "");

        return new OpenAPI()
                .info(new Info()
                        .title("GS API - Alertas de Desastres Naturais") // TÃ­tulo da sua API
                        .version("v1.0.0") // VersÃ£o da sua API
                        .description("""
                                **API RESTful para o Global Solution FIAP 2025**

                                Esta API fornece funcionalidades para consulta de informaÃ§Ãµes sobre desastres naturais
                                e gerenciamento de alertas para usuÃ¡rios com base em sua localizaÃ§Ã£o.
                                IntegraÃ§Ã£o com a API EONET da NASA e serviÃ§os de geolocalizaÃ§Ã£o.

                                **Funcionalidades Principais:**
                                - Cadastro e gerenciamento de clientes e seus endereÃ§os.
                                - Consulta de eventos de desastres naturais (via EONET).
                                - AssociaÃ§Ã£o de eventos de desastres a endereÃ§os de clientes.
                                - VisualizaÃ§Ã£o de alertas em mapas (a ser implementado no frontend).
                                """)
                        .contact(new Contact()
                                .name("Equipe GS API") // Nome da sua equipe ou seu nome
                                .email("seu-email@fiap.com.br") // Seu email de contato
                                .url("https://github.com/seu-usuario/gs-api-repo") // URL do seu projeto no GitHub
                        )
                        .license(new License()
                                .name("Apache 2.0") // Ou a licenÃ§a que vocÃª escolher
                                .url("https://www.apache.org/licenses/LICENSE-2.0.html")
                        )
                )
                .servers(List.of(
                        new Server().url(serverUrl).description("Servidor Local de Desenvolvimento")
                        // VocÃª pode adicionar outros servidores aqui (ex: homologaÃ§Ã£o, produÃ§Ã£o)
                        // new Server().url("https://api.seudominio.com/gsapi").description("Servidor de ProduÃ§Ã£o")
                ));
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java   |   package br.com.fiap.gs.gsapi.config   |   class SwaggerBrowserLauncher
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.EventListener;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Componente para abrir automaticamente o Swagger UI no navegador
 * quando a aplicaÃ§Ã£o inicia em um perfil de desenvolvimento.
 */
@Configuration
@Profile("dev") // Ativa este componente apenas quando o perfil 'dev' estiver ativo
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    // O caminho padrÃ£o do Swagger UI Ã© geralmente /swagger-ui/index.html ou /swagger-ui.html
    // Verifique a propriedade springdoc.swagger-ui.path se vocÃª a customizou
    @Value("${springdoc.swagger-ui.path:/swagger-ui.html}")
    private String swaggerUiPath;

    @Value("${app.launch-swagger-on-startup:true}") // Propriedade customizada para controlar o lanÃ§amento
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automÃ¡tica do Swagger UI no navegador estÃ¡ desabilitada via app.launch-swagger-on-startup=false.");
            return;
        }

        // ConstrÃ³i a URL completa, garantindo que o contextPath seja tratado corretamente
        String effectiveContextPath = (contextPath == null || "/".equals(contextPath)) ? "" : contextPath;
        String effectiveSwaggerUiPath = swaggerUiPath.startsWith("/") ? swaggerUiPath : "/" + swaggerUiPath;

        String url = "http://localhost:" + serverPort + effectiveContextPath + effectiveSwaggerUiPath;
        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI: {}", url);
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI (URL: {}): {}", url, e.getMessage(), e);
            }
        } else {
            log.warn("Abertura automÃ¡tica do navegador nÃ£o Ã© suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\controller\ClienteController.java   |   package br.com.fiap.gs.gsapi.controller   |   class ClienteController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.controller
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.exception.GlobalExceptionHandler; // Para referÃªncia no Swagger
import br.com.fiap.gs.gsapi.service.ClienteService;
import br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria; // Para busca por parÃ¢metros

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springdoc.core.annotations.ParameterObject; // Para agrupar parÃ¢metros de paginaÃ§Ã£o e filtro no Swagger

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/api/v1/clientes")
@Tag(name = "Clientes", description = "Endpoints para gerenciamento de clientes e suas informaÃ§Ãµes relacionadas.")
public class ClienteController {

    private final ClienteService clienteService;

    @Autowired
    public ClienteController(ClienteService clienteService) {
        this.clienteService = clienteService;
    }

    @Operation(
            summary = "Listar todos os clientes com paginaÃ§Ã£o, ordenaÃ§Ã£o e filtros.",
            description = "Retorna uma lista paginada de clientes. Permite filtrar por nome (parcial, case-insensitive), " +
                    "documento (exato) e data de nascimento (exato, formato YYYY-MM-DD ou como definido na entidade). " +
                    "ParÃ¢metros de paginaÃ§Ã£o padrÃ£o: `page=0`, `size=10`. ParÃ¢metro de ordenaÃ§Ã£o padrÃ£o: `sort=nome,asc`."
    )
    @Parameters({
            @Parameter(name = "page", description = "NÃºmero da pÃ¡gina (comeÃ§a em 0)", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "0")),
            @Parameter(name = "size", description = "Tamanho da pÃ¡gina", in = ParameterIn.QUERY, schema = @Schema(type = "integer", defaultValue = "10")),
            @Parameter(name = "sort", description = "CritÃ©rio de ordenaÃ§Ã£o (ex: nome,asc ou nome,desc ou multiplos: nome,asc&sort=documento,desc)", in = ParameterIn.QUERY, schema = @Schema(type = "string", example = "nome,asc"))
            // Os parÃ¢metros de ClienteSearchCriteria (nome, documento, dataNascimento) serÃ£o documentados automaticamente pelo @ParameterObject
    })
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista de clientes encontrada.",
                    content = @Content(mediaType = "application/json",
                            schema = @Schema(implementation = Page.class))) // Idealmente, o Swagger mostraria Page<ClienteResponseDTO>
    })
    @GetMapping
    public ResponseEntity<Page<ClienteResponseDTO>> listarTodosClientes(
            @ParameterObject @Valid ClienteSearchCriteria criteria, // ParÃ¢metros de filtro agrupados e validados
            @PageableDefault(size = 10, sort = "nome") Pageable pageable) {
        Page<ClienteResponseDTO> clientes = clienteService.listarTodos(criteria, pageable); // CORRIGIDO: Passando criteria
        return ResponseEntity.ok(clientes);
    }

    @Operation(summary = "Buscar cliente por ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Cliente encontrado.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class))),
            @ApiResponse(responseCode = "404", description = "Cliente nÃ£o encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @GetMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> buscarClientePorId(
            @Parameter(description = "ID do cliente a ser buscado.", required = true, example = "1") @PathVariable Long id) {
        ClienteResponseDTO cliente = clienteService.buscarPorId(id);
        return ResponseEntity.ok(cliente);
    }

    @Operation(summary = "Criar um novo cliente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "RequisiÃ§Ã£o invÃ¡lida devido a erro de validaÃ§Ã£o ou regra de negÃ³cio (ex: documento duplicado).", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PostMapping
    public ResponseEntity<ClienteResponseDTO> criarCliente(
            @Parameter(description = "Dados do cliente para criaÃ§Ã£o.", required = true,
                    content = @Content(schema = @Schema(implementation = ClienteRequestDTO.class)))
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO) {
        ClienteResponseDTO clienteSalvo = clienteService.criar(clienteRequestDTO);
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(clienteSalvo.getIdCliente())
                .toUri();
        return ResponseEntity.created(location).body(clienteSalvo);
    }

    @Operation(summary = "Atualizar um cliente existente.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Cliente atualizado com sucesso.",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "RequisiÃ§Ã£o invÃ¡lida devido a erro de validaÃ§Ã£o ou regra de negÃ³cio.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class))),
            @ApiResponse(responseCode = "404", description = "Cliente nÃ£o encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @PutMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> atualizarCliente(
            @Parameter(description = "ID do cliente a ser atualizado.", required = true, example = "1") @PathVariable Long id,
            @Parameter(description = "Dados do cliente para atualizaÃ§Ã£o.", required = true,
                    content = @Content(schema = @Schema(implementation = ClienteRequestDTO.class)))
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO) {
        ClienteResponseDTO clienteAtualizado = clienteService.atualizar(id, clienteRequestDTO);
        return ResponseEntity.ok(clienteAtualizado);
    }

    @Operation(summary = "Deletar um cliente por ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Cliente deletado com sucesso.", content = @Content),
            @ApiResponse(responseCode = "404", description = "Cliente nÃ£o encontrado.", content = @Content(schema = @Schema(implementation = GlobalExceptionHandler.ApiError.class)))
    })
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarCliente(
            @Parameter(description = "ID do cliente a ser deletado.", required = true, example = "1") @PathVariable Long id) {
        clienteService.deletar(id);
        return ResponseEntity.noContent().build();
    }

}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\controller\EnderecoController.java   |   package br.com.fiap.gs.gsapi.controller   |   class EnderecoController
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.controller
package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.mapper.EnderecoMapper;
import br.com.fiap.gs.gsapi.model.Endereco;
import br.com.fiap.gs.gsapi.service.EnderecoGeocodingService; // Importe o novo serviÃ§o
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Optional;

@RestController
@RequestMapping("/api/v1/enderecos") // Ou um endpoint base mais apropriado
@Tag(name = "EndereÃ§os", description = "Endpoints para gerenciamento e consulta de endereÃ§os")
public class EnderecoController {

    private final EnderecoGeocodingService enderecoGeocodingService;
    private final EnderecoMapper enderecoMapper;
    // Injete outros serviÃ§os e repositÃ³rios de EndereÃ§o se tiver CRUD completo para EndereÃ§o

    @Autowired
    public EnderecoController(EnderecoGeocodingService enderecoGeocodingService, EnderecoMapper enderecoMapper) {
        this.enderecoGeocodingService = enderecoGeocodingService;
        this.enderecoMapper = enderecoMapper;
    }

    @Operation(summary = "Buscar endereÃ§o completo por CEP e nÃºmero",
            description = "Busca dados do endereÃ§o usando ViaCEP e tenta obter coordenadas de geolocalizaÃ§Ã£o. " +
                    "O nÃºmero Ã© importante para a precisÃ£o da geolocalizaÃ§Ã£o.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "EndereÃ§o encontrado e geocodificado (se possÃ­vel)",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class))),
            @ApiResponse(responseCode = "400", description = "CEP invÃ¡lido", content = @Content),
            @ApiResponse(responseCode = "404", description = "CEP nÃ£o encontrado ou endereÃ§o nÃ£o pÃ´de ser geocodificado", content = @Content)
    })
    @GetMapping("/cep/{cep}")
    public ResponseEntity<EnderecoResponseDTO> buscarEnderecoCompletoPorCep(
            @Parameter(description = "CEP a ser consultado (apenas nÃºmeros ou formatado)", required = true, example = "01001000")
            @PathVariable String cep,
            @Parameter(description = "NÃºmero do endereÃ§o para geolocalizaÃ§Ã£o mais precisa", required = true, example = "100")
            @RequestParam String numero,
            @Parameter(description = "Complemento do endereÃ§o (opcional)", example = "Apto 101")
            @RequestParam(required = false) String complemento) {

        if (cep == null || cep.replaceAll("[^0-9]", "").length() != 8) {
            return ResponseEntity.badRequest().build(); // ValidaÃ§Ã£o bÃ¡sica do CEP
        }
        if (numero == null || numero.trim().isEmpty()) {
            return ResponseEntity.badRequest().build(); // NÃºmero Ã© crucial para geocodificaÃ§Ã£o
        }

        Optional<Endereco> enderecoCompleto = enderecoGeocodingService.obterOuCriarEnderecoCompleto(cep, numero, complemento);

        return enderecoCompleto
                .map(endereco -> ResponseEntity.ok(enderecoMapper.toEnderecoResponseDTO(endereco)))
                .orElseGet(() -> ResponseEntity.notFound().build());
    }

    // Aqui vocÃª adicionaria outros endpoints CRUD para EndereÃ§o, se necessÃ¡rio,
    // usando um EnderecoService dedicado para a lÃ³gica de negÃ³cio do EndereÃ§o.
    // Ex: POST para criar um novo endereÃ§o manualmente, PUT para atualizar, GET /id, GET (listagem), DELETE.
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\geocoding\NominatimResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.geocoding   |   class NominatimResponseDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.dto.geocoding
package br.com.fiap.gs.gsapi.dto.geocoding;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

// Ignora propriedades desconhecidas no JSON para evitar erros de deserializaÃ§Ã£o
@JsonIgnoreProperties(ignoreUnknown = true)
public class NominatimResponseDTO {

    @JsonProperty("place_id")
    private String placeId;

    @JsonProperty("lat")
    private String latitude;

    @JsonProperty("lon")
    private String longitude;

    @JsonProperty("display_name")
    private String displayName;

    // Adicionar mais campos se necessÃ¡rio, como 'address' para detalhes
    // @JsonProperty("address")
    // private NominatimAddressDetailsDTO addressDetails;

    // Construtor padrÃ£o
    public NominatimResponseDTO() {
    }

    // Getters e Setters
    public String getPlaceId() { return placeId; }
    public void setPlaceId(String placeId) { this.placeId = placeId; }
    public String getLatitude() { return latitude; }
    public void setLatitude(String latitude) { this.latitude = latitude; }
    public String getLongitude() { return longitude; }
    public void setLongitude(String longitude) { this.longitude = longitude; }
    public String getDisplayName() { return displayName; }
    public void setDisplayName(String displayName) { this.displayName = displayName; }
    // public NominatimAddressDetailsDTO getAddressDetails() { return addressDetails; }
    // public void setAddressDetails(NominatimAddressDetailsDTO addressDetails) { this.addressDetails = addressDetails; }

    // DTO aninhado para detalhes do endereÃ§o, se vocÃª precisar deles
    // @JsonIgnoreProperties(ignoreUnknown = true)
    // public static class NominatimAddressDetailsDTO {
    //     private String road;
    //     private String suburb; // Bairro
    //     private String city;
    //     private String state;
    //     private String postcode;
    //     private String country;
    //     // Getters e Setters
    // }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class ClienteRequestDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
// importe outras anotaÃ§Ãµes de validaÃ§Ã£o conforme necessÃ¡rio

public class ClienteRequestDTO {

    @NotBlank(message = "O nome nÃ£o pode estar em branco")
    @Size(max = 100, message = "O nome deve ter no mÃ¡ximo 100 caracteres")
    private String nome;

    @NotBlank(message = "O sobrenome nÃ£o pode estar em branco")
    @Size(max = 100, message = "O sobrenome deve ter no mÃ¡ximo 100 caracteres")
    private String sobrenome;

    @NotBlank(message = "A data de nascimento nÃ£o pode estar em branco")
    @Size(max = 10, message = "A data de nascimento deve ter no mÃ¡ximo 10 caracteres") // Ou use @Pattern para formato
    private String dataNascimento;

    @NotBlank(message = "O documento nÃ£o pode estar em branco")
    @Size(max = 18, message = "O documento deve ter no mÃ¡ximo 18 caracteres")
    private String documento;

    // Relacionamentos (contatos, endereÃ§os) geralmente sÃ£o gerenciados
    // atravÃ©s de IDs em DTOs ou por endpoints separados.
    // Ex: private Set<Long> idsContatos;
    // Ou vocÃª pode aninhar CreateContatoRequestDTO etc., mas pode ficar complexo.

    public ClienteRequestDTO() {
    }

    // Construtor, Getters e Setters
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class ContatoRequestDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.dto.request

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class ContatoRequestDTO {

    @NotBlank(message = "O DDD nÃ£o pode estar em branco")
    @Size(min = 2, max = 3, message = "O DDD deve ter entre 2 e 3 caracteres")
    private String ddd;

    @NotBlank(message = "O telefone nÃ£o pode estar em branco")
    @Size(min = 8, max = 15, message = "O telefone deve ter entre 8 e 15 caracteres")
    @Pattern(regexp = "^[0-9]+$", message = "O telefone deve conter apenas nÃºmeros")
    private String telefone;

    @Size(min = 9, max = 15, message = "O celular deve ter entre 9 e 15 caracteres")
    @Pattern(regexp = "^[0-9]+$", message = "O celular deve conter apenas nÃºmeros")
    private String celular; // Pode ser opcional dependendo da regra de negÃ³cio

    @Size(min = 9, max = 15, message = "O WhatsApp deve ter entre 9 e 15 caracteres")
    @Pattern(regexp = "^[0-9]+$", message = "O WhatsApp deve conter apenas nÃºmeros")
    private String whatsapp; // Pode ser opcional

    @NotBlank(message = "O email nÃ£o pode estar em branco")
    @Email(message = "Formato de email invÃ¡lido")
    @Size(max = 255, message = "O email deve ter no mÃ¡ximo 255 caracteres")
    private String email;

    @NotBlank(message = "O tipo de contato nÃ£o pode estar em branco")
    @Size(max = 50, message = "O tipo de contato deve ter no mÃ¡ximo 50 caracteres")
    private String tipoContato;

    public ContatoRequestDTO() {
    }

    public ContatoRequestDTO(String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    public String getDdd() {
        return ddd;
    }

    public void setDdd(String ddd) {
        this.ddd = ddd;
    }

    public String getTelefone() {
        return telefone;
    }

    public void setTelefone(String telefone) {
        this.telefone = telefone;
    }

    public String getCelular() {
        return celular;
    }

    public void setCelular(String celular) {
        this.celular = celular;
    }

    public String getWhatsapp() {
        return whatsapp;
    }

    public void setWhatsapp(String whatsapp) {
        this.whatsapp = whatsapp;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getTipoContato() {
        return tipoContato;
    }

    public void setTipoContato(String tipoContato) {
        this.tipoContato = tipoContato;
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class EnderecoRequestDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.dto.request

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.DecimalMax;
import jakarta.validation.constraints.DecimalMin;
import jakarta.validation.constraints.Digits;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public class EnderecoRequestDTO {

    @NotBlank(message = "O CEP nÃ£o pode estar em branco")
    @Size(min = 8, max = 9, message = "O CEP deve ter entre 8 e 9 caracteres (ex: 00000-000 ou 00000000)")
    private String cep;

    @NotNull(message = "O nÃºmero nÃ£o pode ser nulo")
    @Min(value = 1, message = "O nÃºmero deve ser no mÃ­nimo 1")
    @Max(value = 99999, message = "O nÃºmero deve ser no mÃ¡ximo 99999") // Conforme DDL NUMBER(5)
    private int numero;

    @NotBlank(message = "O logradouro nÃ£o pode estar em branco")
    @Size(max = 255, message = "O logradouro deve ter no mÃ¡ximo 255 caracteres")
    private String logradouro;

    @NotBlank(message = "O bairro nÃ£o pode estar em branco")
    @Size(max = 255, message = "O bairro deve ter no mÃ¡ximo 255 caracteres")
    private String bairro;

    @NotBlank(message = "A localidade nÃ£o pode estar em branco")
    @Size(max = 100, message = "A localidade deve ter no mÃ¡ximo 100 caracteres")
    private String localidade;

    @NotBlank(message = "A UF nÃ£o pode estar em branco")
    @Size(min = 2, max = 2, message = "A UF deve ter 2 caracteres")
    private String uf;

    @Size(max = 255, message = "O complemento deve ter no mÃ¡ximo 255 caracteres")
    private String complemento; // Complemento Ã© opcional

    @NotNull(message = "A latitude nÃ£o pode ser nula")
    @DecimalMin(value = "-90.0", message = "Latitude mÃ­nima Ã© -90.0")
    @DecimalMax(value = "90.0", message = "Latitude mÃ¡xima Ã© 90.0")
    @Digits(integer = 3, fraction = 7, message = "Latitude deve ter atÃ© 3 dÃ­gitos inteiros e 7 fracionÃ¡rios") // Para NUMBER(10,7)
    private Double latitude;

    @NotNull(message = "A longitude nÃ£o pode ser nula")
    @DecimalMin(value = "-180.0", message = "Longitude mÃ­nima Ã© -180.0")
    @DecimalMax(value = "180.0", message = "Longitude mÃ¡xima Ã© 180.0")
    @Digits(integer = 3, fraction = 7, message = "Longitude deve ter atÃ© 3 dÃ­gitos inteiros e 7 fracionÃ¡rios") // Para NUMBER(10,7)
    private Double longitude;

    public EnderecoRequestDTO() {
    }

    public EnderecoRequestDTO(String cep, int numero, String logradouro, String bairro, String localidade, String uf, String complemento, Double latitude, Double longitude) {
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public int getNumero() { return numero; }
    public void setNumero(int numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public Double getLatitude() { return latitude; }
    public void setLatitude(Double latitude) { this.latitude = latitude; }
    public Double getLongitude() { return longitude; }
    public void setLongitude(Double longitude) { this.longitude = longitude; }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\request\EonetEventosRequestDTO.java   |   package br.com.fiap.gs.gsapi.dto.request   |   class EonetEventosRequestDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.dto.request

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.time.Instant;

public class EonetEventosRequestDTO {

    @NotBlank(message = "O ID original da EONET (eonetApiId) nÃ£o pode estar em branco.")
    @Size(max = 50, message = "O ID da EONET deve ter no mÃ¡ximo 50 caracteres.")
    private String eonetApiId; // O ID original da API EONET (ex: "EONET_12345")

    @NotBlank(message = "O payload JSON do evento (jsonEvento) nÃ£o pode estar em branco.")
    // NÃ£o hÃ¡ uma anotaÃ§Ã£o de tamanho padrÃ£o para CLOB em DTOs,
    // mas a validaÃ§Ã£o de ser um JSON vÃ¡lido ocorreria na camada de serviÃ§o ou ao persistir.
    private String jsonEvento; // O JSON completo do evento

    @NotNull(message = "A data do evento/ingestÃ£o nÃ£o pode ser nula.")
    private Instant data; // A coluna 'data' da sua tabela gs_eonet (TIMESTAMP WITH LOCAL TIME ZONE)

    public EonetEventosRequestDTO() {
    }

    public EonetEventosRequestDTO(String eonetApiId, String jsonEvento, Instant data) {
        this.eonetApiId = eonetApiId;
        this.jsonEvento = jsonEvento;
        this.data = data;
    }

    public String getEonetApiId() {
        return eonetApiId;
    }

    public void setEonetApiId(String eonetApiId) {
        this.eonetApiId = eonetApiId;
    }

    public String getJsonEvento() {
        return jsonEvento;
    }

    public void setJsonEvento(String jsonEvento) {
        this.jsonEvento = jsonEvento;
    }

    public Instant getData() {
        return data;
    }

    public void setData(Instant data) {
        this.data = data;
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class ClienteResponseDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.gs.gsapi.dto.response;

import java.util.Set;
// Supondo que vocÃª tambÃ©m crie ContatoResponseDTO e EnderecoResponseDTO
// import br.com.fiap.gs.gsapi.dto.ContatoResponseDTO;
// import br.com.fiap.gs.gsapi.dto.EnderecoResponseDTO;

public class ClienteResponseDTO {
    private long idCliente;
    private String nome;
    private String sobrenome;
    private String dataNascimento;
    private String documento;
    private Set<ContatoResponseDTO> contatos;   // Usar DTOs para objetos aninhados
    private Set<EnderecoResponseDTO> enderecos; // Usar DTOs para objetos aninhados

    public ClienteResponseDTO() {
    }

    // Construtor, Getters e Setters
    public long getIdCliente() { return idCliente; }
    public void setIdCliente(long idCliente) { this.idCliente = idCliente; }
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }
    public Set<ContatoResponseDTO> getContatos() { return contatos; }
    public void setContatos(Set<ContatoResponseDTO> contatos) { this.contatos = contatos; }
    public Set<EnderecoResponseDTO> getEnderecos() { return enderecos; }
    public void setEnderecos(Set<EnderecoResponseDTO> enderecos) { this.enderecos = enderecos; }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class ContatoResponseDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.gs.gsapi.dto.response;

public class ContatoResponseDTO {
    private long idContato;
    private String ddd;
    private String telefone;
    private String celular;
    private String whatsapp;
    private String email;
    private String tipoContato;

    public ContatoResponseDTO() {
    }
    // Construtor, Getters e Setters
    public long getIdContato() { return idContato; }
    public void setIdContato(long idContato) { this.idContato = idContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class EnderecoResponseDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.dto.response

package br.com.fiap.gs.gsapi.dto.response;

import java.util.Set;

public class EnderecoResponseDTO {
    private long idEndereco;
    private String cep;
    private int numero;
    private String logradouro;
    private String bairro;
    private String localidade;
    private String uf;
    private String complemento;
    private double latitude;
    private double longitude;
    private Set<EonetEventoResponseDTO> eonetEventos; // Assumindo que vocÃª terÃ¡ um DTO para EonetEventos

    public EnderecoResponseDTO() {
    }

    // Construtor, Getters e Setters
    public long getIdEndereco() { return idEndereco; }
    public void setIdEndereco(long idEndereco) { this.idEndereco = idEndereco; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public int getNumero() { return numero; }
    public void setNumero(int numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public double getLatitude() { return latitude; }
    public void setLatitude(double latitude) { this.latitude = latitude; }
    public double getLongitude() { return longitude; }
    public void setLongitude(double longitude) { this.longitude = longitude; }
    public Set<EonetEventoResponseDTO> getEonetEventos() { return eonetEventos; }
    public void setEonetEventos(Set<EonetEventoResponseDTO> eonetEventos) { this.eonetEventos = eonetEventos; }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\response\EonetEventoResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.response   |   class EonetEventoResponseDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.dto.response

package br.com.fiap.gs.gsapi.dto.response;

import java.time.Instant;

public class EonetEventoResponseDTO {
    private long idEonet; // PK numÃ©rica interna da sua tabela gs_eonet
    private String eonetApiId; // O ID original da API EONET (ex: "EONET_12345")
    private Instant data; // A coluna 'data' da sua tabela gs_eonet (TIMESTAMP WITH LOCAL TIME ZONE)

    // Campos que seriam extraÃ­dos do JSON na camada de serviÃ§o/mapper
    private String tituloEvento;
    private String linkEvento;
    private Instant dataOcorrenciaOriginalEonet; // A data do evento conforme reportado pela EONET (pode ser diferente da sua 'data' de ingestÃ£o)
    private String categoriaPrincipal; // Exemplo: "Wildfires", "Severe Storms"

    // NÃ£o inclua o campo 'jsonEvento' (CLOB) aqui.

    public EonetEventoResponseDTO() {
    }

    // Construtor, Getters e Setters
    public long getIdEonet() { return idEonet; }
    public void setIdEonet(long idEonet) { this.idEonet = idEonet; }
    public String getEonetApiId() { return eonetApiId; }
    public void setEonetApiId(String eonetApiId) { this.eonetApiId = eonetApiId; }
    public Instant getData() { return data; }
    public void setData(Instant data) { this.data = data; }
    public String getTituloEvento() { return tituloEvento; }
    public void setTituloEvento(String tituloEvento) { this.tituloEvento = tituloEvento; }
    public String getLinkEvento() { return linkEvento; }
    public void setLinkEvento(String linkEvento) { this.linkEvento = linkEvento; }
    public Instant getDataOcorrenciaOriginalEonet() { return dataOcorrenciaOriginalEonet; }
    public void setDataOcorrenciaOriginalEonet(Instant dataOcorrenciaOriginalEonet) { this.dataOcorrenciaOriginalEonet = dataOcorrenciaOriginalEonet; }
    public String getCategoriaPrincipal() { return categoriaPrincipal; }
    public void setCategoriaPrincipal(String categoriaPrincipal) { this.categoriaPrincipal = categoriaPrincipal; }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\dto\viacep\ViaCepResponseDTO.java   |   package br.com.fiap.gs.gsapi.dto.viacep   |   class ViaCepResponseDTO
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.dto.viacep
package br.com.fiap.gs.gsapi.dto.viacep;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

// Ignora propriedades desconhecidas no JSON para evitar erros de deserializaÃ§Ã£o
@JsonIgnoreProperties(ignoreUnknown = true)
public class ViaCepResponseDTO {

    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade; // Cidade
    private String uf;         // Estado
    private String ibge;
    private String gia;
    private String ddd;
    private String siafi;

    @JsonProperty("erro") // Para mapear o campo "erro" do JSON para o mÃ©todo isErro() / setErro()
    private boolean erro; // ViaCEP retorna erro=true se o CEP nÃ£o for encontrado

    // Construtor padrÃ£o
    public ViaCepResponseDTO() {
    }

    // Getters e Setters para todos os campos
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getIbge() { return ibge; }
    public void setIbge(String ibge) { this.ibge = ibge; }
    public String getGia() { return gia; }
    public void setGia(String gia) { this.gia = gia; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getSiafi() { return siafi; }
    public void setSiafi(String siafi) { this.siafi = siafi; }
    public boolean isErro() { return erro; } // Getter para boolean
    public void setErro(boolean erro) { this.erro = erro; } // Setter para boolean
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java   |   package br.com.fiap.gs.gsapi.exception   |   class GlobalExceptionHandler
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.exception
package br.com.fiap.gs.gsapi.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        logger.warn("Recurso nÃ£o encontrado: {} na requisiÃ§Ã£o: {}", ex.getMessage(), request.getDescription(false));
        ApiError apiError = new ApiError(HttpStatus.NOT_FOUND.value(), ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(apiError, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Object> handleIllegalArgumentException(IllegalArgumentException ex, WebRequest request) {
        logger.warn("Argumento ilegal: {} na requisiÃ§Ã£o: {}", ex.getMessage(), request.getDescription(false));
        ApiError apiError = new ApiError(HttpStatus.BAD_REQUEST.value(), ex.getMessage(), LocalDateTime.now());
        return new ResponseEntity<>(apiError, HttpStatus.BAD_REQUEST);
    }

    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, HttpHeaders headers,
            HttpStatusCode status, WebRequest request) {

        logger.warn("Erro de validaÃ§Ã£o: {} na requisiÃ§Ã£o: {}", ex.getMessage(), request.getDescription(false));
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", status.value());
        body.put("message", "Erro de validaÃ§Ã£o nos campos da requisiÃ§Ã£o.");

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.toList());

        ex.getBindingResult().getGlobalErrors().forEach(globalError -> {
            errors.add(globalError.getObjectName() + ": " + globalError.getDefaultMessage());
        });

        body.put("details", errors);

        return new ResponseEntity<>(body, headers, status);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleAllUncaughtException(Exception ex, WebRequest request) {
        logger.error("Erro inesperado no servidor na requisiÃ§Ã£o: " + request.getDescription(false) , ex);
        ApiError apiError = new ApiError(HttpStatus.INTERNAL_SERVER_ERROR.value(), "Ocorreu um erro inesperado no servidor. Tente novamente mais tarde.", LocalDateTime.now());
        return new ResponseEntity<>(apiError, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // Classe DTO interna para representar a resposta de erro padronizada
    // Adicionado timestamp para melhor rastreabilidade
    // CORRIGIDO: Tornada pÃºblica para ser acessÃ­vel por outras classes (ex: Swagger schema)
    public static class ApiError {
        private int status;
        private String message;
        private LocalDateTime timestamp;

        public ApiError(int status, String message, LocalDateTime timestamp) {
            this.status = status;
            this.message = message;
            this.timestamp = timestamp;
        }
        public int getStatus() { return status; }
        public void setStatus(int status) { this.status = status; }
        public String getMessage() { return message; }
        public void setMessage(String message) { this.message = message; }
        public LocalDateTime getTimestamp() { return timestamp; }
        public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java   |   package br.com.fiap.gs.gsapi.exception   |   class ResourceNotFoundException
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.exception
package br.com.fiap.gs.gsapi.exception; // Pacote corrigido

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }

    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class ClienteMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.model.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(
        componentModel = "spring",
        uses = {ContatoMapper.class, EnderecoMapper.class}, // Garante que os mappers para coleÃ§Ãµes aninhadas sejam usados
        nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE // Ignora campos nulos do DTO ao atualizar a entidade
)
public interface ClienteMapper {

    ClienteMapper INSTANCE = Mappers.getMapper(ClienteMapper.class);

    // Mapeia Entidade Cliente para ClienteResponseDTO
    // MapStruct usarÃ¡ ContatoMapper e EnderecoMapper para as coleÃ§Ãµes contatos e enderecos.
    ClienteResponseDTO toClienteResponseDTO(Cliente cliente);

    List<ClienteResponseDTO> toClienteResponseDTOList(List<Cliente> clientes);

    Set<ClienteResponseDTO> toClienteResponseDTOSet(Set<Cliente> clientes);

    // Mapeia ClienteRequestDTO para Entidade Cliente
    @Mapping(target = "idCliente", ignore = true) // ID Ã© gerado pelo banco e nÃ£o deve vir do request de criaÃ§Ã£o
    @Mapping(target = "contatos", ignore = true)  // AssociaÃ§Ãµes de contatos sÃ£o tratadas na camada de serviÃ§o
    @Mapping(target = "enderecos", ignore = true) // AssociaÃ§Ãµes de endereÃ§os sÃ£o tratadas na camada de serviÃ§o
    Cliente toCliente(ClienteRequestDTO clienteRequestDTO);

    // Para atualizar uma entidade Cliente existente com dados de um ClienteRequestDTO
    // O ID e as associaÃ§Ãµes complexas nÃ£o sÃ£o atualizados diretamente por este mÃ©todo;
    // isso Ã© geralmente tratado pela lÃ³gica de serviÃ§o.
    @Mapping(target = "idCliente", ignore = true)
    @Mapping(target = "contatos", ignore = true)
    @Mapping(target = "enderecos", ignore = true)
    void updateClienteFromDto(ClienteRequestDTO clienteRequestDTO, @MappingTarget Cliente cliente);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class ContatoMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.model.Contato;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring")
public interface ContatoMapper {

    ContatoMapper INSTANCE = Mappers.getMapper(ContatoMapper.class);

    ContatoResponseDTO toContatoResponseDTO(Contato contato);

    List<ContatoResponseDTO> toContatoResponseDTOList(List<Contato> contatos);

    Set<ContatoResponseDTO> toContatoResponseDTOSet(Set<Contato> contatos);

    @Mapping(target = "idContato", ignore = true)
    @Mapping(target = "clientes", ignore = true) // Evitar referÃªncia cÃ­clica ou mapeamento desnecessÃ¡rio
    Contato toContato(ContatoRequestDTO contatoRequestDTO);

    @Mapping(target = "idContato", ignore = true)
    @Mapping(target = "clientes", ignore = true)
    void updateContatoFromDto(ContatoRequestDTO contatoRequestDTO, @MappingTarget Contato contato);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class EnderecoMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.model.Endereco;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring", uses = {EonetEventoMapper.class}) // Supondo EonetEventoMapper
public interface EnderecoMapper {

    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    EnderecoResponseDTO toEnderecoResponseDTO(Endereco endereco);

    List<EnderecoResponseDTO> toEnderecoResponseDTOList(List<Endereco> enderecos);

    Set<EnderecoResponseDTO> toEnderecoResponseDTOSet(Set<Endereco> enderecos);

    @Mapping(target = "idEndereco", ignore = true)
    @Mapping(target = "clientes", ignore = true)
    @Mapping(target = "eonetEventos", ignore = true) // SerÃ¡ tratado no serviÃ§o
    Endereco toEndereco(EnderecoRequestDTO enderecoRequestDTO);

    @Mapping(target = "idEndereco", ignore = true)
    @Mapping(target = "clientes", ignore = true)
    @Mapping(target = "eonetEventos", ignore = true)
    void updateEnderecoFromDto(EnderecoRequestDTO enderecoRequestDTO, @MappingTarget Endereco endereco);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\mapper\EonetEventoMapper.java   |   package br.com.fiap.gs.gsapi.mapper   |   class EonetEventoMapper
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.mapper
package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EonetEventosRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EonetEventoResponseDTO;
import br.com.fiap.gs.gsapi.model.EonetEventos;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring")
public abstract class EonetEventoMapper {

    private static final Logger logger = LoggerFactory.getLogger(EonetEventoMapper.class);
    private final ObjectMapper objectMapper = new ObjectMapper();

    // Mapeia EonetEventosRequestDTO (que vem da sua lÃ³gica de ingestÃ£o) para a Entidade EonetEventos
    @Mapping(target = "idEonet", ignore = true) // PK numÃ©rica interna Ã© gerada pelo banco
    @Mapping(target = "eonetApiId", source = "eonetApiId") // ID original da API EONET
    @Mapping(target = "jsonEvento", source = "jsonEvento") // JSON completo
    @Mapping(target = "data", source = "data") // Data de ingestÃ£o/evento
    @Mapping(target = "enderecosEnvolvidos", ignore = true) // Relacionamento serÃ¡ gerenciado separadamente
    public abstract EonetEventos toEonetEventos(EonetEventosRequestDTO requestDTO);


    // Mapeia Entidade EonetEventos para EonetEventoResponseDTO
    // Aqui Ã© onde vocÃª extrai os dados do CLOB JSON
    @Mapping(target = "idEonet", source = "idEonet")
    @Mapping(target = "eonetApiId", source = "eonetApiId")
    @Mapping(target = "data", source = "data") // Data de ingestÃ£o/evento da sua tabela
    @Mapping(target = "tituloEvento", source = "jsonEvento", qualifiedByName = "jsonToTitulo")
    @Mapping(target = "linkEvento", source = "jsonEvento", qualifiedByName = "jsonToLink")
    @Mapping(target = "dataOcorrenciaOriginalEonet", source = "jsonEvento", qualifiedByName = "jsonToDataOcorrencia")
    @Mapping(target = "categoriaPrincipal", source = "jsonEvento", qualifiedByName = "jsonToCategoriaPrincipal")
    public abstract EonetEventoResponseDTO toEonetEventoResponseDTO(EonetEventos eonetEventos);

    public abstract List<EonetEventoResponseDTO> toEonetEventoResponseDTOList(List<EonetEventos> eonetEventos);

    public abstract Set<EonetEventoResponseDTO> toEonetEventoResponseDTOSet(Set<EonetEventos> eonetEventos);


    // MÃ©todos auxiliares para extrair dados do JSON
    // Estes seriam chamados pelo MapStruct devido ao 'qualifiedByName'

    @Named("jsonToTitulo")
    protected String jsonToTitulo(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode titleNode = rootNode.path("title");
            return titleNode.isMissingNode() ? null : titleNode.asText();
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair tÃ­tulo: {}", e.getMessage());
            return null;
        }
    }

    @Named("jsonToLink")
    protected String jsonToLink(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode linkNode = rootNode.path("link");
            return linkNode.isMissingNode() ? null : linkNode.asText();
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair link: {}", e.getMessage());
            return null;
        }
    }

    @Named("jsonToDataOcorrencia")
    protected Instant jsonToDataOcorrencia(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            // A data de ocorrÃªncia geralmente estÃ¡ dentro do primeiro objeto 'geometries'
            // Isso pode precisar de ajuste dependendo da estrutura exata que vocÃª quer priorizar
            JsonNode geometriesNode = rootNode.path("geometries");
            if (!geometriesNode.isMissingNode() && geometriesNode.isArray() && geometriesNode.size() > 0) {
                JsonNode firstGeometry = geometriesNode.get(0);
                JsonNode dateNode = firstGeometry.path("date");
                if (!dateNode.isMissingNode()) {
                    return Instant.parse(dateNode.asText());
                }
            }
        } catch (JsonProcessingException | DateTimeParseException e) {
            logger.error("Erro ao parsear JSON para extrair data de ocorrÃªncia: {}", e.getMessage());
        }
        return null;
    }

    @Named("jsonToCategoriaPrincipal")
    protected String jsonToCategoriaPrincipal(String jsonEvento) {
        if (jsonEvento == null || jsonEvento.isEmpty()) return null;
        try {
            JsonNode rootNode = objectMapper.readTree(jsonEvento);
            JsonNode categoriesNode = rootNode.path("categories");
            if (!categoriesNode.isMissingNode() && categoriesNode.isArray() && categoriesNode.size() > 0) {
                JsonNode firstCategory = categoriesNode.get(0);
                JsonNode titleNode = firstCategory.path("title");
                return titleNode.isMissingNode() ? null : titleNode.asText();
            }
        } catch (JsonProcessingException e) {
            logger.error("Erro ao parsear JSON para extrair categoria principal: {}", e.getMessage());
        }
        return null;
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\model\Cliente.java   |   package br.com.fiap.gs.gsapi.model   |   class Cliente
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_cliente")
public class Cliente {

    @Id
    // Usando Coluna de Identidade (Oracle 12c+) em vez de Sequence + Trigger explÃ­citos
    // Se o DDL gerado pelo Data Modeler usa Sequence+Trigger, mantenha as anotaÃ§Ãµes @SequenceGenerator e @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Ou GenerationType.SEQUENCE se usar o DDL com sequence/trigger
    @Column(name = "id_cliente")
    private Long idCliente; // Usar Long (wrapper) para IDs Ã© uma boa prÃ¡tica, permite nulo antes da persistÃªncia

    @Column(name = "nome", length = 100, nullable = false)
    private String nome;

    @Column(name = "sobrenome", length = 100, nullable = false)
    private String sobrenome;

    @Column(name = "data_nascimento", length = 10, nullable = false)
    private String dataNascimento; // Para MVP. Ideal: java.time.LocalDate

    @Column(name = "documento", length = 18, nullable = false, unique = true)
    private String documento;

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(name = "gs_clientecontato",
            joinColumns = @JoinColumn(name = "gs_cliente_id_cliente", referencedColumnName = "id_cliente"),
            inverseJoinColumns = @JoinColumn(name = "gs_contato_id_contato", referencedColumnName = "id_contato"))
    private Set<Contato> contatos = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(name = "gs_clienteendereco",
            joinColumns = @JoinColumn(name = "gs_cliente_id_cliente", referencedColumnName = "id_cliente"),
            inverseJoinColumns = @JoinColumn(name = "gs_endereco_id_endereco", referencedColumnName = "id_endereco"))
    private Set<Endereco> enderecos = new HashSet<>();

    public Cliente() {
    }

    public Cliente(String nome, String sobrenome, String dataNascimento, String documento) {
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
        this.documento = documento;
    }

    // Getters e Setters
    public Long getIdCliente() { return idCliente; }
    public void setIdCliente(Long idCliente) { this.idCliente = idCliente; }
    public String getNome() { return nome; }
    public void setNome(String nome) { this.nome = nome; }
    public String getSobrenome() { return sobrenome; }
    public void setSobrenome(String sobrenome) { this.sobrenome = sobrenome; }
    public String getDataNascimento() { return dataNascimento; }
    public void setDataNascimento(String dataNascimento) { this.dataNascimento = dataNascimento; }
    public String getDocumento() { return documento; }
    public void setDocumento(String documento) { this.documento = documento; }
    public Set<Contato> getContatos() { return contatos; }
    public void setContatos(Set<Contato> contatos) { this.contatos = contatos; }
    public Set<Endereco> getEnderecos() { return enderecos; }
    public void setEnderecos(Set<Endereco> enderecos) { this.enderecos = enderecos; }

    // MÃ©todos utilitÃ¡rios para gerenciar coleÃ§Ãµes bidirecionais
    public void addContato(Contato contato) {
        this.contatos.add(contato);
        contato.getClientesInternal().add(this); // Use um mÃ©todo package-private ou protected em Contato
    }
    public void removeContato(Contato contato) {
        this.contatos.remove(contato);
        contato.getClientesInternal().remove(this);
    }
    public void addEndereco(Endereco endereco) {
        this.enderecos.add(endereco);
        endereco.getClientesInternal().add(this);
    }
    public void removeEndereco(Endereco endereco) {
        this.enderecos.remove(endereco);
        endereco.getClientesInternal().remove(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cliente cliente = (Cliente) o;
        // Se o ID Ã© nulo, a igualdade sÃ³ pode ser por referÃªncia de objeto.
        // ApÃ³s a persistÃªncia, o ID Ã© a melhor forma de verificar igualdade.
        return idCliente != null && idCliente.equals(cliente.idCliente);
    }

    @Override
    public int hashCode() {
        // Se o ID Ã© nulo, use o hashCode do objeto.
        // ApÃ³s a persistÃªncia, o ID Ã© a melhor forma.
        return idCliente != null ? Objects.hash(idCliente) : super.hashCode();
    }

    @Override
    public String toString() {
        return "Cliente{" +
                "idCliente=" + idCliente +
                ", nome='" + nome + '\'' +
                ", sobrenome='" + sobrenome + '\'' +
                ", documento='" + documento + '\'' +
                '}';
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\model\Contato.java   |   package br.com.fiap.gs.gsapi.model   |   class Contato
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_contato", uniqueConstraints = {
        @UniqueConstraint(name = "unq_gs_contato_email", columnNames = {"email"}) // Adicionando unique constraint para email
})
public class Contato {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_contato")
    private Long idContato;

    @Column(name = "ddd", length = 3, nullable = false)
    private String ddd;

    @Column(name = "telefone", length = 15, nullable = false)
    private String telefone;

    @Column(name = "celular", length = 15, nullable = false)
    private String celular;

    @Column(name = "whatsapp", length = 15, nullable = false)
    private String whatsapp;

    @Column(name = "email", length = 255, nullable = false)
    private String email;

    @Column(name = "tipo_contato", length = 50, nullable = false)
    private String tipoContato;

    @ManyToMany(mappedBy = "contatos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    public Contato() {
    }

    public Contato(String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    // Getters e Setters
    public Long getIdContato() { return idContato; }
    public void setIdContato(Long idContato) { this.idContato = idContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }

    // MÃ©todo package-private ou protected para ser usado por Cliente
    Set<Cliente> getClientesInternal() {
        return clientes;
    }
    protected void setClientes(Set<Cliente> clientes) { // Protected para JPA e testes, nÃ£o para uso pÃºblico geral
        this.clientes = clientes;
    }


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Contato contato = (Contato) o;
        return idContato != null && idContato.equals(contato.idContato);
    }

    @Override
    public int hashCode() {
        return idContato != null ? Objects.hash(idContato) : super.hashCode();
    }

    @Override
    public String toString() {
        return "Contato{" +
                "idContato=" + idContato +
                ", email='" + email + '\'' +
                ", tipoContato='" + tipoContato + '\'' +
                '}';
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\model\Endereco.java   |   package br.com.fiap.gs.gsapi.model   |   class Endereco
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_endereco")
public class Endereco {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_endereco")
    private Long idEndereco;

    @Column(name = "cep", length = 9, nullable = false)
    private String cep;

    @Column(name = "numero", nullable = false)
    private int numero;

    @Column(name = "logradouro", length = 255, nullable = false)
    private String logradouro;

    @Column(name = "bairro", length = 255, nullable = false)
    private String bairro;

    @Column(name = "localidade", length = 100, nullable = false)
    private String localidade;

    @Column(name = "uf", length = 2, nullable = false)
    private String uf;

    @Column(name = "complemento", length = 255, nullable = false) // Seu DDL tem NOT NULL
    private String complemento;

    @Column(name = "latitude", nullable = false, precision = 10, scale = 7)
    private Double latitude; // Usar Double (wrapper)

    @Column(name = "longitude", nullable = false, precision = 10, scale = 7)
    private Double longitude; // Usar Double (wrapper)

    @ManyToMany(mappedBy = "enderecos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinTable(name = "gs_enderecoeventos",
            joinColumns = @JoinColumn(name = "gs_endereco_id_endereco", referencedColumnName = "id_endereco"),
            inverseJoinColumns = @JoinColumn(name = "gs_eonet_id_eonet", referencedColumnName = "id_eonet")) // Refere-se Ã  PK numÃ©rica de gs_eonet
    private Set<EonetEventos> eonetEventos = new HashSet<>();

    public Endereco() {
    }

    public Endereco(String cep, int numero, String logradouro, String bairro, String localidade, String uf, String complemento, Double latitude, Double longitude) {
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    // Getters e Setters
    public Long getIdEndereco() { return idEndereco; }
    public void setIdEndereco(Long idEndereco) { this.idEndereco = idEndereco; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public int getNumero() { return numero; }
    public void setNumero(int numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public Double getLatitude() { return latitude; }
    public void setLatitude(Double latitude) { this.latitude = latitude; }
    public Double getLongitude() { return longitude; }
    public void setLongitude(Double longitude) { this.longitude = longitude; }

    Set<Cliente> getClientesInternal() { return clientes; }
    protected void setClientes(Set<Cliente> clientes) { this.clientes = clientes; }

    public Set<EonetEventos> getEonetEventos() { return eonetEventos; }
    public void setEonetEventos(Set<EonetEventos> eonetEventos) { this.eonetEventos = eonetEventos; }

    public void addEonetEvento(EonetEventos evento) {
        this.eonetEventos.add(evento);
        evento.getEnderecosEnvolvidosInternal().add(this);
    }
    public void removeEonetEvento(EonetEventos evento) {
        this.eonetEventos.remove(evento);
        evento.getEnderecosEnvolvidosInternal().remove(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Endereco endereco = (Endereco) o;
        return idEndereco != null && idEndereco.equals(endereco.idEndereco);
    }

    @Override
    public int hashCode() {
        return idEndereco != null ? Objects.hash(idEndereco) : super.hashCode();
    }

    @Override
    public String toString() {
        return "Endereco{" +
                "idEndereco=" + idEndereco +
                ", cep='" + cep + '\'' +
                ", logradouro='" + logradouro + '\'' +
                ", numero=" + numero +
                ", localidade='" + localidade + '\'' +
                ", uf='" + uf + '\'' +
                '}';
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\model\EonetEventos.java   |   package br.com.fiap.gs.gsapi.model   |   class EonetEventos
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.*;
import java.time.Instant;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "gs_eonet", uniqueConstraints = {
        @UniqueConstraint(name = "unq_gs_eonet_eonet_api_id", columnNames = {"eonet_id"}) // Nome da coluna no DDL Ã© eonet_id
})
public class EonetEventos {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id_eonet")
    private Long idEonet; // PK numÃ©rica interna

    @Column(name = "eonet_id", length = 50, nullable = false) // ID original da API EONET
    private String eonetApiId;

    @Lob
    @Column(name = "json", columnDefinition = "CLOB") // DDL tem CLOB NULL
    private String jsonEvento;

    @Column(name = "data") // DDL tem TIMESTAMP WITH LOCAL TIME ZONE NULL
    private Instant data;

    @ManyToMany(mappedBy = "eonetEventos", fetch = FetchType.LAZY)
    private Set<Endereco> enderecosEnvolvidos = new HashSet<>();

    public EonetEventos() {
    }

    public EonetEventos(String eonetApiId, String jsonEvento, Instant data) {
        this.eonetApiId = eonetApiId;
        this.jsonEvento = jsonEvento;
        this.data = data;
    }

    // Getters e Setters
    public Long getIdEonet() { return idEonet; }
    public void setIdEonet(Long idEonet) { this.idEonet = idEonet; }
    public String getEonetApiId() { return eonetApiId; }
    public void setEonetApiId(String eonetApiId) { this.eonetApiId = eonetApiId; }
    public String getJsonEvento() { return jsonEvento; }
    public void setJsonEvento(String jsonEvento) { this.jsonEvento = jsonEvento; }
    public Instant getData() { return data; }
    public void setData(Instant data) { this.data = data; }

    Set<Endereco> getEnderecosEnvolvidosInternal() { return enderecosEnvolvidos; }
    protected void setEnderecosEnvolvidos(Set<Endereco> enderecosEnvolvidos) { this.enderecosEnvolvidos = enderecosEnvolvidos; }


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        EonetEventos that = (EonetEventos) o;
        // Chave de negÃ³cio primÃ¡ria Ã© o eonetApiId
        if (eonetApiId != null) {
            return eonetApiId.equals(that.eonetApiId);
        }
        // Se ambos eonetApiId sÃ£o nulos, e os IDs gerados sÃ£o nulos, sÃ£o "iguais" apenas se forem a mesma instÃ¢ncia.
        // Se os IDs gerados existem, eles devem ser usados para comparaÃ§Ã£o.
        return idEonet != null && idEonet.equals(that.idEonet);
    }

    @Override
    public int hashCode() {
        // Chave de negÃ³cio primÃ¡ria Ã© o eonetApiId
        return Objects.hash(eonetApiId);
    }

    @Override
    public String toString() {
        return "EonetEventos{" +
                "idEonet=" + idEonet +
                ", eonetApiId='" + eonetApiId + '\'' +
                ", data=" + data +
                '}';
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class ClienteRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Cliente;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long>, JpaSpecificationExecutor<Cliente> {

    // Exemplo de busca customizada (se necessÃ¡rio)
    Optional<Cliente> findByDocumento(String documento);

    // JpaSpecificationExecutor jÃ¡ permite buscas dinÃ¢micas com Specifications
    // JpaRepository jÃ¡ oferece:
    // - save, saveAll
    // - findById, findAll, findAllById
    // - delete, deleteAll, deleteById
    // - count
    // - existsById
    // - findAll(Sort sort)
    // - findAll(Pageable pageable) -> para paginaÃ§Ã£o
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class ContatoRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Contato;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ContatoRepository extends JpaRepository<Contato, Long> {

    Optional<Contato> findByEmail(String email);
    // Adicione outros mÃ©todos de busca customizados se necessÃ¡rio
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class EnderecoRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Endereco;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor; // Adicionar se precisar de buscas dinÃ¢micas para Endereco
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface EnderecoRepository extends JpaRepository<Endereco, Long>, JpaSpecificationExecutor<Endereco> { // Adicionado JpaSpecificationExecutor

    // MÃ©todo para buscar um endereÃ§o pelo CEP
    List<Endereco> findByCep(String cep);

    // MÃ©todo para buscar um endereÃ§o pelo CEP e nÃºmero (NECESSÃRIO PARA EnderecoGeocodingService)
    Optional<Endereco> findByCepAndNumero(String cep, int numero);

    // Adicione outros mÃ©todos de busca customizados se necessÃ¡rio
    // Exemplo: buscar endereÃ§os por UF
    // List<Endereco> findByUf(String uf);

    // Exemplo: buscar endereÃ§os por localidade (cidade)
    // List<Endereco> findByLocalidadeIgnoreCase(String localidade);
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\repository\EonetEventoRepository.java   |   package br.com.fiap.gs.gsapi.repository   |   class EonetEventoRepository
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.repository
package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.EonetEventos;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.Optional;

@Repository
public interface EonetEventoRepository extends JpaRepository<EonetEventos, Long> {

    // Busca pelo ID original da API EONET (que Ã© Ãºnico)
    Optional<EonetEventos> findByEonetApiId(String eonetApiId);

    // Exemplo de busca por eventos dentro de um perÃ­odo de data (usando a coluna 'data' da sua tabela)
    Page<EonetEventos> findByDataBetween(Instant dataInicio, Instant dataFim, Pageable pageable);

    // Exemplo de como vocÃª poderia buscar eventos cujo JSON contenha um certo tÃ­tulo
    // ATENÃ‡ÃƒO: Buscas diretas em CLOB JSON podem ser menos performÃ¡ticas.
    // O ideal Ã© ter campos extraÃ­dos e indexados para filtros comuns.
    // Esta Ã© uma query nativa para Oracle como exemplo, pode precisar de ajustes.
    @Query(value = "SELECT * FROM gs_eonet e WHERE JSON_VALUE(e.json, '$.title') LIKE %:titulo%", nativeQuery = true)
    Page<EonetEventos> findByJsonTitleContaining(@Param("titulo") String titulo, Pageable pageable);

}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\service\ClienteService.java   |   package br.com.fiap.gs.gsapi.service   |   class ClienteService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.ClienteMapper;
import br.com.fiap.gs.gsapi.model.Cliente;
import br.com.fiap.gs.gsapi.model.Contato; // Assumindo que vocÃª pode querer associar/criar contatos
import br.com.fiap.gs.gsapi.model.Endereco; // Assumindo que vocÃª pode querer associar/criar endereÃ§os
import br.com.fiap.gs.gsapi.repository.ClienteRepository;
import br.com.fiap.gs.gsapi.repository.ContatoRepository;
import br.com.fiap.gs.gsapi.repository.EnderecoRepository;
import br.com.fiap.gs.gsapi.service.search.ClienteSearchCriteria;
import br.com.fiap.gs.gsapi.service.search.ClienteSpecification;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@CacheConfig(cacheNames = "clientes") // Define um nome de cache padrÃ£o para os mÃ©todos desta classe
public class ClienteService {

    private final ClienteRepository clienteRepository;
    private final ContatoRepository contatoRepository; // Para buscar contatos existentes
    private final EnderecoRepository enderecoRepository; // Para buscar endereÃ§os existentes
    private final ClienteMapper clienteMapper;

    @Autowired
    public ClienteService(ClienteRepository clienteRepository,
                          ContatoRepository contatoRepository,
                          EnderecoRepository enderecoRepository,
                          ClienteMapper clienteMapper) {
        this.clienteRepository = clienteRepository;
        this.contatoRepository = contatoRepository;
        this.enderecoRepository = enderecoRepository;
        this.clienteMapper = clienteMapper;
    }

    @Transactional(readOnly = true)
    // Chave de cache mais robusta, incluindo hashCode dos critÃ©rios se nÃ£o nulos
    @Cacheable(key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString() + '-' + T(java.util.Objects).hashCode(#criteria)")
    public Page<ClienteResponseDTO> listarTodos(ClienteSearchCriteria criteria, Pageable pageable) {
        Specification<Cliente> spec = ClienteSpecification.fromCriteria(criteria);
        Page<Cliente> clientesPage = clienteRepository.findAll(spec, pageable);
        return clientesPage.map(clienteMapper::toClienteResponseDTO);
    }

    @Transactional(readOnly = true)
    @Cacheable(key = "#id")
    public ClienteResponseDTO buscarPorId(Long id) {
        Cliente cliente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente nÃ£o encontrado com ID: " + id));
        return clienteMapper.toClienteResponseDTO(cliente);
    }

    @Transactional
    @CacheEvict(allEntries = true)
    public ClienteResponseDTO criar(ClienteRequestDTO clienteRequestDTO) {
        // ValidaÃ§Ã£o de documento Ãºnico
        clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).ifPresent(c -> {
            throw new IllegalArgumentException("Cliente com o documento '" + clienteRequestDTO.getDocumento() + "' jÃ¡ existe.");
        });

        Cliente cliente = clienteMapper.toCliente(clienteRequestDTO);

        // LÃ³gica para associar contatos e endereÃ§os (exemplo)
        // Se o ClienteRequestDTO contiver IDs de contatos/endereÃ§os existentes para associar:
        // Set<Long> idsContatos = clienteRequestDTO.getIdsContatos(); // Supondo que o DTO tenha isso
        // if (idsContatos != null && !idsContatos.isEmpty()) {
        //     Set<Contato> contatosParaAssociar = new HashSet<>(contatoRepository.findAllById(idsContatos));
        //     if(contatosParaAssociar.size() != idsContatos.size()){
        //          throw new ResourceNotFoundException("Um ou mais contatos nÃ£o encontrados para associaÃ§Ã£o.");
        //     }
        //     cliente.setContatos(contatosParaAssociar);
        //     // Para relacionamento bidirecional, vocÃª tambÃ©m pode precisar adicionar o cliente ao contato
        //     // contatosParaAssociar.forEach(contato -> contato.getClientes().add(cliente));
        // }
        // LÃ³gica similar para endereÃ§os

        Cliente clienteSalvo = clienteRepository.save(cliente);
        return clienteMapper.toClienteResponseDTO(clienteSalvo);
    }

    @Transactional
    @CachePut(key = "#id")
    @CacheEvict(allEntries = true, condition = "#result != null")
    public ClienteResponseDTO atualizar(Long id, ClienteRequestDTO clienteRequestDTO) {
        Cliente clienteExistente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente nÃ£o encontrado com ID: " + id));

        if (clienteRequestDTO.getDocumento() != null && !clienteExistente.getDocumento().equals(clienteRequestDTO.getDocumento())) {
            clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).ifPresent(c -> {
                if (c.getIdCliente() != id) {
                    throw new IllegalArgumentException("Outro cliente com o documento '" + clienteRequestDTO.getDocumento() + "' jÃ¡ existe.");
                }
            });
        }

        clienteMapper.updateClienteFromDto(clienteRequestDTO, clienteExistente);

        // LÃ³gica mais complexa para atualizar coleÃ§Ãµes (contatos, endereÃ§os)
        // Ex: remover os que nÃ£o estÃ£o mais no DTO, adicionar os novos.
        // Isso geralmente requer uma lÃ³gica mais detalhada do que um simples mapeamento.

        Cliente clienteAtualizado = clienteRepository.save(clienteExistente);
        return clienteMapper.toClienteResponseDTO(clienteAtualizado);
    }

    @Transactional
    @CacheEvict(allEntries = true) // Invalida todos os caches de "clientes"
    public void deletar(Long id) {
        if (!clienteRepository.existsById(id)) {
            throw new ResourceNotFoundException("Cliente nÃ£o encontrado com ID: " + id + " para exclusÃ£o.");
        }
        // Considerar a lÃ³gica de desassociaÃ§Ã£o ou remoÃ§Ã£o em cascata configurada nas entidades
        clienteRepository.deleteById(id);
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\service\EnderecoGeocodingService.java   |   package br.com.fiap.gs.gsapi.service   |   class EnderecoGeocodingService
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.service
package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.client.NominatimClient;
import br.com.fiap.gs.gsapi.client.ViaCepClient;
import br.com.fiap.gs.gsapi.dto.geocoding.NominatimResponseDTO;
import br.com.fiap.gs.gsapi.dto.viacep.ViaCepResponseDTO;
import br.com.fiap.gs.gsapi.model.Endereco; // Sua entidade Endereco
import br.com.fiap.gs.gsapi.repository.EnderecoRepository; // Seu repositÃ³rio
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Service
public class EnderecoGeocodingService {

    private static final Logger logger = LoggerFactory.getLogger(EnderecoGeocodingService.class);

    private final ViaCepClient viaCepClient;
    private final NominatimClient nominatimClient;
    private final EnderecoRepository enderecoRepository;

    @Autowired
    public EnderecoGeocodingService(ViaCepClient viaCepClient,
                                    NominatimClient nominatimClient,
                                    EnderecoRepository enderecoRepository) {
        this.viaCepClient = viaCepClient;
        this.nominatimClient = nominatimClient;
        this.enderecoRepository = enderecoRepository;
    }

    /**
     * Busca o endereÃ§o completo (com lat/lon) a partir de um CEP e nÃºmero.
     * Se o endereÃ§o jÃ¡ existir no banco com coordenadas, retorna o existente.
     * Caso contrÃ¡rio, busca no ViaCEP, depois no Nominatim, e salva/atualiza no banco.
     *
     * @param cep O CEP a ser consultado.
     * @param numero O nÃºmero do endereÃ§o (para geocodificaÃ§Ã£o mais precisa).
     * @param complemento O complemento do endereÃ§o (opcional).
     * @return Um Optional contendo a entidade Endereco com os dados e coordenadas, ou Optional.empty() se nÃ£o encontrado/falha.
     */
    @Transactional
    public Optional<Endereco> obterOuCriarEnderecoCompleto(String cep, String numeroStr, String complemento) {
        String cepNumerico = cep.replaceAll("[^0-9]", "");

        // Tenta buscar no banco um endereÃ§o que jÃ¡ possa ter sido geocodificado
        // Esta lÃ³gica de busca pode precisar ser mais sofisticada (ex: por um ID de cliente se for um update)
        // Por enquanto, vamos assumir que se o CEP e nÃºmero batem, Ã© o mesmo endereÃ§o.
        // Em um cenÃ¡rio real, vocÃª pode ter um ID de endereÃ§o se ele jÃ¡ existir.
        Optional<Endereco> enderecoExistente = enderecoRepository.findByCepAndNumero(cepNumerico, parseNumero(numeroStr));

        if (enderecoExistente.isPresent() && enderecoExistente.get().getLatitude() != 0 && enderecoExistente.get().getLongitude() != 0) {
            logger.info("EndereÃ§o encontrado no banco com coordenadas para CEP {} e NÃºmero {}. ID: {}", cepNumerico, numeroStr, enderecoExistente.get().getIdEndereco());
            // Se o complemento mudou, atualize
            if (complemento != null && !complemento.equals(enderecoExistente.get().getComplemento())) {
                enderecoExistente.get().setComplemento(complemento);
                return Optional.of(enderecoRepository.save(enderecoExistente.get()));
            }
            return enderecoExistente;
        }

        logger.info("Buscando dados no ViaCEP para CEP: {}", cepNumerico);
        ViaCepResponseDTO viaCepData = viaCepClient.buscarEnderecoPorCep(cepNumerico);

        if (viaCepData == null || viaCepData.isErro()) {
            logger.warn("NÃ£o foi possÃ­vel obter dados do ViaCEP para o CEP: {}", cepNumerico);
            return Optional.empty();
        }

        // Prepara a entidade Endereco (nova ou a existente sem coordenadas)
        Endereco enderecoParaSalvar = enderecoExistente.orElseGet(Endereco::new);
        mapearViaCepParaEndereco(viaCepData, numeroStr, complemento, enderecoParaSalvar);

        // Tenta obter coordenadas do Nominatim
        // Lembre-se da polÃ­tica de uso do Nominatim (1 req/seg)
        // Em uma aplicaÃ§Ã£o real, adicione um delay aqui se for chamar em loop.
        try {
            Thread.sleep(1000); // Delay de 1 segundo para respeitar o limite do Nominatim
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("Thread interrompida enquanto esperava para chamar Nominatim.", e);
        }

        NominatimResponseDTO nominatimResponse = nominatimClient.buscarCoordenadasPorEndereco(
                enderecoParaSalvar.getLogradouro(),
                String.valueOf(enderecoParaSalvar.getNumero()), // Passa o nÃºmero jÃ¡ parseado
                enderecoParaSalvar.getBairro(),
                enderecoParaSalvar.getLocalidade(),
                enderecoParaSalvar.getUf(),
                enderecoParaSalvar.getCep()
        ).blockFirst(); // Cuidado com blockFirst() em ambientes totalmente reativos. Considere alternativas.

        if (nominatimResponse != null && nominatimResponse.getLatitude() != null && nominatimResponse.getLongitude() != null) {
            try {
                enderecoParaSalvar.setLatitude(Double.parseDouble(nominatimResponse.getLatitude()));
                enderecoParaSalvar.setLongitude(Double.parseDouble(nominatimResponse.getLongitude()));
                logger.info("Coordenadas obtidas do Nominatim para CEP {}: Lat={}, Lon={}", cepNumerico, enderecoParaSalvar.getLatitude(), enderecoParaSalvar.getLongitude());
            } catch (NumberFormatException e) {
                logger.error("Erro ao converter coordenadas do Nominatim de String para Double: Lat={}, Lon={}",
                        nominatimResponse.getLatitude(), nominatimResponse.getLongitude(), e);
                // Decide se quer salvar sem coordenadas ou retornar erro
            }
        } else {
            logger.warn("NÃ£o foi possÃ­vel obter coordenadas do Nominatim para o endereÃ§o do CEP: {}", cepNumerico);
        }

        try {
            Endereco enderecoSalvo = enderecoRepository.save(enderecoParaSalvar);
            return Optional.of(enderecoSalvo);
        } catch (Exception e) {
            logger.error("Erro ao salvar endereÃ§o para CEP {}: {}", cepNumerico, e.getMessage(), e);
            return Optional.empty();
        }
    }

    private void mapearViaCepParaEndereco(ViaCepResponseDTO viaCepData, String numeroStr, String complemento, Endereco endereco) {
        endereco.setCep(viaCepData.getCep().replaceAll("[^0-9]", ""));
        endereco.setLogradouro(viaCepData.getLogradouro());
        endereco.setBairro(viaCepData.getBairro());
        endereco.setLocalidade(viaCepData.getLocalidade());
        endereco.setUf(viaCepData.getUf());
        if (numeroStr != null && !numeroStr.trim().isEmpty()) {
            endereco.setNumero(parseNumero(numeroStr));
        }
        endereco.setComplemento(complemento != null ? complemento : (viaCepData.getComplemento() != null ? viaCepData.getComplemento() : ""));
    }

    private int parseNumero(String numeroStr) {
        if (numeroStr == null || numeroStr.trim().isEmpty()) return 0; // Ou lance exceÃ§Ã£o, ou defina um padrÃ£o
        try {
            return Integer.parseInt(numeroStr.replaceAll("[^0-9]", ""));
        } catch (NumberFormatException e) {
            logger.warn("NÃºmero de endereÃ§o invÃ¡lido fornecido: '{}'. Usando 0.", numeroStr);
            return 0; // Ou lance exceÃ§Ã£o
        }
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\service\search\ClienteSearchCriteria.java   |   package br.com.fiap.gs.gsapi.service.search   |   class ClienteSearchCriteria
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.service.search;

import java.util.Objects;

// Classe simples para encapsular critÃ©rios de busca para Cliente
public class ClienteSearchCriteria {
    private String nome;
    private String documento;
    private String dataNascimento; // Poderia ser LocalDate se o DTO e a entidade usassem

    public ClienteSearchCriteria() {
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public String getDataNascimento() {
        return dataNascimento;
    }

    public void setDataNascimento(String dataNascimento) {
        this.dataNascimento = dataNascimento;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ClienteSearchCriteria that = (ClienteSearchCriteria) o;
        return Objects.equals(nome, that.nome) &&
                Objects.equals(documento, that.documento) &&
                Objects.equals(dataNascimento, that.dataNascimento);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nome, documento, dataNascimento);
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\service\search\ClienteSpecification.java   |   package br.com.fiap.gs.gsapi.service.search   |   class ClienteSpecification
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.service.search;

import br.com.fiap.gs.gsapi.model.Cliente;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils; // Para StringUtils.hasText

import java.util.ArrayList;
import java.util.List;

public class ClienteSpecification {

    public static Specification<Cliente> fromCriteria(ClienteSearchCriteria criteria) {
        return (root, query, criteriaBuilder) -> {
            if (criteria == null) {
                return criteriaBuilder.conjunction(); // Retorna uma condiÃ§Ã£o sempre verdadeira se nÃ£o houver critÃ©rios
            }

            List<Predicate> predicates = new ArrayList<>();

            if (StringUtils.hasText(criteria.getNome())) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("nome")), "%" + criteria.getNome().toLowerCase() + "%"));
            }
            if (StringUtils.hasText(criteria.getDocumento())) {
                predicates.add(criteriaBuilder.equal(root.get("documento"), criteria.getDocumento()));
            }
            if (StringUtils.hasText(criteria.getDataNascimento())) {
                // Se dataNascimento fosse LocalDate, a comparaÃ§Ã£o seria diferente
                // Ex: criteriaBuilder.equal(root.get("dataNascimento"), criteria.getDataNascimentoAsLocalDate());
                predicates.add(criteriaBuilder.equal(root.get("dataNascimento"), criteria.getDataNascimento()));
            }
            // Adicione outros predicados para outros campos de busca

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
// main\java\br\com\fiap\gs\gsapi\service\search\ContatoSearchCriteria.java   |   package br.com.fiap.gs.gsapi.service.search   |   class ContatoSearchCriteria
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•

// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.service.search;

import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.Objects;

public class ContatoSearchCriteria {
    private String email;
    private String tipoContato;
    private String ddd;

    // Construtor padrÃ£o, Getters e Setters
    public ContatoSearchCriteria() {}

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ContatoSearchCriteria that = (ContatoSearchCriteria) o;
        return Objects.equals(email, that.email) &&
                Objects.equals(tipoContato, that.tipoContato) &&
                Objects.equals(ddd, that.ddd);
    }

    @Override
    public int hashCode() {
        return Objects.hash(email, tipoContato, ddd);
    }
}
```java
// Pacote: br.com.fiap.gs.gsapi.service.search
package br.com.fiap.gs.gsapi.service.search;

import br.com.fiap.gs.gsapi.model.Contato;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.StringUtils;

import java.util.ArrayList;
import java.util.List;

public class ContatoSpecification {

    public static Specification<Contato> fromCriteria(ContatoSearchCriteria criteria) {
        return (root, query, criteriaBuilder) -> {
            if (criteria == null) {
                return criteriaBuilder.conjunction();
            }
            List<Predicate> predicates = new ArrayList<>();

            if (StringUtils.hasText(criteria.getEmail())) {
                predicates.add(criteriaBuilder.like(criteriaBuilder.lower(root.get("email")), "%" + criteria.getEmail().toLowerCase() + "%"));
            }
            if (StringUtils.hasText(criteria.getTipoContato())) {
                predicates.add(criteriaBuilder.equal(criteriaBuilder.lower(root.get("tipoContato")), criteria.getTipoContato().toLowerCase()));
            }
            if (StringUtils.hasText(criteria.getDdd())) {
                predicates.add(criteriaBuilder.equal(root.get("ddd"), criteria.getDdd()));
            }
            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }
}

