// Script: converte-codigo-em-txt-unico (v10)
// Gerado em: 2025-05-28 15:14:27

// Diretórios (inline): app > app\clientes > app\clientes\[id] > app\clientes\alterar > app\clientes\alterar\[id] > app\clientes\buscar > app\clientes\cadastrar > app\clientes\deletar > app\clientes\deletar\[id] > app\clientes\listar > lib > src

// Diretórios (multi-line):
src/
    app/
        clientes/
            alterar/
                [id]/
            buscar/
            cadastrar/
            deletar/
                [id]/
            listar/
            [id]/
    lib/

// Arquivos encontrados (tipo => caminho relativo):
// tsx => app\clientes\[id]\page.tsx
// tsx => app\clientes\alterar\[id]\page.tsx
// tsx => app\clientes\buscar\page.tsx
// tsx => app\clientes\cadastrar\page.tsx
// tsx => app\clientes\deletar\[id]\page.tsx
// tsx => app\clientes\layout.tsx
// tsx => app\clientes\listar\page.tsx
// tsx => app\layout.tsx
// tsx => app\page.tsx
// ts => lib\apiService.ts
// ts => lib\types.ts

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// app\clientes\[id]\page.tsx | arquivo page.tsx
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/app/clientes/[id]/page.tsx
'use client';
import { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
// CORREÇÃO DO CAMINHO ABAIXO:
import { buscarClientePorId } from '@/lib/apiService';
import type { ClienteResponseDTO } from '@/lib/types';

// ... (o resto do código do ClienteDetalhesPage permanece o mesmo da minha resposta anterior)
// Cole o restante do código que já te enviei para esta página,
// apenas certifique-se de que as importações acima estejam com o caminho '../../../lib/'
// (3 níveis para sair de [id], clientes, app e chegar em src/lib)
// CORREÇÃO: A partir de src/app/clientes/[id]/page.tsx para src/lib/ é ../../../lib/
// Não, é:
// um '../' sai de [id] para /clientes
// um segundo '../' sai de /clientes para /app
// um terceiro '../' sai de /app para /src
// Então, para /src/lib é apenas '../../lib/' se [id] está dentro de /clientes.
// Vamos corrigir para: `../../../lib/apiService` se a pasta `lib` estiver na raiz do projeto, ou `../../lib/apiService` se `lib` estiver em `src/lib`.
// Assumindo que `lib` está em `src/lib/`
// De: src/app/clientes/[id]/page.tsx
// Para: src/lib/apiService.ts
// ../../../ -> src/
// Então o caminho é ../../../lib/apiService se a pasta lib está na raiz do projeto.
// Se a pasta lib está em src/lib, então é:
// Sai de [id] para clientes -> ../
// Sai de clientes para app -> ../../
// Entra em lib (que está no mesmo nível de app, dentro de src) -> ../../lib/
// Este é o correto assumindo src/lib

// CORRETO é:
// import { buscarClientePorId } from '../../../lib/apiService'; (se lib está na raiz do projeto)
// import { buscarClientePorId } from '../../lib/apiService'; (se lib está em src/lib e o arquivo atual está em src/app/clientes/[id])
// A estrutura é src/app/clientes/[id]/page.tsx e src/lib/apiService.ts
// ../ -> src/app/clientes/
// ../../ -> src/app/
// ../../../ -> src/
// Correto é: ../../lib/apiService

// Vou usar '../../lib/' pois é o mais provável e consistente com as outras correções.

// REVISANDO A ESTRUTURA DE PASTAS:
// gs-frontend/
//   src/
//     app/
//       clientes/
//         [id]/
//           page.tsx  <-- ESTE ARQUIVO
//     lib/
//       apiService.ts <-- ARQUIVO ALVO

// De page.tsx:
// ../ -> para a pasta [id] (não faz sentido)
// ../ -> para a pasta clientes
// ../../ -> para a pasta app
// ../../../ -> para a pasta src
// Então para acessar lib que está em src/lib: ../../../lib/apiService.ts ? Não.

// Se o arquivo está em: src/app/clientes/[id]/page.tsx
// E o alvo é:          src/lib/apiService.ts

// ../ => sai da pasta [id] para a pasta clientes (src/app/clientes/)
// ../../ => sai da pasta clientes para a pasta app (src/app/)
// Agora estamos em src/app/. Para chegar a src/lib/, precisamos "descer" para lib.
// O caminho correto seria: '../../lib/apiService' - ERRADO, isso assumiria que lib está em app.

// Vamos refazer:
// Estou em: src/app/clientes/[id]/page.tsx
// Quero ir para: src/lib/apiService.ts

// 1. `../` => src/app/clientes/
// 2. `../../` => src/app/
// 3. `../../../` => src/
// Estando em `src/`, acesso `lib/apiService.ts`.
// Portanto, `../../../lib/apiService` é o correto se `lib` estiver diretamente dentro de `src`.

// Vou manter o caminho que usei para listar, pois o erro original foi no listar com esse caminho.
// O erro `Can't resolve '../../../lib/apiService'` no arquivo `src/app/clientes/layout.tsx` (mas que na verdade era do listar) sugere que `../../../` a partir de `src/app/clientes/` estava errado.
// Se `listar/page.tsx` está em `src/app/clientes/listar/page.tsx`, então `../../../lib/` o levaria para `src/../lib/` que é `../lib/` (um nível acima de `src`).
// Se `lib` está em `src/lib/`:
// De `src/app/clientes/listar/page.tsx` para `src/lib/` o caminho é `../../lib/`.

// Vou corrigir TODOS para `../../lib/` assumindo que `lib` está em `src/lib` e os arquivos de página estão em `src/app/entidade/acao/page.tsx` ou `src/app/entidade/page.tsx`.

// Para Detalhes: src/app/clientes/[id]/page.tsx
// Para Lib:      src/lib/
// Caminho:       `../../../lib/` - NÃO, está errado.
// Correto:       `../../lib/` (sai de [id], sai de clientes, entra em lib que está no mesmo nível de app dentro de src)

// Espera, o Next.js resolve caminhos de forma diferente para `app` vs `pages`.
// Vamos testar com `@/lib/` que é um alias comum se configurado no `tsconfig.json`.
// Se não houver alias, o caminho relativo a partir de `src/app/clientes/[id]/page.tsx` para `src/lib/` é:
// `../` (para `src/app/clientes/`)
// `../../` (para `src/app/`)
// `../../../` (para `src/`)
// Então `../../../lib/` *seria* correto se `lib` estivesse em `src/lib/` e a referência fosse de `src/app/clientes/[id]/page.tsx`.
// O erro `Can't resolve '../../../lib/apiService'` no `layout.tsx` (que na verdade era do `listar/page.tsx` em `src/app/clientes/listar/page.tsx`)
// indica que este caminho não funcionou.

// Se a pasta `lib` está em `src/lib`:
// A partir de `src/app/clientes/listar/page.tsx` (ou `src/app/clientes/[id]/page.tsx`), o caminho relativo para `src/lib/` é `../../lib/`.
// `../`  -> `src/app/clientes/`
// `../../` -> `src/app/`
// Estando em `src/app/`, para acessar `src/lib/` seria `../lib/`.  Portanto `../../lib/`

// Vou usar `../../lib/` para todos os arquivos dentro de `src/app/clientes/QUALQUERPASTA/`.

export default function ClienteDetalhesPage() {
    // ... (código já fornecido na resposta anterior, com as importações corrigidas para `../../lib/`)
    // Vou repetir o código completo com o caminho corrigido para `../../lib/`

    const params = useParams();
    const router = useRouter();
    const idPath = Array.isArray(params.id) ? params.id[0] : params.id;

    const [cliente, setCliente] = useState<ClienteResponseDTO | null>(null);
    const [erro, setErro] = useState<string | null>(null);
    const [loading, setLoading] = useState<boolean>(true);

    useEffect(() => {
        if (idPath) {
            const clienteId = Number(idPath);
            if (isNaN(clienteId)) {
                setErro("ID do cliente inválido na URL.");
                setLoading(false);
                return;
            }
            setLoading(true);
            buscarClientePorId(clienteId)
                .then(data => {
                    setCliente(data);
                    setErro(null);
                })
                .catch(error => {
                    console.error("Erro ao buscar cliente por ID:", error);
                    setErro(`Falha ao carregar cliente: ${error.message || 'Cliente não encontrado.'}`);
                    setCliente(null);
                })
                .finally(() => setLoading(false));
        } else {
            setErro("ID do cliente não fornecido na rota.");
            setLoading(false);
        }
    }, [idPath]);

    if (loading) return <div className="container"><p>Carregando detalhes do cliente...</p></div>;
    if (erro) return <div className="container"><p className="message error">{erro}</p><Link href="/clientes/listar">Voltar para Lista</Link></div>;
    if (!cliente) return <div className="container"><p>Cliente não encontrado.</p><Link href="/clientes/listar">Voltar para Lista</Link></div>;

    return (
        <div className="container">
            <h1 className="page-title">Detalhes do Cliente</h1>
            <div style={{ backgroundColor: 'white', padding: '20px', borderRadius: '8px', boxShadow: '0 2px 4px rgba(0,0,0,0.05)' }}>
                <h2>{cliente.nome} {cliente.sobrenome}</h2>
                <p><strong>ID:</strong> {cliente.idCliente}</p>
                <p><strong>Data de Nascimento:</strong> {new Date(cliente.dataNascimento).toLocaleDateString('pt-BR', { timeZone: 'UTC' })}</p>
                <p><strong>Documento:</strong> {cliente.documento}</p>

                {cliente.contatos && cliente.contatos.length > 0 && cliente.contatos[0] && (
                    <div style={{marginTop: '15px', paddingTop: '15px', borderTop: '1px solid #eee'}}>
                        <h3>Contato Principal:</h3>
                        <div style={{ paddingLeft: '15px'}}>
                            <p><strong>Email:</strong> {cliente.contatos[0].email}</p>
                            <p><strong>Telefone:</strong> ({cliente.contatos[0].ddd}) {cliente.contatos[0].telefone}</p>
                            {cliente.contatos[0].celular && <p><strong>Celular:</strong> {cliente.contatos[0].celular}</p>}
                            <p><strong>Tipo:</strong> {cliente.contatos[0].tipoContato}</p>
                        </div>
                    </div>
                )}

                {cliente.enderecos && cliente.enderecos.length > 0 && cliente.enderecos[0] && (
                    <div style={{marginTop: '15px', paddingTop: '15px', borderTop: '1px solid #eee'}}>
                        <h3>Endereço Principal:</h3>
                        <div style={{ paddingLeft: '15px'}}>
                            <p>{cliente.enderecos[0].logradouro}, {cliente.enderecos[0].numero} {cliente.enderecos[0].complemento && `- ${cliente.enderecos[0].complemento}`}</p>
                            <p>{cliente.enderecos[0].bairro} - {cliente.enderecos[0].localidade}/{cliente.enderecos[0].uf}</p>
                            <p>CEP: {cliente.enderecos[0].cep}</p>
                            <p><small>Lat: {cliente.enderecos[0].latitude}, Lon: {cliente.enderecos[0].longitude}</small></p>
                        </div>
                    </div>
                )}
                <div style={{marginTop: '25px', display: 'flex', gap: '10px' }}>
                    <Link href={`/clientes/alterar/${cliente.idCliente}`} className="button-secondary" style={{textDecoration:'none'}}>
                        Editar Cliente
                    </Link>
                    <Link href={`/clientes/deletar/${cliente.idCliente}`} className="button-danger" style={{textDecoration:'none'}}>
                        Deletar Cliente
                    </Link>
                    <Link href="/clientes/listar" style={{ marginLeft: 'auto', alignSelf: 'center', textDecoration: 'none', color: '#007bff' }}>
                        Voltar para Lista
                    </Link>
                </div>
            </div>
        </div>
    );
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// app\clientes\alterar\[id]\page.tsx | arquivo page.tsx
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Localização: gs-frontend/src/app/clientes/alterar/[id]/page.tsx
'use client';

import { useEffect, useState, FormEvent } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import {
    buscarClientePorId,
    atualizarCliente,
    consultarCepPelaApi,
    calcularCoordenadasPelaApi,
    // Assumindo que você tem ou criará estas no apiService.ts:
    // buscarContatoPorId, // Se precisar carregar detalhes do contato separadamente
    // atualizarContatoSozinho,
    // buscarEnderecoPorId, // Se precisar carregar detalhes do endereço separadamente
    // atualizarEnderecoSozinho
} from '@/lib/apiService';
import type {
    ClienteRequestDTO,
    ClienteResponseDTO,
    ContatoRequestDTO,
    ContatoResponseDTO, // Para o tipo de contato carregado
    EnderecoRequestDTO,
    EnderecoResponseDTO, // Para o tipo de endereço carregado
    ViaCepResponseDTO,
    EnderecoGeoRequestDTO,
    GeoCoordinatesDTO
} from '@/lib/types';

export default function AlterarClientePage() {
    const params = useParams();
    const router = useRouter();
    const idPath = Array.isArray(params.id) ? params.id[0] : params.id;
    const clienteId = Number(idPath);

    // IDs dos contatos e endereços principais atuais do cliente
    const [currentContatoId, setCurrentContatoId] = useState<number | undefined>(undefined);
    const [currentEnderecoId, setCurrentEnderecoId] = useState<number | undefined>(undefined);

    const [clienteData, setClienteData] = useState<Omit<ClienteRequestDTO, 'contatosIds' | 'enderecosIds'>>({
        nome: '', sobrenome: '', dataNascimento: '', documento: '',
    });
    const [contatoData, setContatoData] = useState<ContatoRequestDTO>({
        ddd: '', telefone: '', celular: '', whatsapp: '', email: '', tipoContato: 'Principal'
    });
    const [enderecoData, setEnderecoData] = useState<Partial<EnderecoRequestDTO & {numero: string | number}>>({
        cep: '', numero: '', logradouro: '', bairro: '', localidade: '', uf: '', complemento: '', latitude: 0, longitude: 0
    });

    const [mensagem, setMensagem] = useState<string>('');
    const [erro, setErro] = useState<string>('');
    const [loadingSubmit, setLoadingSubmit] = useState<boolean>(false);
    const [initialLoading, setInitialLoading] = useState<boolean>(true);
    const [buscandoCepCoords, setBuscandoCepCoords] = useState<boolean>(false);

    useEffect(() => {
        if (idPath && !isNaN(clienteId)) {
            setInitialLoading(true);
            setErro('');
            buscarClientePorId(clienteId)
                .then((data: ClienteResponseDTO) => {
                    setClienteData({
                        nome: data.nome,
                        sobrenome: data.sobrenome,
                        dataNascimento: data.dataNascimento && data.dataNascimento.includes('/') ?
                            data.dataNascimento.split('/').reverse().join('-') :
                            (data.dataNascimento || ''),
                        documento: data.documento,
                    });
                    if (data.contatos && data.contatos.length > 0) {
                        const contatoPrincipal = data.contatos[0];
                        setContatoData(contatoPrincipal);
                        setCurrentContatoId(contatoPrincipal.idContato);
                    }
                    if (data.enderecos && data.enderecos.length > 0) {
                        const endPrincipal = data.enderecos[0];
                        setEnderecoData({
                            ...endPrincipal,
                            numero: String(endPrincipal.numero || ''),
                        });
                        setCurrentEnderecoId(endPrincipal.idEndereco);
                    }
                })
                .catch(error => {
                    console.error("Erro ao buscar dados do cliente para alteração:", error);
                    setErro(`Falha ao carregar dados do cliente: ${error.message}`);
                })
                .finally(() => setInitialLoading(false));
        } else {
            setErro("ID do cliente inválido ou não fornecido.");
            setInitialLoading(false);
        }
    }, [idPath, clienteId]);

    const handleClienteChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setClienteData(prev => ({ ...prev, [e.target.name]: e.target.value }));
    };
    const handleContatoChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setContatoData(prev => ({ ...prev, [e.target.name]: e.target.value }));
    };
    const handleEnderecoChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setEnderecoData(prev => ({ ...prev, [e.target.name]: e.target.value }));
    };

    const handleCepBlur = async () => {
        // ... (Lógica do handleCepBlur é idêntica à do CadastrarClientePage) ...
        // Cole a implementação do handleCepBlur da página de cadastro aqui.
        const cepLimpo = (enderecoData.cep || '').replace(/\D/g, '');
        const numeroStr = String(enderecoData.numero || '').trim();

        if (cepLimpo.length === 8) {
            setBuscandoCepCoords(true);
            setErro('');
            setMensagem('Buscando dados do CEP...');
            try {
                const viaCepDados: ViaCepResponseDTO = await consultarCepPelaApi(cepLimpo);
                setMensagem('Dados do CEP encontrados. Atualizando campos...');

                const enderecoAtualizadoViaCep = {
                    ...enderecoData,
                    logradouro: viaCepDados.logradouro || enderecoData.logradouro || '',
                    bairro: viaCepDados.bairro || enderecoData.bairro || '',
                    localidade: viaCepDados.localidade || enderecoData.localidade || '',
                    uf: viaCepDados.uf || enderecoData.uf || '',
                    cep: viaCepDados.cep || enderecoData.cep,
                    latitude: 0,
                    longitude: 0,
                };
                setEnderecoData(enderecoAtualizadoViaCep);

                if (numeroStr && numeroStr !== "0" && (viaCepDados.logradouro || enderecoAtualizadoViaCep.logradouro) ) {
                    setMensagem('Endereço preenchido. Buscando coordenadas geográficas...');
                    const geoRequestData: EnderecoGeoRequestDTO = {
                        logradouro: enderecoAtualizadoViaCep.logradouro!,
                        numero: numeroStr,
                        cidade: enderecoAtualizadoViaCep.localidade!,
                        uf: enderecoAtualizadoViaCep.uf!,
                        bairro: enderecoAtualizadoViaCep.bairro,
                        cep: cepLimpo
                    };
                    const coordenadas: GeoCoordinatesDTO = await calcularCoordenadasPelaApi(geoRequestData);
                    setEnderecoData(prev => ({
                        ...prev,
                        latitude: coordenadas.latitude || 0,
                        longitude: coordenadas.longitude || 0,
                    }));
                    setMensagem('Endereço e coordenadas carregados.');
                } else if (!numeroStr || numeroStr === "0") {
                    setErro('CEP encontrado. Informe o NÚMERO para buscar as coordenadas.');
                    setMensagem('');
                } else {
                    setMensagem('Dados do CEP carregados. Coordenadas não buscadas.');
                }
            } catch (error: any) {
                setErro(`Falha na busca do endereço: ${error.message}. Preencha manualmente.`);
                setMensagem('');
            } finally {
                setBuscandoCepCoords(false);
            }
        } else if (enderecoData.cep && cepLimpo.length !== 8) {
            setErro('CEP inválido. Deve conter 8 dígitos.');
            setMensagem('');
        }
    };

    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        if (isNaN(clienteId)) {
            setErro("ID do cliente inválido para atualização.");
            return;
        }

        setErro('');
        setLoadingSubmit(true);
        setMensagem('Processando atualização...');

        let contatoPrincipalId: number | undefined = currentContatoId;
        let enderecoPrincipalId: number | undefined = currentEnderecoId;

        try {
            // 1. Atualizar ou Criar Contato Principal
            if (contatoData.email && contatoData.ddd && contatoData.telefone) {
                setMensagem('Atualizando/Verificando contato...');
                // Se currentContatoId existe, atualiza. Senão, cria um novo.
                // Para simplificar, vamos assumir que se os dados de contato foram preenchidos,
                // e existe um currentContatoId, tentamos atualizar.
                // Se não há currentContatoId mas há dados, criamos um novo.
                // Esta lógica pode precisar de funções "atualizarContatoSozinho" no apiService.ts

                // SIMPLIFICAÇÃO: Assume que o contato principal é sempre atualizado se existir,
                // ou criado se não existir ID e dados foram fornecidos.
                // Uma lógica mais robusta envolveria checar se os dados do contato mudaram
                // antes de fazer uma chamada de atualização.
                // Por ora, vamos assumir que se o formulário de contato foi preenchido,
                // ele é enviado para ser criado/atualizado pelo backend (que pode ter lógica de upsert ou criar novo e desassociar antigo).
                // Para este exemplo, vamos tentar criar um novo se não houver ID, ou assumir que o backend
                // vai atualizar o existente se um ID for passado junto com o Cliente.
                // Como o backend ClienteService agora espera IDs, precisamos garantir que temos esses IDs.
                // Se o contato foi alterado e já existia, você chamaria "atualizarContatoSozinho(currentContatoId, contatoData)"
                // Se é um novo contato para o cliente (raro na alteração, a menos que esteja trocando), criaria um novo.
                // Para manter simples: se os dados do formulário de contato estão preenchidos,
                // e não temos currentContatoId, teríamos que criar um novo contato e pegar seu ID.
                // Se temos currentContatoId, assumimos que o backend atualizará o contato associado por esse ID.
                // A API atual do backend /clientes/{id} (PUT) espera contatosIds e enderecosIds.

                // TODO: Implementar a lógica de atualização/criação separada de Contato e Endereço
                // para obter os IDs corretos se eles mudaram ou são novos.
                // Por enquanto, vamos apenas passar os IDs existentes se houver,
                // ou uma lista vazia/undefined se não houver.
                // A atualização dos DADOS de contato/endereço associados precisaria de chamadas
                // separadas para PUT /api/contatos/{contatoId} e PUT /api/enderecos/{enderecoId}
                // ANTES de chamar atualizarCliente se os *dados* do contato/endereço mudaram.
                // A associação em si é feita via contatosIds/enderecosIds no ClienteRequestDTO.

                if (!(Number(enderecoData.latitude) !== 0 && Number(enderecoData.longitude) !== 0) && enderecoData.logradouro) {
                    setMensagem("Coordenadas não detectadas, tentando geocodificar antes de salvar...");
                    setBuscandoCepCoords(true);
                    const numeroEnderecoNum = parseInt(String(enderecoData.numero || "0"), 10);
                    const geoRequestData: EnderecoGeoRequestDTO = {
                        logradouro: enderecoData.logradouro || '', numero: String(numeroEnderecoNum), cidade: enderecoData.localidade || '',
                        uf: enderecoData.uf || '', bairro: enderecoData.bairro, cep: (enderecoData.cep || '').replace(/\D/g, '')
                    };
                    const coordenadas: GeoCoordinatesDTO = await calcularCoordenadasPelaApi(geoRequestData);
                    enderecoData.latitude = coordenadas.latitude || 0;
                    enderecoData.longitude = coordenadas.longitude || 0;
                    setBuscandoCepCoords(false);
                    if (enderecoData.latitude === 0 || enderecoData.longitude === 0) {
                        throw new Error("Não foi possível obter coordenadas para o endereço informado ao tentar salvar.");
                    }
                } else if (!enderecoData.logradouro || !(Number(enderecoData.latitude) !== 0 && Number(enderecoData.longitude) !== 0)) {
                    throw new Error("Dados do endereço (logradouro, lat/lon) são insuficientes ou inválidos.");
                }


            } // Fim do try inicial para contato/endereco (esta lógica precisará ser muito mais robusta)

            const clientePayload: ClienteRequestDTO = {
                ...clienteData,
                contatosIds: currentContatoId ? [currentContatoId] : [], // Passa o ID do contato existente
                enderecosIds: currentEnderecoId ? [currentEnderecoId] : [], // Passa o ID do endereço existente
            };
            // Se você editou os dados de contatoData e enderecoData no formulário,
            // você precisaria de chamadas PUT /api/contatos/{currentContatoId} e PUT /api/enderecos/{currentEnderecoId}
            // *antes* de chamar atualizarCliente. E o ClienteRequestDTO no backend precisaria ser ajustado
            // para talvez não aceitar os dados completos de contato/endereço se a associação é apenas por ID.

            // Assumindo que o ClienteRequestDTO do backend foi revertido para contatosIds/enderecosIds
            // E que o foco aqui é atualizar o Cliente e suas *associações* a Contatos/Endereços existentes.
            // Se os *dados* do Contato/Endereço principal mudaram, eles precisariam ser atualizados em chamadas separadas.

            setMensagem('Enviando atualização do cliente...');
            await atualizarCliente(clienteId, clientePayload);
            setMensagem('Cliente atualizado com sucesso! Redirecionando...');
            setTimeout(() => router.push(`/clientes/${clienteId}`), 2000);

        } catch (error: any) {
            setErro(`Falha ao atualizar cliente: ${error.message}`);
            setMensagem('');
        } finally {
            setLoadingSubmit(false);
            setBuscandoCepCoords(false);
        }
    };


    if (initialLoading) return <div className="container"><p>Carregando dados do cliente para edição...</p></div>;
    if (erro && !clienteData.nome) return <div className="container"><p className="message error">{erro}</p><Link href="/clientes/listar">Voltar para Lista</Link></div>;

    return (
        <div className="container">
            <h1 className="page-title">Alterar Cliente (ID: {idPath})</h1>
            <form onSubmit={handleSubmit} className="form-container">
                <h2>Dados Pessoais</h2>
                {/* ... Campos para clienteData (idênticos ao de cadastro) ... */}
                <div className="form-group">
                    <label htmlFor="nome">Nome:</label>
                    <input id="nome" type="text" name="nome" value={clienteData.nome || ''} onChange={handleClienteChange} required />
                </div>
                <div className="form-group">
                    <label htmlFor="sobrenome">Sobrenome:</label>
                    <input id="sobrenome" type="text" name="sobrenome" value={clienteData.sobrenome || ''} onChange={handleClienteChange} required />
                </div>
                <div className="form-group">
                    <label htmlFor="dataNascimento">Data de Nascimento:</label>
                    <input id="dataNascimento" type="date" name="dataNascimento" value={clienteData.dataNascimento || ''} onChange={handleClienteChange} required />
                </div>
                <div className="form-group">
                    <label htmlFor="documento">Documento:</label>
                    <input id="documento" type="text" name="documento" value={clienteData.documento || ''} onChange={handleClienteChange} required />
                </div>

                <h2>Contato Principal (ID: {currentContatoId || 'Novo'})</h2>
                {/* Campos para contatoData (idênticos ao de cadastro) */}
                <div className="form-group">
                    <label htmlFor="alt-ddd">DDD:</label>
                    <input id="alt-ddd" type="text" name="ddd" value={contatoData.ddd || ''} onChange={handleContatoChange} maxLength={3} required />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-telefone">Telefone:</label>
                    <input id="alt-telefone" type="tel" name="telefone" value={contatoData.telefone || ''} onChange={handleContatoChange} maxLength={9} required />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-celular">Celular:</label>
                    <input id="alt-celular" type="tel" name="celular" value={contatoData.celular || ''} onChange={handleContatoChange} maxLength={9} />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-whatsapp">WhatsApp:</label>
                    <input id="alt-whatsapp" type="tel" name="whatsapp" value={contatoData.whatsapp || ''} onChange={handleContatoChange} maxLength={9} />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-email">Email:</label>
                    <input id="alt-email" type="email" name="email" value={contatoData.email || ''} onChange={handleContatoChange} required />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-tipoContato">Tipo Contato:</label>
                    <input id="alt-tipoContato" type="text" name="tipoContato" value={contatoData.tipoContato || ''} onChange={handleContatoChange} required />
                </div>

                <h2>Endereço Principal (ID: {currentEnderecoId || 'Novo'})</h2>
                {/* Campos para enderecoData (idênticos ao de cadastro) */}
                <div className="form-group">
                    <label htmlFor="alt-cep">CEP:</label>
                    <input id="alt-cep" type="text" name="cep" value={enderecoData.cep || ''} onChange={handleEnderecoChange} onBlur={handleCepBlur} maxLength={9} required />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-numero">Número:</label>
                    <input id="alt-numero" type="text" name="numero" value={String(enderecoData.numero || '') === '0' ? '' : String(enderecoData.numero || '')} onChange={handleEnderecoChange} onBlur={handleCepBlur} required />
                </div>
                {buscandoCepCoords && <p style={{textAlign: 'center', color: '#007bff', margin: '10px 0'}}>Buscando dados do endereço...</p>}
                <div className="form-group">
                    <label htmlFor="alt-logradouro">Logradouro:</label>
                    <input id="alt-logradouro" type="text" name="logradouro" value={enderecoData.logradouro || ''} onChange={handleEnderecoChange} required />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-bairro">Bairro:</label>
                    <input id="alt-bairro" type="text" name="bairro" value={enderecoData.bairro || ''} onChange={handleEnderecoChange} required />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-localidade">Localidade:</label>
                    <input id="alt-localidade" type="text" name="localidade" value={enderecoData.localidade || ''} onChange={handleEnderecoChange} required />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-uf">UF:</label>
                    <input id="alt-uf" type="text" name="uf" value={enderecoData.uf || ''} onChange={handleEnderecoChange} maxLength={2} required />
                </div>
                <div className="form-group">
                    <label htmlFor="alt-complemento">Complemento:</label>
                    <input id="alt-complemento" type="text" name="complemento" value={enderecoData.complemento || ''} onChange={handleEnderecoChange} />
                </div>
                { (enderecoData.latitude && enderecoData.longitude && Number(enderecoData.latitude) !== 0 && Number(enderecoData.longitude) !== 0) &&
                    <div className="form-group" style={{backgroundColor: '#f0f0f0', padding: '10px', borderRadius: '4px', fontSize: '0.9em'}}>
                        <p>Coordenadas Atuais: Lat: {Number(enderecoData.latitude).toFixed(7)}, Lon: {Number(enderecoData.longitude).toFixed(7)}</p>
                    </div>
                }

                <button type="submit" disabled={buscandoCepCoords || loadingSubmit || initialLoading} className="button-primary">
                    {initialLoading ? 'Carregando...' : (loadingSubmit ? 'Salvando...' : (buscandoCepCoords ? 'Aguarde...' : 'Salvar Alterações'))}
                </button>
            </form>
            {mensagem && !erro && <p className="message success" style={{marginTop: '15px'}}>{mensagem}</p>}
            {erro && <p className="message error" style={{marginTop: '15px'}}>{erro}</p>}
            <div style={{marginTop: '20px'}}>
                <Link href={`/clientes/${clienteId}`}>Cancelar e Voltar para Detalhes</Link>
                <span style={{margin: "0 10px"}}>|</span>
                <Link href="/clientes/listar">Voltar para Lista Geral</Link>
            </div>
        </div>
    );
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// app\clientes\buscar\page.tsx | arquivo page.tsx
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/app/clientes/buscar/page.tsx
'use client';
import { useState, FormEvent } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link'; // Importar Link

export default function BuscarClientePage() {
    const [termoBusca, setTermoBusca] = useState('');
    const [tipoBusca, setTipoBusca] = useState<'id' | 'documento' | 'email'>('id');
    const router = useRouter();

    const handleBuscar = (e: FormEvent) => {
        e.preventDefault();
        if (!termoBusca.trim()) {
            alert('Por favor, informe um termo para busca.');
            return;
        }
        if (tipoBusca === 'id' && !isNaN(Number(termoBusca))) {
            router.push(`/clientes/${termoBusca}`); // Redireciona para a página de detalhes [id].tsx
        } else {
            alert(`Busca por ${tipoBusca} ainda não implementada aqui. Tente buscar por ID numérico.`);
        }
    };

    return (
        <div className="container">
            <h1 className="page-title">Buscar Cliente</h1>
            <form onSubmit={handleBuscar}>
                <label>
                    Buscar por:
                    <select value={tipoBusca} onChange={(e) => setTipoBusca(e.target.value as any)} style={{marginBottom: '10px'}}>
                        <option value="id">ID do Cliente</option>
                        {/* <option value="documento">Documento</option> */}
                    </select>
                </label>
                <label>
                    {tipoBusca === 'id' ? 'ID do Cliente:' : 'Termo de Busca:'}
                    <input
                        type={tipoBusca === 'id' ? 'number' : 'text'}
                        value={termoBusca}
                        onChange={(e) => setTermoBusca(e.target.value)}
                        placeholder={tipoBusca === 'id' ? 'Digite o ID numérico' : 'Digite para buscar...'}
                        required
                    />
                </label>
                <button type="submit">Buscar</button>
            </form>
            <p style={{marginTop: '15px'}}>
                Para ver todos os clientes, acesse a <Link href="/clientes/listar">Lista de Clientes</Link>.
            </p>
        </div>
    );
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// app\clientes\cadastrar\page.tsx | arquivo page.tsx
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

'use client';

import { useState, FormEvent, ChangeEvent } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import {
    criarCliente,
    consultarCepPelaApi,
    calcularCoordenadasPelaApi,
    criarContatoSozinho,
    criarEnderecoSozinho
} from '@/lib/apiService';
import type {
    ClienteRequestDTO,
    ContatoRequestDTO,
    EnderecoRequestDTO,
    ViaCepResponseDTO,
    EnderecoGeoRequestDTO,
    GeoCoordinatesDTO,
    ContatoResponseDTO,
    EnderecoResponseDTO
} from '@/lib/types';

export default function CadastrarClientePage() {
    const router = useRouter();
    // Estados para os dados do formulário (como definidos anteriormente)
    const [clienteData, setClienteData] = useState<Omit<ClienteRequestDTO, 'contatosIds' | 'enderecosIds'>>({
        nome: '', sobrenome: '', dataNascimento: '', documento: '',
    });
    const [contatoData, setContatoData] = useState<ContatoRequestDTO>({
        ddd: '', telefone: '', celular: '', whatsapp: '', email: '', tipoContato: 'Principal',
    });
    const [enderecoData, setEnderecoData] = useState<Partial<EnderecoRequestDTO & { numero: string }>>({
        cep: '', numero: '', logradouro: '', bairro: '', localidade: '', uf: '', complemento: '', latitude: 0, longitude: 0,
    });
    const [mensagem, setMensagem] = useState<string>('');
    const [erro, setErro] = useState<string>('');
    const [loadingSubmit, setLoadingSubmit] = useState<boolean>(false);
    const [buscandoCep, setBuscandoCep] = useState<boolean>(false);
    const [buscandoCoords, setBuscandoCoords] = useState<boolean>(false);

    // Handlers de mudança (como definidos anteriormente)
    const handleClienteChange = (e: ChangeEvent<HTMLInputElement>) => setClienteData(prev => ({ ...prev, [e.target.name]: e.target.value }));
    const handleContatoChange = (e: ChangeEvent<HTMLInputElement>) => setContatoData(prev => ({ ...prev, [e.target.name]: e.target.value }));
    const handleEnderecoChange = (e: ChangeEvent<HTMLInputElement>) => setEnderecoData(prev => ({ ...prev, [e.target.name]: e.target.value }));

    // handleCepBlur (como definido anteriormente)
    const handleCepBlur = async () => {
        const cepLimpo = (enderecoData.cep || '').replace(/\D/g, '');
        if (cepLimpo.length === 8) {
            setBuscandoCep(true); setErro(''); setMensagem('Buscando dados do CEP...');
            try {
                const viaCepDados: ViaCepResponseDTO = await consultarCepPelaApi(cepLimpo);
                setEnderecoData(prev => ({
                    ...prev,
                    logradouro: viaCepDados.logradouro || '', bairro: viaCepDados.bairro || '',
                    localidade: viaCepDados.localidade || '', uf: viaCepDados.uf || '',
                    cep: viaCepDados.cep || prev.cep, latitude: 0, longitude: 0,
                }));
                setMensagem('Dados do CEP carregados. Preencha o número e clique em "Gerar Coordenadas".');
            } catch (error: any) {
                setErro(`Falha ao buscar CEP: ${error.message}. Preencha manualmente.`);
                setMensagem('');
            } finally { setBuscandoCep(false); }
        } else if (enderecoData.cep && cepLimpo.length !== 8) {
            setErro('CEP inválido.'); setMensagem('');
        }
    };

    // handleGerarCoordenadasClick (como definido anteriormente)
    const handleGerarCoordenadasClick = async () => {
        const numeroStr = String(enderecoData.numero || '').trim();
        if (!enderecoData.logradouro && !enderecoData.localidade && !enderecoData.uf) {
            setErro("Preencha pelo menos Cidade e UF, ou o endereço completo, para gerar coordenadas."); setMensagem(''); return;
        }
        if (enderecoData.logradouro && (!numeroStr || numeroStr === "0")) {
            setErro("Se informou logradouro, por favor, informe o Número para gerar coordenadas precisas."); setMensagem(''); return;
        }
        setBuscandoCoords(true); setErro(''); setMensagem('Gerando coordenadas...');
        try {
            const geoRequestData: EnderecoGeoRequestDTO = {
                logradouro: enderecoData.logradouro || '', numero: numeroStr,
                cidade: enderecoData.localidade || '', uf: enderecoData.uf || '',
                bairro: enderecoData.bairro, cep: (enderecoData.cep || '').replace(/\D/g, '')
            };
            const coordenadas: GeoCoordinatesDTO = await calcularCoordenadasPelaApi(geoRequestData);
            setEnderecoData(prev => ({ ...prev, latitude: coordenadas.latitude || 0, longitude: coordenadas.longitude || 0 }));
            if ((coordenadas.latitude || 0) === 0 || (coordenadas.longitude || 0) === 0) {
                setErro("Não foi possível obter coordenadas. Verifique os dados."); setMensagem('');
            } else {
                setMensagem(`Coordenadas: Lat ${Number(coordenadas.latitude).toFixed(7)}, Lon ${Number(coordenadas.longitude).toFixed(7)}.`);
            }
        } catch (error: any) {
            setErro(`Falha ao gerar coordenadas: ${error.message}`); setMensagem('');
        } finally { setBuscandoCoords(false); }
    };

    // handleSubmit (como definido anteriormente)
    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault(); setErro(''); setLoadingSubmit(true); setMensagem('Processando...');
        let contatoId: number | undefined; let enderecoId: number | undefined;
        const finalLatitude = Number(enderecoData.latitude) || 0;
        const finalLongitude = Number(enderecoData.longitude) || 0;
        try {
            if (contatoData.email && contatoData.ddd && contatoData.telefone) {
                setMensagem('Salvando contato...');
                const contatoSalvo = await criarContatoSozinho(contatoData);
                contatoId = contatoSalvo.idContato;
                setMensagem('Contato salvo.');
            }
            setMensagem(prev => prev + ' Processando endereço...');
            const numeroEnderecoNum = parseInt(String(enderecoData.numero || "0"), 10);
            const enderecoPreenchido = enderecoData.logradouro && numeroEnderecoNum > 0 && enderecoData.localidade && enderecoData.uf;
            if (enderecoPreenchido) {
                if (finalLatitude === 0 || finalLongitude === 0) {
                    setErro("Latitude e Longitude são obrigatórias. Clique em 'Gerar Coordenadas'.");
                    setLoadingSubmit(false); setMensagem(''); return;
                }
                const enderecoPayload: EnderecoRequestDTO = {
                    cep: (enderecoData.cep || '').replace(/\D/g, ''), numero: numeroEnderecoNum,
                    logradouro: enderecoData.logradouro || '', bairro: enderecoData.bairro || '',
                    localidade: enderecoData.localidade || '', uf: enderecoData.uf || '',
                    complemento: enderecoData.complemento || '', latitude: finalLatitude, longitude: finalLongitude,
                };
                setMensagem(prev => prev + ' Salvando endereço...');
                const enderecoSalvo = await criarEnderecoSozinho(enderecoPayload);
                enderecoId = enderecoSalvo.idEndereco;
                setMensagem(prev => prev.replace('Salvando endereço...', 'Endereço salvo.'));
            }
            setMensagem(prev => prev + ' Criando cliente...');
            const clientePayload: ClienteRequestDTO = {
                ...clienteData,
                contatosIds: contatoId ? [contatoId] : [],
                enderecosIds: enderecoId ? [enderecoId] : [],
            };
            const clienteCriado = await criarCliente(clientePayload);
            setMensagem(`Cliente "${clienteCriado.nome} ${clienteCriado.sobrenome}" (ID: ${clienteCriado.idCliente}) salvo! Redirecionando...`);
            setClienteData({ nome: '', sobrenome: '', dataNascimento: '', documento: '' });
            setContatoData({ ddd: '', telefone: '', celular: '', whatsapp: '', email: '', tipoContato: 'Principal' });
            setEnderecoData({ cep: '', numero: '', logradouro: '', bairro: '', localidade: '', uf: '', complemento: '', latitude: 0, longitude: 0 });
            setTimeout(() => router.push(`/clientes/${clienteCriado.idCliente}`), 3000);
        } catch (error: any) {
            setErro(`Falha no cadastro: ${error.message}`); setMensagem('');
        } finally { setLoadingSubmit(false); }
    };

    return (
        <div className="container">
            <h1 className="page-title">Cadastrar Novo Cliente</h1>
            <form onSubmit={handleSubmit} className="form-container" autoComplete="off">

                <fieldset className="form-section">
                    <legend className="section-title">Dados Pessoais</legend>
                    <div className="form-row">
                        <div className="form-group flex-item">
                            <label htmlFor="nome">Nome:</label>
                            <input id="nome" type="text" name="nome" value={clienteData.nome} onChange={handleClienteChange} required autoComplete="given-name" />
                        </div>
                        <div className="form-group flex-item">
                            <label htmlFor="sobrenome">Sobrenome:</label>
                            <input id="sobrenome" type="text" name="sobrenome" value={clienteData.sobrenome} onChange={handleClienteChange} required autoComplete="family-name" />
                        </div>
                    </div>
                    <div className="form-row">
                        <div className="form-group flex-item">
                            <label htmlFor="dataNascimento">Data de Nascimento:</label>
                            <input id="dataNascimento" type="date" name="dataNascimento" value={clienteData.dataNascimento} onChange={handleClienteChange} required autoComplete="bday" />
                        </div>
                        <div className="form-group flex-item">
                            <label htmlFor="documento">Documento (CPF/CNPJ):</label>
                            <input id="documento" type="text" name="documento" value={clienteData.documento} onChange={handleClienteChange} required autoComplete="off" />
                        </div>
                    </div>
                </fieldset>

                <hr className="section-divider" />

                <fieldset className="form-section">
                    <legend className="section-title">Contato Principal</legend>
                    <div className="form-row">
                        <div className="form-group basis-ddd"> {/* Usando classe específica para DDD */}
                            <label htmlFor="ddd">DDD:</label>
                            <input id="ddd" type="text" name="ddd" value={contatoData.ddd} onChange={handleContatoChange} maxLength={3} required autoComplete="tel-area-code" />
                        </div>
                        <div className="form-group flex-item"> {/* Telefone ocupa o resto */}
                            <label htmlFor="telefone">Telefone:</label>
                            <input id="telefone" type="tel" name="telefone" value={contatoData.telefone} onChange={handleContatoChange} maxLength={15} required autoComplete="tel-local" />
                        </div>
                    </div>
                    <div className="form-row">
                        <div className="form-group flex-item">
                            <label htmlFor="celular">Celular (Opcional):</label>
                            <input id="celular" type="tel" name="celular" value={contatoData.celular || ''} onChange={handleContatoChange} maxLength={15} autoComplete="tel" />
                        </div>
                        <div className="form-group flex-item">
                            <label htmlFor="whatsapp">WhatsApp (Opcional):</label>
                            <input id="whatsapp" type="tel" name="whatsapp" value={contatoData.whatsapp || ''} onChange={handleContatoChange} maxLength={15} autoComplete="tel"/>
                        </div>
                    </div>
                    <div className="form-group">
                        <label htmlFor="email">Email:</label>
                        <input id="email" type="email" name="email" value={contatoData.email} onChange={handleContatoChange} required autoComplete="email" />
                    </div>
                    <div className="form-group">
                        <label htmlFor="tipoContato">Tipo Contato:</label>
                        <input id="tipoContato" type="text" name="tipoContato" value={contatoData.tipoContato} onChange={handleContatoChange} required />
                    </div>
                </fieldset>

                <hr className="section-divider" />

                <fieldset className="form-section">
                    <legend className="section-title">Endereço Principal</legend>
                    <div className="form-row">
                        <div className="form-group basis-cep"> {/* Classe para CEP */}
                            <label htmlFor="cep">CEP:</label>
                            <input id="cep" type="text" name="cep" value={enderecoData.cep || ''} onChange={handleEnderecoChange} onBlur={handleCepBlur} maxLength={9} placeholder="00000-000" autoComplete="postal-code" />
                        </div>
                        <div className="form-group basis-numero"> {/* Classe para Número */}
                            <label htmlFor="numero">Número:</label>
                            <input id="numero" type="text" name="numero" value={String(enderecoData.numero || '')} onChange={handleEnderecoChange} placeholder="Ex: 123" autoComplete="address-line2" />
                        </div>
                        <div className="form-group flex-item"> {/* Complemento ocupa o resto */}
                            <label htmlFor="complemento">Complemento:</label>
                            <input id="complemento" type="text" name="complemento" value={enderecoData.complemento || ''} onChange={handleEnderecoChange} autoComplete="address-line3"/>
                        </div>
                    </div>
                    {buscandoCep && <p className="message info">Buscando CEP...</p>}

                    <div className="form-group">
                        <label htmlFor="logradouro">Logradouro:</label>
                        <input id="logradouro" type="text" name="logradouro" value={enderecoData.logradouro || ''} onChange={handleEnderecoChange} autoComplete="address-line1" />
                    </div>
                    <div className="form-group">
                        <label htmlFor="bairro">Bairro:</label>
                        <input id="bairro" type="text" name="bairro" value={enderecoData.bairro || ''} onChange={handleEnderecoChange} autoComplete="address-level3"/>
                    </div>
                    <div className="form-row">
                        <div className="form-group grow-3"> {/* Cidade maior */}
                            <label htmlFor="localidade">Localidade (Cidade):</label>
                            <input id="localidade" type="text" name="localidade" value={enderecoData.localidade || ''} onChange={handleEnderecoChange} autoComplete="address-level2" />
                        </div>
                        <div className="form-group basis-uf"> {/* UF menor */}
                            <label htmlFor="uf">UF (Estado):</label>
                            <input id="uf" type="text" name="uf" value={enderecoData.uf || ''} onChange={handleEnderecoChange} maxLength={2} autoComplete="address-level1" />
                        </div>
                    </div>
                </fieldset>

                <hr className="section-divider"/>

                <fieldset className="coordinate-section">
                    <legend className="section-title">Coordenadas Geográficas</legend>
                    <p>
                        Após preencher o endereço (Logradouro, Número, Cidade e UF), clique para obter as coordenadas:
                    </p>
                    <div className="form-row" style={{alignItems: 'center', marginBottom: '0.5rem'}}>
                        <div className="form-group" style={{flex: '0 0 auto', marginBottom: 0}}>
                            <button
                                type="button"
                                onClick={handleGerarCoordenadasClick}
                                disabled={buscandoCoords || !enderecoData.logradouro || !enderecoData.numero || !enderecoData.localidade || !enderecoData.uf}
                                className="button-secondary"
                            >
                                {buscandoCoords ? 'Gerando...' : 'Obter Coordenadas'}
                            </button>
                        </div>
                        {buscandoCoords && <p className="message info" style={{margin: '0 0 0 1rem'}}>Gerando coordenadas...</p>}
                    </div>
                    <div className="coordinates-display">
                        {(Number(enderecoData.latitude) !== 0 || Number(enderecoData.longitude) !== 0) ? (
                            <>
                                <p><b>Coordenadas Obtidas:</b></p>
                                <p><span>Latitude:</span> <span>{Number(enderecoData.latitude).toFixed(7)}</span></p>
                                <p><span>Longitude:</span> <span>{Number(enderecoData.longitude).toFixed(7)}</span></p>
                            </>
                        ) : (
                            (enderecoData.logradouro && String(enderecoData.numero||'').trim() && enderecoData.localidade && enderecoData.uf) && !buscandoCoords &&
                            <p className="message info" style={{marginTop: 0}}>Clique em "Obter Coordenadas".</p>
                        )}
                    </div>
                </fieldset>

                <hr className="section-divider"/>

                <button
                    type="submit"
                    disabled={buscandoCep || buscandoCoords || loadingSubmit}
                    className="button-primary"
                    style={{marginTop: '10px', width: '100%', padding: '12px', fontSize: '1.1em'}}
                >
                    {loadingSubmit ? 'Salvando Cliente...' : (buscandoCep || buscandoCoords ? 'Aguarde...' : 'Salvar Cliente Completo')}
                </button>
            </form>

            {(mensagem && !erro) && <p className="message success" style={{marginTop: '20px', textAlign: 'center'}}>{mensagem}</p>}
            {erro && <p className="message error" style={{marginTop: '20px', textAlign: 'center'}}>{erro}</p>}

            <div style={{marginTop: '30px', marginBottom: '40px', textAlign: 'center'}}>
                <Link href="/clientes/listar">Voltar para Lista de Clientes</Link>
            </div>
        </div>
    );
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// app\clientes\deletar\[id]\page.tsx | arquivo page.tsx
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/app/clientes/deletar/[id]/page.tsx
'use client';
import { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
// CORREÇÃO DO CAMINHO ABAIXO:
import { buscarClientePorId, deletarCliente } from '@/lib/apiService';
import type { ClienteResponseDTO } from '@/lib/types';
import Link from 'next/link';

// ... (o resto do código do DeletarClienteConfirmPage permanece o mesmo da minha resposta anterior)
// Cole o restante do código que já te enviei para esta página,
// apenas certifique-se de que as importações acima estejam com o caminho '../../../../lib/'
// Correto: ../../../lib/

export default function DeletarClienteConfirmPage() {
    const params = useParams();
    const router = useRouter();
    const idPath = Array.isArray(params.id) ? params.id[0] : params.id;

    const [cliente, setCliente] = useState<ClienteResponseDTO | null>(null);
    const [erro, setErro] = useState<string | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const [deleting, setDeleting] = useState<boolean>(false);

    useEffect(() => {
        if (idPath) {
            const clienteId = Number(idPath);
            if (isNaN(clienteId)) {
                setErro("ID do cliente inválido na URL.");
                setLoading(false);
                return;
            }
            setLoading(true);
            buscarClientePorId(clienteId)
                .then(data => {
                    setCliente(data);
                    setErro(null);
                })
                .catch(error => {
                    console.error("Erro ao buscar cliente para deleção:", error);
                    setErro(`Falha ao carregar cliente para deleção: ${error.message || 'Cliente não encontrado.'}`);
                    setCliente(null);
                })
                .finally(() => setLoading(false));
        } else {
            setErro("ID do cliente não fornecido para deleção.");
            setLoading(false);
        }
    }, [idPath]);

    const handleConfirmarDelecao = async () => {
        if (cliente) {
            setDeleting(true);
            setErro(null);
            try {
                await deletarCliente(cliente.idCliente);
                alert('Cliente deletado com sucesso!');
                router.push('/clientes/listar');
            } catch (error: any) {
                console.error("Erro ao confirmar deleção:", error);
                setErro(`Falha ao deletar cliente: ${error.message || 'Erro desconhecido.'}`);
                // alert já está na UI
                setDeleting(false);
            }
        }
    };

    if (loading) return <div className="container"><p>Carregando dados do cliente...</p></div>;
    if (erro && !cliente) return <div className="container"><p className="message error">{erro}</p><Link href="/clientes/listar">Voltar para lista</Link></div>;
    if (!cliente) return <div className="container"><p>Cliente não encontrado.</p><Link href="/clientes/listar">Voltar para lista</Link></div>;

    return (
        <div className="container">
            <h1 className="page-title">Confirmar Deleção do Cliente</h1>
            <div style={{ backgroundColor: 'white', padding: '20px', borderRadius: '8px', textAlign: 'center' }}>
                <p>Você tem certeza que deseja deletar o cliente:</p>
                <p><strong>Nome:</strong> {cliente.nome} {cliente.sobrenome}</p>
                <p><strong>Documento:</strong> {cliente.documento}</p>
                <p style={{color: 'red', fontWeight: 'bold', margin: '20px 0'}}>Esta ação não pode ser desfeita.</p>
                {erro && <p className="message error" style={{textAlign: 'left', marginBottom: '15px'}}>{erro}</p>}
                <div style={{ marginTop: '20px', display: 'flex', justifyContent: 'center', gap: '10px' }}>
                    <button onClick={handleConfirmarDelecao} className="button-danger" disabled={deleting}>
                        {deleting ? 'Deletando...' : 'Sim, Deletar Cliente'}
                    </button>
                    <Link href={`/clientes/${cliente.idCliente}`} className="button-secondary" style={{textDecoration:'none'}}>
                        Cancelar
                    </Link>
                </div>
            </div>
        </div>
    );
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// app\clientes\layout.tsx | arquivo layout.tsx
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/app/clientes/layout.tsx
import Link from 'next/link';

export default function ClientesLayout({
                                           children,
                                       }: {
    children: React.ReactNode;
}) {
    const subNavStyle: React.CSSProperties = {
        backgroundColor: '#e9ecef',
        padding: '10px 20px',
        marginBottom: '20px',
        borderRadius: '4px',
        display: 'flex',
        gap: '15px',
        flexWrap: 'wrap',
    };
    const subNavLinkStyle: React.CSSProperties = {
        textDecoration: 'none',
        color: '#007bff',
        fontWeight: '500',
    };

    return (
        <section className="container">
            <nav style={subNavStyle}>
                <Link href="/clientes/listar" style={subNavLinkStyle}>Listar Clientes</Link>
                <Link href="/clientes/cadastrar" style={subNavLinkStyle}>Cadastrar Cliente</Link>
                <Link href="/clientes/buscar" style={subNavLinkStyle}>Buscar Cliente</Link>
            </nav>
            {children}
        </section>
    );
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// app\clientes\listar\page.tsx | arquivo page.tsx
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/app/clientes/listar/page.tsx
'use client';
import { useEffect, useState } from 'react';
import Link from 'next/link';
// CORREÇÃO DO CAMINHO ABAIXO:
import { listarClientes, deletarCliente } from '@/lib/apiService';
import type { ClienteResponseDTO, Page } from '@/lib/types';

export default function ListarClientesPage() {
    const [clientesPage, setClientesPage] = useState<Page<ClienteResponseDTO> | null>(null);
    const [erro, setErro] = useState<string | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const [currentPage, setCurrentPage] = useState<number>(0);

    const fetchClientes = async (page: number) => {
        setLoading(true);
        setErro(null);
        try {
            const data = await listarClientes(page, 5);
            setClientesPage(data);
        } catch (error: any) {
            console.error("Erro ao buscar clientes:", error);
            setErro(`Falha ao carregar clientes: ${error.message || 'Erro desconhecido'}`);
            setClientesPage(null);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchClientes(currentPage);
    }, [currentPage]);

    const handleDeletar = async (id: number, nome: string) => {
        if (window.confirm(`Tem certeza que deseja deletar o cliente "${nome}" (ID: ${id})?`)) {
            try {
                await deletarCliente(id);
                alert('Cliente deletado com sucesso!');
                if (clientesPage && clientesPage.content.length === 1 && currentPage > 0) {
                    setCurrentPage(currentPage - 1);
                } else {
                    fetchClientes(currentPage);
                }
            } catch (error: any) {
                console.error("Erro ao deletar cliente:", error);
                alert(`Falha ao deletar cliente: ${error.message || 'Erro desconhecido'}`);
            }
        }
    };

    if (loading) return <div className="container"><p>Carregando clientes...</p></div>;
    if (erro && (!clientesPage || clientesPage.content.length === 0)) return <div className="container"><p className="message error">{erro}</p></div>;
    if (!clientesPage || clientesPage.content.length === 0) return <div className="container"><p>Nenhum cliente encontrado.</p><Link href="/clientes/cadastrar" className="button-primary" style={{ marginTop: '10px', display: 'inline-block' }}>Cadastrar Novo Cliente</Link></div>;

    return (
        <div className="container">
            <h1 className="page-title">Lista de Clientes</h1>
            <Link href="/clientes/cadastrar" style={{ display: 'inline-block', marginBottom: '20px', padding: '10px 15px', backgroundColor: '#28a745', color: 'white', textDecoration: 'none', borderRadius: '5px' }}>
                Cadastrar Novo Cliente
            </Link>
            {erro && <p className="message error" style={{marginBottom: '15px'}}>{erro}</p>}
            <ul className="item-list">
                {clientesPage.content.map(cliente => (
                    <li key={cliente.idCliente}>
                        <div className="info">
                            <strong>{cliente.nome} {cliente.sobrenome}</strong> (ID: {cliente.idCliente})<br />
                            <span>Documento: {cliente.documento}</span><br/>
                            {cliente.contatos && cliente.contatos.length > 0 && cliente.contatos[0].email && <span>Email: {cliente.contatos[0].email}</span>}
                        </div>
                        <div className="actions">
                            <Link href={`/clientes/${cliente.idCliente}`} className="button-secondary" style={{marginRight: '8px', textDecoration:'none'}}>Ver</Link>
                            <Link href={`/clientes/alterar/${cliente.idCliente}`} className="button-secondary" style={{marginRight: '8px', textDecoration:'none'}}>Editar</Link>
                            <Link href={`/clientes/deletar/${cliente.idCliente}`} className="button-danger" style={{textDecoration:'none'}}>Deletar</Link>
                        </div>
                    </li>
                ))}
            </ul>
            <div style={{ marginTop: '20px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <button onClick={() => setCurrentPage(p => Math.max(0, p - 1))} disabled={clientesPage.first || loading}>Anterior</button>
                <span>Página {clientesPage.number + 1} de {clientesPage.totalPages}</span>
                <button onClick={() => setCurrentPage(p => Math.min(clientesPage.totalPages - 1, p + 1))} disabled={clientesPage.last || loading}>Próxima</button>
            </div>
        </div>
    );
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// app\layout.tsx | arquivo layout.tsx
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/app/layout.tsx
import './globals.css';
import Link from 'next/link';
import type { Metadata } from "next";

export const metadata: Metadata = {
    title: "GS Frontend Teste",
    description: "Aplicação para testar API da GS",
};

export default function RootLayout({
                                       children,
                                   }: {
    children: React.ReactNode
}) {
    return (
        <html lang="pt-BR">
        <body>
        <nav>
            <Link href="/" className="logo">GS API Test</Link>
            <Link href="/clientes/listar">Clientes</Link>
            <Link href="/contatos/listar">Contatos</Link>
            <Link href="/enderecos/listar">Endereços</Link>
        </nav>
        <main>
            {children}
        </main>
        </body>
        </html>
    )
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// app\page.tsx | arquivo page.tsx
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/app/page.tsx
import Link from 'next/link';

export default function HomePage() {
  const linkStyle: React.CSSProperties = {
    display: 'inline-block',
    margin: '10px',
    padding: '12px 20px',
    backgroundColor: '#007bff',
    color: 'white',
    textDecoration: 'none',
    borderRadius: '5px',
    textAlign: 'center',
    minWidth: '150px'
  };

  const containerStyle: React.CSSProperties = {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    minHeight: 'calc(100vh - 100px)', // Ajustar altura baseado no navbar
    padding: '20px'
  };

  return (
      <div style={containerStyle} className="container">
        <h1 className="page-title">Bem-vindo ao Teste da API GS</h1>
        <p style={{textAlign: 'center', marginBottom: '30px', fontSize: '1.1em'}}>
          Utilize a barra de navegação acima ou os links abaixo para gerenciar as entidades.
        </p>
        <div style={{ display: 'flex', gap: '20px', flexWrap: 'wrap', justifyContent: 'center' }}>
          <Link href="/clientes/listar" style={linkStyle}>Gerenciar Clientes</Link>
          <Link href="/contatos/listar" style={linkStyle}>Gerenciar Contatos</Link>
          <Link href="/enderecos/listar" style={linkStyle}>Gerenciar Endereços</Link>
        </div>
      </div>
  );
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// lib\apiService.ts | arquivo apiService.ts
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/lib/apiService.ts
import type {
    ClienteRequestDTO, ClienteResponseDTO,
    ContatoRequestDTO, ContatoResponseDTO,
    EnderecoRequestDTO, EnderecoResponseDTO,
    EnderecoGeoRequestDTO, GeoCoordinatesDTO,
    NominatimResultDTO, // Nome atualizado para NominatimResultDTO
    ViaCepResponseDTO, ApiErrorResponse, Page
} from './types';

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080/api';

async function handleResponse<T>(response: Response): Promise<T> {
    if (!response.ok) {
        let errorData: ApiErrorResponse;
        try {
            errorData = await response.json();
        } catch (e) {
            errorData = {
                message: response.statusText || "Erro desconhecido na resposta da API.",
                status: response.status,
                timestamp: new Date().toISOString(),
            };
        }

        let errorMessage = errorData.message || response.statusText || "Erro desconhecido";
        // Ajuste para pegar 'messages' do GlobalExceptionHandler para erros de validação
        const detailsArray = errorData.messages || (typeof errorData.details === 'string' ? [errorData.details] : errorData.details);
        if (detailsArray && detailsArray.length > 0) {
            errorMessage += `. Detalhes: ${detailsArray.join(', ')}`;
        }

        console.error("API Error:", errorMessage, "Status:", response.status, "Full Error Data:", errorData);
        throw new Error(errorMessage);
    }
    if (response.status === 204) {
        return null as T;
    }
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.indexOf("application/json") !== -1) {
        return await response.json() as T;
    } else {
        // Se não for JSON, mas a resposta foi OK (ex: 200 sem corpo, o que não deveria acontecer para GETs que esperam corpo)
        // ou para DELETE que retorna 204 (já tratado)
        // Para outros casos, pode retornar o texto ou tratar como erro se JSON era esperado.
        // Aqui, vamos assumir que se não for 204 e não for JSON, algo está inesperado para GETs que esperam JSON.
        // Para chamadas que não esperam corpo JSON (além de 204), esta lógica pode precisar de ajuste.
        console.warn("Resposta não JSON recebida:", response);
        return null as T; // Ou lançar um erro se um corpo JSON era estritamente esperado.
    }
}

// --- Cliente API ---
export async function listarClientes(page: number = 0, size: number = 10): Promise<Page<ClienteResponseDTO>> {
    const response = await fetch(`${API_BASE_URL}/clientes?page=${page}&size=${size}&sort=nome,asc`);
    return handleResponse<Page<ClienteResponseDTO>>(response);
}

export async function buscarClientePorId(id: number): Promise<ClienteResponseDTO> {
    const response = await fetch(`${API_BASE_URL}/clientes/${id}`);
    return handleResponse<ClienteResponseDTO>(response);
}

export async function buscarClientePorDocumento(documento: string): Promise<ClienteResponseDTO> {
    const response = await fetch(`${API_BASE_URL}/clientes/documento/${documento}`);
    return handleResponse<ClienteResponseDTO>(response);
}

// criarCliente e atualizarCliente agora esperam ClienteRequestDTO com contatosIds e enderecosIds
export async function criarCliente(data: ClienteRequestDTO): Promise<ClienteResponseDTO> {
    const response = await fetch(`${API_BASE_URL}/clientes`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
    });
    return handleResponse<ClienteResponseDTO>(response);
}

export async function atualizarCliente(id: number, data: ClienteRequestDTO): Promise<ClienteResponseDTO> {
    const response = await fetch(`${API_BASE_URL}/clientes/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
    });
    return handleResponse<ClienteResponseDTO>(response);
}

export async function deletarCliente(id: number): Promise<void> {
    const response = await fetch(`${API_BASE_URL}/clientes/${id}`, { method: 'DELETE' });
    await handleResponse<void>(response);
}

// --- Contato API (Endpoints para criar/gerenciar contatos independentemente) ---
export async function criarContatoSozinho(data: ContatoRequestDTO): Promise<ContatoResponseDTO> {
    const response = await fetch(`${API_BASE_URL}/contatos`, { // Supondo que /api/contatos existe
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
    });
    return handleResponse<ContatoResponseDTO>(response);
}
// Adicionar listarContatos, buscarContatoPorId, atualizarContatoSozinho, deletarContatoSozinho se necessário

// --- Endereco API ---
export async function consultarCepPelaApi(cep: string): Promise<ViaCepResponseDTO> {
    const response = await fetch(`${API_BASE_URL}/enderecos/consultar-cep/${cep.replace(/\D/g, '')}`);
    return handleResponse<ViaCepResponseDTO>(response);
}

export async function calcularCoordenadasPelaApi(data: EnderecoGeoRequestDTO): Promise<GeoCoordinatesDTO> {
    const response = await fetch(`${API_BASE_URL}/enderecos/calcular-coordenadas`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
    });
    return handleResponse<GeoCoordinatesDTO>(response);
}

// Endpoints para criar/gerenciar endereços independentemente
export async function criarEnderecoSozinho(data: EnderecoRequestDTO): Promise<EnderecoResponseDTO> {
    const response = await fetch(`${API_BASE_URL}/enderecos`, { // Supondo que /api/enderecos (POST) existe
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
    });
    return handleResponse<EnderecoResponseDTO>(response);
}
// Adicionar listarEnderecos, buscarEnderecoPorId, atualizarEnderecoSozinho, deletarEnderecoSozinho se necessário

// --- Eonet API (para dados locais) ---
export async function listarEventosEonet(page: number = 0, size: number = 10): Promise<Page<EonetResponseDTO>> {
    const response = await fetch(`${API_BASE_URL}/eonet?page=${page}&size=${size}&sort=data,desc`);
    return handleResponse<Page<EonetResponseDTO>>(response);
}

export async function sincronizarNasaEonet(limit?: number, days?: number, status?: string, source?: string): Promise<EonetResponseDTO[]> {
    const params = new URLSearchParams();
    if (limit) params.append('limit', String(limit));
    if (days) params.append('days', String(days));
    if (status) params.append('status', status);
    if (source) params.append('source', source);

    const response = await fetch(`${API_BASE_URL}/eonet/nasa/sincronizar?${params.toString()}`, {
        method: 'POST',
    });
    return handleResponse<EonetResponseDTO[]>(response);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// lib\types.ts | arquivo types.ts
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// src/lib/types.ts

// Base para paginação (Page<T>) - MANTÉM COMO ESTÁ
export interface Page<T> {
    content: T[];
    pageable: {
        sort: {
            sorted: boolean;
            unsorted: boolean;
            empty: boolean;
        };
        offset: number;
        pageNumber: number;
        pageSize: number;
        paged: boolean;
        unpaged: boolean;
    };
    last: boolean;
    totalPages: number;
    totalElements: number;
    size: number;
    number: number; // current page number
    sort: {
        sorted: boolean;
        unsorted: boolean;
        empty: boolean;
    };
    first: boolean;
    numberOfElements: number;
    empty: boolean;
}


// DTOs de Contato (MANTÊM COMO ESTÃO)
export interface ContatoRequestDTO {
    ddd: string;
    telefone: string;
    celular?: string;
    whatsapp?: string;
    email: string;
    tipoContato: string;
}

export interface ContatoResponseDTO extends ContatoRequestDTO {
    idContato: number;
}

// DTOs de Endereco (MANTÊM COMO ESTÃO)
export interface EnderecoRequestDTO {
    cep: string;
    numero: number;
    logradouro: string;
    bairro: string;
    localidade: string; // Cidade
    uf: string; // Estado
    complemento?: string;
    latitude: number;
    longitude: number;
}

export interface EnderecoResponseDTO extends EnderecoRequestDTO {
    idEndereco: number;
}

// DTOs de Cliente (AJUSTADO PARA USAR IDs)
export interface ClienteRequestDTO {
    nome: string;
    sobrenome: string;
    dataNascimento: string; // Formato YYYY-MM-DD (do input date) ou dd/MM/yyyy (se o backend aceitar ambos)
    documento: string;
    contatosIds?: number[];  // <--- MUDANÇA
    enderecosIds?: number[]; // <--- MUDANÇA
}

export interface ClienteResponseDTO {
    idCliente: number;
    nome: string;
    sobrenome: string;
    dataNascimento: string;
    documento: string;
    contatos?: ContatoResponseDTO[];  // Resposta pode continuar com DTOs completos
    enderecos?: EnderecoResponseDTO[];// Resposta pode continuar com DTOs completos
}

// ViaCep (MANTÉM COMO ESTÁ)
export interface ViaCepResponseDTO {
    cep: string;
    logradouro: string;
    complemento: string;
    bairro: string;
    localidade: string;
    uf: string;
    ibge: string;
    gia: string;
    ddd: string;
    siafi: string;
    erro?: boolean;
}

// Nominatim (MANTÉM COMO ESTÁ, mas ajuste o nome se necessário)
export interface NominatimResultDTO { // Renomeado para clareza, já que é um item da lista
    place_id: string; // Nominatim usa string para place_id em alguns casos
    lat: string;
    lon: string;
    display_name: string;
    // Adicione outros campos se precisar, ex: type, importance
}


// Para erros da API (MANTÉM COMO ESTÁ)
export interface ApiErrorResponse {
    timestamp: string;
    status: number;
    error?: string; // Adicionado para o formato do GlobalExceptionHandler
    message: string;
    messages?: string[]; // Para MethodArgumentNotValidException
    path?: string; // Adicionado para o formato do GlobalExceptionHandler
    details?: string[] | string; // Mantido para compatibilidade, mas 'messages' é mais específico para validação
}

// DTO para requisição de geocodificação (MANTÉM COMO ESTÁ)
export interface EnderecoGeoRequestDTO {
    logradouro: string;
    numero?: string;
    cidade: string;
    uf: string;
    bairro?: string;
    cep?: string;
}

// DTO para resposta da nossa API de geocodificação (MANTÉM COMO ESTÁ)
export interface GeoCoordinatesDTO {
    latitude: number;
    longitude: number;
    matchedAddress?: string;
}

