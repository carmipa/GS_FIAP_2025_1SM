// Script: converte-codigo-em-txt-unico (v10)
// Gerado em: 2025-05-28 09:23:06

// Diretórios (inline): main > main\java > main\java\br > main\java\br\com > main\java\br\com\fiap > main\java\br\com\fiap\gs > main\java\br\com\fiap\gs\gsapi > main\java\br\com\fiap\gs\gsapi\client > main\java\br\com\fiap\gs\gsapi\config > main\java\br\com\fiap\gs\gsapi\controller > main\java\br\com\fiap\gs\gsapi\dto > main\java\br\com\fiap\gs\gsapi\dto\geo > main\java\br\com\fiap\gs\gsapi\dto\request > main\java\br\com\fiap\gs\gsapi\dto\response > main\java\br\com\fiap\gs\gsapi\exception > main\java\br\com\fiap\gs\gsapi\mapper > main\java\br\com\fiap\gs\gsapi\model > main\java\br\com\fiap\gs\gsapi\repository > main\java\br\com\fiap\gs\gsapi\service > main\java\br\com\fiap\gs\gsapi\specification > main\resources > main\resources\static > main\resources\templates > outros > outros\bd-oracle-gs > outros\teste-postman > src > test > test\java > test\java\br > test\java\br\com > test\java\br\com\fiap > test\java\br\com\fiap\gs > test\java\br\com\fiap\gs\gsapi

// Diretórios (multi-line):
src/
    main/
        java/
            br/
                com/
                    fiap/
                        gs/
                            gsapi/
                                client/
                                config/
                                controller/
                                dto/
                                    geo/
                                    request/
                                    response/
                                exception/
                                mapper/
                                model/
                                repository/
                                service/
                                specification/
        resources/
            static/
            templates/
    outros/
        bd-oracle-gs/
        teste-postman/
    test/
        java/
            br/
                com/
                    fiap/
                        gs/
                            gsapi/

// Arquivos encontrados (tipo => caminho relativo):
// java => main\java\br\com\fiap\gs\gsapi\GsapiApplication.java
// java => main\java\br\com\fiap\gs\gsapi\client\GeoCodingClient.java
// java => main\java\br\com\fiap\gs\gsapi\client\ViaCepClient.java
// java => main\java\br\com\fiap\gs\gsapi\config\AppConfig.java
// java => main\java\br\com\fiap\gs\gsapi\config\CorsConfig.java
// java => main\java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java
// java => main\java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java
// java => main\java\br\com\fiap\gs\gsapi\controller\ClienteController.java
// java => main\java\br\com\fiap\gs\gsapi\controller\EnderecoController.java
// java => main\java\br\com\fiap\gs\gsapi\controller\EonetController.java
// java => main\java\br\com\fiap\gs\gsapi\dto\geo\GeoCoordinatesDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoGeoRequestDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\request\EonetRequestDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\response\EonetResponseDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\response\NominatimResponseDTO.java
// java => main\java\br\com\fiap\gs\gsapi\dto\response\ViaCepResponseDTO.java
// java => main\java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java
// java => main\java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java
// java => main\java\br\com\fiap\gs\gsapi\exception\ServiceUnavailableException.java
// java => main\java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java
// java => main\java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java
// java => main\java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java
// java => main\java\br\com\fiap\gs\gsapi\mapper\EonetMapper.java
// java => main\java\br\com\fiap\gs\gsapi\model\Cliente.java
// java => main\java\br\com\fiap\gs\gsapi\model\Contato.java
// java => main\java\br\com\fiap\gs\gsapi\model\Endereco.java
// java => main\java\br\com\fiap\gs\gsapi\model\Eonet.java
// java => main\java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java
// java => main\java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java
// java => main\java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java
// java => main\java\br\com\fiap\gs\gsapi\repository\EonetRepository.java
// java => main\java\br\com\fiap\gs\gsapi\service\ClienteService.java
// java => main\java\br\com\fiap\gs\gsapi\service\ContatoService.java
// java => main\java\br\com\fiap\gs\gsapi\service\EnderecoService.java
// java => main\java\br\com\fiap\gs\gsapi\service\EonetService.java

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\GsapiApplication.java | package br.com.fiap.gs.gsapi | class GsapiApplication
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi; // Pacote da sua classe principal

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.client.RestTemplateBuilder; // Import
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean; // Import
import org.springframework.web.client.RestTemplate; // Import

@SpringBootApplication
@EnableCaching
public class GsapiApplication { // Verifique o nome da sua classe principal

	public static void main(String[] args) {
		SpringApplication.run(GsapiApplication.class, args);
	}

	@Bean // Define o RestTemplate como um bean gerenciado pelo Spring
	public RestTemplate restTemplate(RestTemplateBuilder builder) {
		return builder.build();
	}
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\client\GeoCodingClient.java | package br.com.fiap.gs.gsapi.client | class GeoCodingClient
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.external.NominatimResponseDTO;
import br.com.fiap.gs.gsapi.exception.ServiceUnavailableException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.Collections;
import java.util.List;

@Component
public class GeoCodingClient {

    private static final Logger logger = LoggerFactory.getLogger(GeoCodingClient.class);
    private final RestTemplate restTemplate;

    @Value("${nominatim.api.url:https://nominatim.openstreetmap.org/search}")
    private String nominatimApiUrl;

    // Defina seu User-Agent. Importante para a política do Nominatim.
    @Value("${app.geocoding.user-agent:GSAPI_Fiap_Project/1.0 (seuemail@example.com)}")
    private String userAgent;

    @Autowired
    public GeoCodingClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public List<NominatimResponseDTO> buscarCoordenadasPorEndereco(String query) {
        if (query == null || query.trim().isEmpty()) {
            throw new IllegalArgumentException("Query de endereço não pode ser nula ou vazia.");
        }

        UriComponentsBuilder uriBuilder = UriComponentsBuilder.fromHttpUrl(nominatimApiUrl)
                .queryParam("q", query)
                .queryParam("format", "jsonv2") // ou "json" dependendo da preferência
                .queryParam("addressdetails", 1)
                .queryParam("limit", 3); // Limita a 3 resultados, pegaremos o mais relevante

        HttpHeaders headers = new HttpHeaders();
        headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
        headers.set("User-Agent", userAgent); // Essencial para Nominatim

        HttpEntity<String> entity = new HttpEntity<>(headers);
        String url = uriBuilder.toUriString();
        logger.info("Consultando Nominatim: {}", url);

        try {
            // Nominatim retorna um array JSON diretamente
            ResponseEntity<List<NominatimResponseDTO>> response = restTemplate.exchange(
                    url,
                    HttpMethod.GET,
                    entity,
                    new ParameterizedTypeReference<List<NominatimResponseDTO>>() {});

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                logger.info("Resposta do Nominatim para query '{}': {} resultados", query, response.getBody().size());
                return response.getBody();
            } else {
                logger.error("Erro ao consultar Nominatim para query '{}'. Status: {}", query, response.getStatusCode());
                throw new ServiceUnavailableException("Serviço Nominatim retornou status: " + response.getStatusCode());
            }
        } catch (HttpClientErrorException | HttpServerErrorException e) {
            logger.error("Erro HTTP ao consultar Nominatim para query '{}': {} - {}", query, e.getStatusCode(), e.getResponseBodyAsString(), e);
            throw new ServiceUnavailableException("Erro ao comunicar com o serviço Nominatim: " + e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Erro inesperado ao consultar Nominatim para query '{}': {}", query, e.getMessage(), e);
            throw new ServiceUnavailableException("Erro inesperado ao processar consulta ao Nominatim.", e);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\client\ViaCepClient.java | package br.com.fiap.gs.gsapi.client | class ViaCepClient
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.client;

import br.com.fiap.gs.gsapi.dto.external.ViaCepResponseDTO;
import br.com.fiap.gs.gsapi.exception.ServiceUnavailableException; // Criaremos esta exceção
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.RestTemplate;

@Component
public class ViaCepClient {

    private static final Logger logger = LoggerFactory.getLogger(ViaCepClient.class);

    private final RestTemplate restTemplate;

    @Value("${viacep.api.url:https://viacep.com.br/ws}") // URL base pode ser configurada no application.properties
    private String viaCepApiUrl;

    @Autowired
    public ViaCepClient(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public ViaCepResponseDTO buscarEnderecoPorCep(String cep) {
        if (cep == null || cep.trim().isEmpty()) {
            throw new IllegalArgumentException("CEP não pode ser nulo ou vazio.");
        }
        // Remove caracteres não numéricos do CEP
        String cepFormatado = cep.replaceAll("[^0-9]", "");
        if (cepFormatado.length() != 8) {
            throw new IllegalArgumentException("CEP deve conter 8 dígitos numéricos.");
        }

        String url = String.format("%s/%s/json/", viaCepApiUrl, cepFormatado);
        logger.info("Consultando ViaCEP: {}", url);

        try {
            ResponseEntity<ViaCepResponseDTO> response = restTemplate.getForEntity(url, ViaCepResponseDTO.class);

            if (response.getStatusCode().is2xxSuccessful() && response.getBody() != null) {
                if (response.getBody().isErro()) { // ViaCEP retorna "erro: true" para CEPs não encontrados
                    logger.warn("CEP {} não encontrado no ViaCEP.", cepFormatado);
                    return null; // Ou lançar uma exceção específica de CEP não encontrado
                }
                logger.info("Resposta do ViaCEP para {}: {}", cepFormatado, response.getBody());
                return response.getBody();
            } else {
                logger.error("Erro ao consultar ViaCEP para {}. Status: {}", cepFormatado, response.getStatusCode());
                throw new ServiceUnavailableException("Serviço ViaCEP retornou status: " + response.getStatusCode());
            }
        } catch (HttpClientErrorException | HttpServerErrorException e) {
            logger.error("Erro HTTP ao consultar ViaCEP para {}: {} - {}", cepFormatado, e.getStatusCode(), e.getResponseBodyAsString(), e);
            throw new ServiceUnavailableException("Erro ao comunicar com o serviço ViaCEP: " + e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Erro inesperado ao consultar ViaCEP para {}: {}", cepFormatado, e.getMessage(), e);
            throw new ServiceUnavailableException("Erro inesperado ao processar consulta ao ViaCEP.", e);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\AppConfig.java | package br.com.fiap.gs.gsapi.config | class AppConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.BufferingClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.Duration;

@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        // Configura o RestTemplate com um timeout e um interceptor para logging (opcional)
        // BufferingClientHttpRequestFactory é útil se você quiser logar o corpo da requisição/resposta
        SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
        requestFactory.setConnectTimeout((int) Duration.ofSeconds(10).toMillis());
        requestFactory.setReadTimeout((int) Duration.ofSeconds(10).toMillis());

        return builder
                .requestFactory(() -> new BufferingClientHttpRequestFactory(requestFactory))
                // .additionalInterceptors(new LoggingClientHttpRequestInterceptor()) // Crie esta classe se quiser logar
                .build();
    }

    @Bean
    public WebClient.Builder webClientBuilder() {
        // Configurações padrão para o WebClient.Builder, se necessário
        // Ex: timeouts, codecs, etc. podem ser configurados aqui globalmente
        // ou no momento da construção do WebClient específico.
        return WebClient.builder();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\CorsConfig.java | package br.com.fiap.gs.gsapi.config | class CorsConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;
import java.util.List;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    private final Environment environment;

    // Origens permitidas para produção (leia do application.properties)
    // Ex: cors.production.allowed.origins=https://meufrontend.com,https://outrofrontend.com
    @Value("${cors.production.allowed.origins:}")
    private String[] productionAllowedOrigins;

    // Origens permitidas para desenvolvimento (pode ser fixo ou também configurável)
    @Value("${cors.development.allowed.origins:http://localhost:3000,http://localhost:3001,http://127.0.0.1:3000,http://127.0.0.1:3001}")
    private String[] developmentAllowedOrigins;

    public CorsConfig(Environment environment) {
        this.environment = environment;
    }

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
        String[] allowedOriginsToUse;

        if (isProdProfileActive) {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÇÃO DE CORS PARA PRODUÇÃO <<<<<<<<<<");
            if (productionAllowedOrigins != null && productionAllowedOrigins.length > 0 &&
                    Arrays.stream(productionAllowedOrigins).anyMatch(origin -> origin != null && !origin.trim().isEmpty())) {
                allowedOriginsToUse = Arrays.stream(productionAllowedOrigins)
                        .filter(origin -> origin != null && !origin.trim().isEmpty())
                        .toArray(String[]::new);
                System.out.println("Allowed Origins (prod): " + String.join(", ", allowedOriginsToUse));
            } else {
                System.out.println("WARN: Nenhuma origem de produção VÁLIDA configurada para CORS (cors.production.allowed.origins). CORS estará altamente restrito.");
                // Por segurança, defina um fallback restrito ou nenhuma origem se não configurado
                allowedOriginsToUse = new String[]{}; // Ou uma URL de fallback muito específica
            }
        } else {
            System.out.println(">>>>>>>>>> CARREGANDO CONFIGURAÇÃO DE CORS PARA DESENVOLVIMENTO/PADRÃO <<<<<<<<<<");
            allowedOriginsToUse = developmentAllowedOrigins;
            System.out.println("Allowed Origins (dev/default): " + String.join(", ", allowedOriginsToUse));
        }

        if (allowedOriginsToUse.length > 0) {
            registry.addMapping("/**") // Aplica a todas as rotas da API
                    .allowedOrigins(allowedOriginsToUse)
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD")
                    .allowedHeaders("*") // Permite todos os cabeçalhos
                    .allowCredentials(true) // Importante se você usar cookies ou autenticação baseada em sessão
                    .maxAge(3600); // Tempo em segundos que o resultado de uma requisição pre-flight OPTIONS pode ser cacheado
        } else if (isProdProfileActive) {
            // Se em produção e nenhuma origem válida foi configurada, não adicione nenhum mapping de CORS
            // ou adicione um muito restritivo para bloquear por padrão.
            System.out.println("WARN: CORS em produção está bloqueado pois nenhuma origem válida foi configurada.");
        }
    }

    // Alternativamente, você pode usar um CorsFilter Bean se preferir uma configuração mais programática
    // ou se precisar de mais controle sobre a ordem dos filtros.
    // @Bean
    // public CorsFilter corsFilter() {
    //     UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    //     CorsConfiguration config = new CorsConfiguration();
    //     config.setAllowCredentials(true);
    //
    //     boolean isProdProfileActive = Arrays.asList(environment.getActiveProfiles()).contains("prod");
    //     if (isProdProfileActive && productionAllowedOrigins != null && productionAllowedOrigins.length > 0) {
    //         config.setAllowedOrigins(Arrays.asList(productionAllowedOrigins));
    //     } else {
    //         config.setAllowedOrigins(Arrays.asList(developmentAllowedOrigins)); // Ou use allowedOriginPatterns
    //     }
    //
    //     config.addAllowedHeader("*");
    //     config.addAllowedMethod("*"); // GET, POST, PUT, DELETE, etc.
    //     source.registerCorsConfiguration("/**", config);
    //     return new CorsFilter(source);
    // }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\OpenApiConfig.java | package br.com.fiap.gs.gsapi.config | class OpenApiConfig
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

/**
 * Classe de configuração do Springdoc OpenAPI para definir as informações detalhadas da API.
 * Isso inclui título, versão, descrição, informações de contato e licença,
 * que serão exibidos na interface do Swagger UI.
 */
@Configuration
public class OpenApiConfig {

    private static final Logger log = LoggerFactory.getLogger(OpenApiConfig.class);

    // Você pode injetar valores do application.properties se precisar
    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    @Bean
    public OpenAPI customOpenAPI() {
        log.info("🔧 Configuração personalizada do OpenAPI inicializada.");

        // Constrói a URL base do servidor dinamicamente
        String serverUrl = "http://localhost:" + serverPort + (contextPath != null ? contextPath : "");

        return new OpenAPI()
                .info(new Info()
                        .title("GS API - Alertas de Desastres Naturais") // Título da sua API
                        .version("v1.0.0") // Versão da sua API
                        .description("""
                                **API RESTful para o Global Solution FIAP 2025**

                                Esta API fornece funcionalidades para consulta de informações sobre desastres naturais
                                e gerenciamento de alertas para usuários com base em sua localização.
                                Integração com a API EONET da NASA e serviços de geolocalização.

                                **Funcionalidades Principais:**
                                - Cadastro e gerenciamento de clientes e seus endereços.
                                - Consulta de eventos de desastres naturais (via EONET).
                                - Associação de eventos de desastres a endereços de clientes.
                                - Visualização de alertas em mapas (a ser implementado no frontend).
                                """)
                        .contact(new Contact()
                                .name("Equipe GS API") // Nome da sua equipe ou seu nome
                                .email("seu-email@fiap.com.br") // Seu email de contato
                                .url("https://github.com/seu-usuario/gs-api-repo") // URL do seu projeto no GitHub
                        )
                        .license(new License()
                                .name("Apache 2.0") // Ou a licença que você escolher
                                .url("https://www.apache.org/licenses/LICENSE-2.0.html")
                        )
                )
                .servers(List.of(
                        new Server().url(serverUrl).description("Servidor Local de Desenvolvimento")
                        // Você pode adicionar outros servidores aqui (ex: homologação, produção)
                        // new Server().url("https://api.seudominio.com/gsapi").description("Servidor de Produção")
                ));
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\config\SwaggerBrowserLauncher.java | package br.com.fiap.gs.gsapi.config | class SwaggerBrowserLauncher
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

// Pacote: br.com.fiap.gs.gsapi.config
package br.com.fiap.gs.gsapi.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.context.event.EventListener;

import java.awt.Desktop;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

/**
 * Componente para abrir automaticamente o Swagger UI no navegador
 * quando a aplicação inicia em um perfil de desenvolvimento.
 */
@Configuration
@Profile("dev") // Ativa este componente apenas quando o perfil 'dev' estiver ativo
public class SwaggerBrowserLauncher {

    private static final Logger log = LoggerFactory.getLogger(SwaggerBrowserLauncher.class);

    @Value("${server.port:8080}")
    private String serverPort;

    @Value("${server.servlet.context-path:}")
    private String contextPath;

    // O caminho padrão do Swagger UI é geralmente /swagger-ui/index.html ou /swagger-ui.html
    // Verifique a propriedade springdoc.swagger-ui.path se você a customizou
    @Value("${springdoc.swagger-ui.path:/swagger-ui.html}")
    private String swaggerUiPath;

    @Value("${app.launch-swagger-on-startup:true}") // Propriedade customizada para controlar o lançamento
    private boolean launchSwaggerOnStartup;

    @EventListener(ApplicationReadyEvent.class)
    public void launchBrowserOnStartup() {
        if (!launchSwaggerOnStartup) {
            log.info("Abertura automática do Swagger UI no navegador está desabilitada via app.launch-swagger-on-startup=false.");
            return;
        }

        // Constrói a URL completa, garantindo que o contextPath seja tratado corretamente
        String effectiveContextPath = (contextPath == null || "/".equals(contextPath)) ? "" : contextPath;
        String effectiveSwaggerUiPath = swaggerUiPath.startsWith("/") ? swaggerUiPath : "/" + swaggerUiPath;

        String url = "http://localhost:" + serverPort + effectiveContextPath + effectiveSwaggerUiPath;
        log.info("Tentando abrir o Swagger UI em: {}", url);

        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                Desktop.getDesktop().browse(new URI(url));
                log.info("Navegador aberto com sucesso na URL do Swagger UI: {}", url);
            } catch (IOException | URISyntaxException e) {
                log.error("Erro ao tentar abrir o navegador para o Swagger UI (URL: {}): {}", url, e.getMessage(), e);
            }
        } else {
            log.warn("Abertura automática do navegador não é suportada neste ambiente. Acesse manualmente: {}", url);
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\controller\ClienteController.java | package br.com.fiap.gs.gsapi.controller | class ClienteController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.service.ClienteService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/api/clientes")
@Tag(name = "Clientes", description = "Endpoints para gerenciamento de clientes")
public class ClienteController {

    private final ClienteService clienteService;

    @Autowired
    public ClienteController(ClienteService clienteService) {
        this.clienteService = clienteService;
    }

    @Operation(summary = "Lista todos os clientes de forma paginada")
    @ApiResponse(responseCode = "200", description = "Lista de clientes retornada com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class)))
    @GetMapping
    public ResponseEntity<Page<ClienteResponseDTO>> listarTodosClientes(
            @PageableDefault(size = 10, sort = {"nome"}) Pageable pageable) {
        Page<ClienteResponseDTO> clientes = clienteService.listarTodos(pageable);
        return ResponseEntity.ok(clientes);
    }

    @Operation(summary = "Busca um cliente pelo seu ID")
    @ApiResponse(responseCode = "200", description = "Cliente encontrado",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Cliente não encontrado", content = @Content)
    @GetMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> buscarClientePorId(@PathVariable Long id) {
        ClienteResponseDTO cliente = clienteService.buscarPorId(id);
        return ResponseEntity.ok(cliente);
    }

    @Operation(summary = "Busca um cliente pelo seu Documento (CPF/CNPJ)")
    @ApiResponse(responseCode = "200", description = "Cliente encontrado",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Cliente não encontrado", content = @Content)
    @GetMapping("/documento/{documento}")
    public ResponseEntity<ClienteResponseDTO> buscarClientePorDocumento(@PathVariable String documento) {
        ClienteResponseDTO cliente = clienteService.buscarPorDocumento(documento);
        return ResponseEntity.ok(cliente);
    }

    @Operation(summary = "Cria um novo cliente")
    @ApiResponse(responseCode = "201", description = "Cliente criado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class)))
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos", content = @Content)
    @PostMapping
    public ResponseEntity<ClienteResponseDTO> criarCliente(
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO,
            UriComponentsBuilder uriBuilder) {
        ClienteResponseDTO clienteSalvo = clienteService.criarCliente(clienteRequestDTO);
        URI location = uriBuilder.path("/api/clientes/{id}").buildAndExpand(clienteSalvo.getIdCliente()).toUri();
        return ResponseEntity.created(location).body(clienteSalvo);
    }

    @Operation(summary = "Atualiza um cliente existente")
    @ApiResponse(responseCode = "200", description = "Cliente atualizado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ClienteResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Cliente não encontrado", content = @Content)
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos", content = @Content)
    @PutMapping("/{id}")
    public ResponseEntity<ClienteResponseDTO> atualizarCliente(
            @PathVariable Long id,
            @Valid @RequestBody ClienteRequestDTO clienteRequestDTO) {
        ClienteResponseDTO clienteAtualizado = clienteService.atualizarCliente(id, clienteRequestDTO);
        return ResponseEntity.ok(clienteAtualizado);
    }

    @Operation(summary = "Deleta um cliente pelo seu ID")
    @ApiResponse(responseCode = "204", description = "Cliente deletado com sucesso")
    @ApiResponse(responseCode = "404", description = "Cliente não encontrado", content = @Content)
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarCliente(@PathVariable Long id) {
        clienteService.deletarCliente(id);
        return ResponseEntity.noContent().build();
    }

    @Operation(summary = "Pesquisa clientes por nome ou sobrenome")
    @ApiResponse(responseCode = "200", description = "Resultado da pesquisa de clientes",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class)))
    @GetMapping("/pesquisar")
    public ResponseEntity<Page<ClienteResponseDTO>> pesquisarClientes(
            @Parameter(description = "Termo para buscar no nome ou sobrenome do cliente") @RequestParam String termo,
            @PageableDefault(size = 10, sort = {"nome"}) Pageable pageable) {
        Page<ClienteResponseDTO> clientes = clienteService.pesquisarClientes(termo, pageable);
        return ResponseEntity.ok(clientes);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\controller\EnderecoController.java | package br.com.fiap.gs.gsapi.controller | class EnderecoController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.external.ViaCepResponseDTO;
import br.com.fiap.gs.gsapi.dto.request.EnderecoGeoRequestDTO; // Importar
import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.dto.response.GeoCoordinatesDTO; // Importar
import br.com.fiap.gs.gsapi.service.EnderecoService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/api/enderecos")
@Tag(name = "Endereços", description = "Endpoints para gerenciamento de endereços")
public class EnderecoController {

    private final EnderecoService enderecoService;

    @Autowired
    public EnderecoController(EnderecoService enderecoService) {
        this.enderecoService = enderecoService;
    }

    @Operation(summary = "Lista todos os endereços de forma paginada")
    @ApiResponse(responseCode = "200", description = "Lista de endereços retornada com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = Page.class)))
    @GetMapping
    public ResponseEntity<Page<EnderecoResponseDTO>> listarTodosEnderecos(
            @PageableDefault(size = 10, sort = {"cep"}) Pageable pageable) {
        Page<EnderecoResponseDTO> enderecos = enderecoService.listarTodos(pageable);
        return ResponseEntity.ok(enderecos);
    }

    @Operation(summary = "Busca um endereço pelo seu ID")
    @ApiResponse(responseCode = "200", description = "Endereço encontrado",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Endereço não encontrado", content = @Content)
    @GetMapping("/{id}")
    public ResponseEntity<EnderecoResponseDTO> buscarEnderecoPorId(@PathVariable Long id) {
        EnderecoResponseDTO endereco = enderecoService.buscarPorId(id);
        return ResponseEntity.ok(endereco);
    }

    @Operation(summary = "Consulta dados de endereço a partir de um CEP (ViaCEP)")
    @ApiResponse(responseCode = "200", description = "Dados do CEP retornados com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = ViaCepResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "CEP não encontrado ou inválido", content = @Content)
    @ApiResponse(responseCode = "400", description = "Formato de CEP inválido", content = @Content)
    @ApiResponse(responseCode = "503", description = "Serviço ViaCEP indisponível ou erro de comunicação", content = @Content)
    @GetMapping("/consultar-cep/{cep}")
    public ResponseEntity<ViaCepResponseDTO> consultarCep(
            @Parameter(description = "CEP a ser consultado (apenas números ou formato XXXXX-XXX)", example = "01001000")
            @PathVariable String cep) {
        ViaCepResponseDTO enderecoViaCep = enderecoService.consultarDadosPorCep(cep);
        return ResponseEntity.ok(enderecoViaCep);
    }

    // Novo endpoint para calcular coordenadas
    @Operation(summary = "Calcula latitude e longitude para um endereço usando Nominatim")
    @ApiResponse(responseCode = "200", description = "Coordenadas calculadas com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = GeoCoordinatesDTO.class)))
    @ApiResponse(responseCode = "404", description = "Endereço não encontrado para geocodificação", content = @Content)
    @ApiResponse(responseCode = "400", description = "Dados de endereço insuficientes ou inválidos", content = @Content)
    @ApiResponse(responseCode = "503", description = "Serviço de geocodificação indisponível ou erro de comunicação", content = @Content)
    @PostMapping("/calcular-coordenadas")
    public ResponseEntity<GeoCoordinatesDTO> calcularCoordenadas(
            @Valid @org.springframework.web.bind.annotation.RequestBody EnderecoGeoRequestDTO enderecoGeoRequestDTO) {
        GeoCoordinatesDTO coordenadas = enderecoService.calcularCoordenadasPorEndereco(enderecoGeoRequestDTO);
        return ResponseEntity.ok(coordenadas);
    }

    @Operation(summary = "Cria um novo endereço.")
    @ApiResponse(responseCode = "201", description = "Endereço criado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class)))
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: latitude/longitude ausentes)", content = @Content)
    @PostMapping
    public ResponseEntity<EnderecoResponseDTO> criarEndereco(
            @Valid @org.springframework.web.bind.annotation.RequestBody EnderecoRequestDTO enderecoRequestDTO,
            UriComponentsBuilder uriBuilder) {
        EnderecoResponseDTO enderecoSalvo = enderecoService.criarEndereco(enderecoRequestDTO);
        URI location = uriBuilder.path("/api/enderecos/{id}").buildAndExpand(enderecoSalvo.getIdEndereco()).toUri();
        return ResponseEntity.created(location).body(enderecoSalvo);
    }

    @Operation(summary = "Atualiza um endereço existente")
    @ApiResponse(responseCode = "200", description = "Endereço atualizado com sucesso",
            content = @Content(mediaType = "application/json", schema = @Schema(implementation = EnderecoResponseDTO.class)))
    @ApiResponse(responseCode = "404", description = "Endereço não encontrado", content = @Content)
    @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos", content = @Content)
    @PutMapping("/{id}")
    public ResponseEntity<EnderecoResponseDTO> atualizarEndereco(
            @PathVariable Long id,
            @Valid @org.springframework.web.bind.annotation.RequestBody EnderecoRequestDTO enderecoRequestDTO) {
        EnderecoResponseDTO enderecoAtualizado = enderecoService.atualizarEndereco(id, enderecoRequestDTO);
        return ResponseEntity.ok(enderecoAtualizado);
    }

    @Operation(summary = "Deleta um endereço pelo seu ID")
    @ApiResponse(responseCode = "204", description = "Endereço deletado com sucesso")
    @ApiResponse(responseCode = "404", description = "Endereço não encontrado", content = @Content)
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletarEndereco(@PathVariable Long id) {
        enderecoService.deletarEndereco(id);
        return ResponseEntity.noContent().build();
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\controller\EonetController.java | package br.com.fiap.gs.gsapi.controller | class EonetController
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.controller;

import br.com.fiap.gs.gsapi.dto.request.EonetRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EonetResponseDTO;
import br.com.fiap.gs.gsapi.service.EonetService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;
import java.time.OffsetDateTime;
import java.util.List;

@RestController
@RequestMapping("/api/eonet")
@Tag(name = "EONET Eventos", description = "Endpoints para gerenciamento de eventos EONET armazenados localmente")
public class EonetController {

    private final EonetService eonetService;

    @Autowired
    public EonetController(EonetService eonetService) {
        this.eonetService = eonetService;
    }

    @Operation(summary = "Lista todos os eventos EONET armazenados, de forma paginada")
    @GetMapping
    public ResponseEntity<Page<EonetResponseDTO>> listarTodosEventosEonet(
            @PageableDefault(size = 10, sort = {"data"}, direction = org.springframework.data.domain.Sort.Direction.DESC) Pageable pageable) {
        Page<EonetResponseDTO> eventos = eonetService.listarTodosEventos(pageable);
        return ResponseEntity.ok(eventos);
    }

    @Operation(summary = "Busca um evento EONET armazenado pelo seu ID interno")
    @GetMapping("/{idInterno}")
    public ResponseEntity<EonetResponseDTO> buscarEventoPorIdInterno(@PathVariable Long idInterno) {
        EonetResponseDTO evento = eonetService.buscarEventoPorIdInterno(idInterno);
        return ResponseEntity.ok(evento);
    }

    @Operation(summary = "Busca um evento EONET armazenado pelo ID da API da NASA")
    @GetMapping("/api-id/{eonetApiId}")
    public ResponseEntity<EonetResponseDTO> buscarEventoPorEonetApiId(@PathVariable String eonetApiId) {
        EonetResponseDTO evento = eonetService.buscarEventoPorEonetApiId(eonetApiId);
        return ResponseEntity.ok(evento);
    }

    @Operation(summary = "Salva um novo evento EONET (obtido externamente) no banco local")
    @ApiResponse(responseCode = "201", description = "Evento EONET salvo com sucesso")
    @PostMapping
    public ResponseEntity<EonetResponseDTO> salvarEventoEonet(
            @Valid @RequestBody EonetRequestDTO eonetRequestDTO,
            UriComponentsBuilder uriBuilder) {
        EonetResponseDTO eventoSalvo = eonetService.salvarEvento(eonetRequestDTO);
        URI location = uriBuilder.path("/api/eonet/{idInterno}").buildAndExpand(eventoSalvo.getIdEonet()).toUri();
        return ResponseEntity.created(location).body(eventoSalvo);
    }

    @Operation(summary = "Atualiza um evento EONET existente no banco local")
    @PutMapping("/{idInterno}")
    public ResponseEntity<EonetResponseDTO> atualizarEventoEonet(
            @PathVariable Long idInterno,
            @Valid @RequestBody EonetRequestDTO eonetRequestDTO) {
        EonetResponseDTO eventoAtualizado = eonetService.atualizarEvento(idInterno, eonetRequestDTO);
        return ResponseEntity.ok(eventoAtualizado);
    }

    @Operation(summary = "Deleta um evento EONET do banco local pelo seu ID interno")
    @DeleteMapping("/{idInterno}")
    public ResponseEntity<Void> deletarEventoEonet(@PathVariable Long idInterno) {
        eonetService.deletarEvento(idInterno);
        return ResponseEntity.noContent().build();
    }

    @Operation(summary = "Busca eventos EONET armazenados dentro de um intervalo de datas")
    @GetMapping("/por-data")
    public ResponseEntity<List<EonetResponseDTO>> buscarEventosPorIntervaloDeData(
            @Parameter(description = "Data inicial do evento (formato ISO OffsetDateTime: yyyy-MM-dd'T'HH:mm:ssXXX)", required = true)
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.OFFSET_DATE_TIME) OffsetDateTime dataInicial,
            @Parameter(description = "Data final do evento (formato ISO OffsetDateTime: yyyy-MM-dd'T'HH:mm:ssXXX)", required = true)
            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.OFFSET_DATE_TIME) OffsetDateTime dataFinal) {
        List<EonetResponseDTO> eventos = eonetService.buscarEventosPorIntervaloDeData(dataInicial, dataFinal);
        return ResponseEntity.ok(eventos);
    }

    /*
    @Operation(summary = "Busca novos eventos da API da NASA e os persiste localmente (simulado)")
    @PostMapping("/nasa/sincronizar")
    public ResponseEntity<List<EonetResponseDTO>> sincronizarEventosDaNasa(
            @RequestParam(defaultValue = "10") Integer limit,
            @RequestParam(defaultValue = "open") String status) {
        // List<EonetResponseDTO> novosEventos = eonetService.buscarEpersistirNovosEventosDaNasa(limit, status);
        // return ResponseEntity.ok(novosEventos);
        return ResponseEntity.status(HttpStatus.NOT_IMPLEMENTED).build(); // Placeholder
    }
    */
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\geo\GeoCoordinatesDTO.java | package br.com.fiap.gs.gsapi.dto.response | class GeoCoordinatesDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response; // Ou br.com.fiap.gs.gsapi.dto.geo

public class GeoCoordinatesDTO {
    private double latitude;
    private double longitude;
    private String matchedAddress; // O endereço que o serviço de geocodificação identificou

    public GeoCoordinatesDTO() {
    }

    public GeoCoordinatesDTO(double latitude, double longitude, String matchedAddress) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.matchedAddress = matchedAddress;
    }

    // Getters e Setters
    public double getLatitude() {
        return latitude;
    }

    public void setLatitude(double latitude) {
        this.latitude = latitude;
    }

    public double getLongitude() {
        return longitude;
    }

    public void setLongitude(double longitude) {
        this.longitude = longitude;
    }

    public String getMatchedAddress() {
        return matchedAddress;
    }

    public void setMatchedAddress(String matchedAddress) {
        this.matchedAddress = matchedAddress;
    }

    @Override
    public String toString() {
        return "GeoCoordinatesDTO{" +
                "latitude=" + latitude +
                ", longitude=" + longitude +
                ", matchedAddress='" + matchedAddress + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\ClienteRequestDTO.java | package br.com.fiap.gs.gsapi.dto.request | class ClienteRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import java.time.LocalDate;
import java.util.List;

public class ClienteRequestDTO {

    @NotBlank(message = "O nome não pode estar em branco.")
    @Size(min = 2, max = 100, message = "O nome deve ter entre 2 e 100 caracteres.")
    private String nome;

    @NotBlank(message = "O sobrenome não pode estar em branco.")
    @Size(min = 2, max = 100, message = "O sobrenome deve ter entre 2 e 100 caracteres.")
    private String sobrenome;

    // Para dataNascimento, se fosse LocalDate:
    // @NotNull(message = "A data de nascimento não pode ser nula.")
    // @PastOrPresent(message = "A data de nascimento deve ser no passado ou presente.")
    // private LocalDate dataNascimento;

    @NotBlank(message = "A data de nascimento não pode estar em branco.")
    @Pattern(regexp = "^\\d{2}/\\d{2}/\\d{4}$", message = "A data de nascimento deve estar no formato dd/MM/yyyy.")
    private String dataNascimento; // Mantendo como String por ora, conforme entidade

    @NotBlank(message = "O documento não pode estar em branco.")
    @Size(min = 11, max = 18, message = "O documento deve ter entre 11 (CPF) e 18 (CNPJ com máscara) caracteres.")
    // Poderia adicionar @Pattern para CPF/CNPJ aqui se necessário
    private String documento;

    // IDs dos contatos e endereços existentes a serem associados
    // Ou, se for para criar contatos/endereços junto com cliente, seriam DTOs de Contato/Endereco aqui
    private List<Long> contatosIds;
    private List<Long> enderecosIds;


    // Construtor Padrão (necessário para desserialização)
    public ClienteRequestDTO() {
    }

    // Construtor com todos os campos
    public ClienteRequestDTO(String nome, String sobrenome, String dataNascimento, String documento, List<Long> contatosIds, List<Long> enderecosIds) {
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
        this.documento = documento;
        this.contatosIds = contatosIds;
        this.enderecosIds = enderecosIds;
    }


    // Getters e Setters
    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getSobrenome() {
        return sobrenome;
    }

    public void setSobrenome(String sobrenome) {
        this.sobrenome = sobrenome;
    }

    public String getDataNascimento() {
        return dataNascimento;
    }

    public void setDataNascimento(String dataNascimento) {
        this.dataNascimento = dataNascimento;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public List<Long> getContatosIds() {
        return contatosIds;
    }

    public void setContatosIds(List<Long> contatosIds) {
        this.contatosIds = contatosIds;
    }

    public List<Long> getEnderecosIds() {
        return enderecosIds;
    }

    public void setEnderecosIds(List<Long> enderecosIds) {
        this.enderecosIds = enderecosIds;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\ContatoRequestDTO.java | package br.com.fiap.gs.gsapi.dto.request | class ContatoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

public class ContatoRequestDTO {

    @NotBlank(message = "O DDD não pode estar em branco.")
    @Size(min = 2, max = 3, message = "O DDD deve ter entre 2 e 3 caracteres.")
    private String ddd;

    @NotBlank(message = "O telefone não pode estar em branco.")
    @Size(min = 8, max = 15, message = "O telefone deve ter entre 8 e 15 caracteres.")
    @Pattern(regexp = "^[0-9]+$", message = "O telefone deve conter apenas números.")
    private String telefone;

    @NotBlank(message = "O celular não pode estar em branco.")
    @Size(min = 9, max = 15, message = "O celular deve ter entre 9 e 15 caracteres.")
    @Pattern(regexp = "^[0-9]+$", message = "O celular deve conter apenas números.")
    private String celular;

    @NotBlank(message = "O WhatsApp não pode estar em branco.")
    @Size(min = 9, max = 15, message = "O WhatsApp deve ter entre 9 e 15 caracteres.")
    @Pattern(regexp = "^[0-9]+$", message = "O WhatsApp deve conter apenas números.")
    private String whatsapp;

    @NotBlank(message = "O e-mail não pode estar em branco.")
    @Email(message = "O e-mail deve ser válido.")
    @Size(max = 255, message = "O e-mail não pode exceder 255 caracteres.")
    private String email;

    @NotBlank(message = "O tipo de contato não pode estar em branco.")
    @Size(max = 50, message = "O tipo de contato não pode exceder 50 caracteres.")
    private String tipoContato;

    // Getters e Setters
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoGeoRequestDTO.java | package br.com.fiap.gs.gsapi.dto.request | class EnderecoGeoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class EnderecoGeoRequestDTO {

    @NotBlank(message = "Logradouro é obrigatório para geocodificação.")
    @Size(max = 255)
    private String logradouro;

    @Size(max = 10) // Número pode ser opcional ou parte do logradouro para Nominatim
    private String numero;

    @NotBlank(message = "Cidade (Localidade) é obrigatória para geocodificação.")
    @Size(max = 100)
    private String cidade; // Localidade

    @NotBlank(message = "UF (Estado) é obrigatória para geocodificação.")
    @Size(min = 2, max = 2)
    private String uf;

    @Size(max = 100) // Bairro pode ajudar na precisão
    private String bairro;

    @Size(max = 9) // CEP pode ajudar na precisão
    private String cep;

    // Construtor padrão
    public EnderecoGeoRequestDTO() {}

    // Getters e Setters
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getNumero() { return numero; }
    public void setNumero(String numero) { this.numero = numero; }
    public String getCidade() { return cidade; }
    public void setCidade(String cidade) { this.cidade = cidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\EnderecoRequestDTO.java | package br.com.fiap.gs.gsapi.dto.request | class EnderecoRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Digits;


public class EnderecoRequestDTO {

    @NotBlank(message = "O CEP não pode estar em branco.")
    @Pattern(regexp = "^\\d{5}-?\\d{3}$", message = "O CEP deve estar no formato XXXXX-XXX ou XXXXXXXX.")
    private String cep;

    @NotNull(message = "O número não pode ser nulo.")
    // @Digits(integer = 5, fraction = 0, message = "O número deve ser um inteiro de até 5 dígitos.") // Se fosse string
    private Integer numero; // NUMBER(5)

    @NotBlank(message = "O logradouro não pode estar em branco.")
    @Size(max = 255, message = "O logradouro não pode exceder 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O bairro não pode estar em branco.")
    @Size(max = 255, message = "O bairro não pode exceder 255 caracteres.")
    private String bairro;

    @NotBlank(message = "A localidade (cidade) não pode estar em branco.")
    @Size(max = 100, message = "A localidade não pode exceder 100 caracteres.")
    private String localidade;

    @NotBlank(message = "A UF não pode estar em branco.")
    @Size(min = 2, max = 2, message = "A UF deve ter 2 caracteres.")
    private String uf;

    @NotBlank(message = "O complemento não pode estar em branco.") // DDL diz NOT NULL
    @Size(max = 255, message = "O complemento não pode exceder 255 caracteres.")
    private String complemento;

    // Latitude e Longitude serão preenchidas pelo ViaCEP/outra API,
    // então não são obrigatórias na requisição inicial do usuário,
    // mas podem ser enviadas se já conhecidas.
    @NotNull(message = "Latitude não pode ser nula.")
    @Digits(integer = 3, fraction = 7, message = "Latitude inválida.") // ex: -90.1234567
    private Double latitude;

    @NotNull(message = "Longitude não pode ser nula.")
    @Digits(integer = 4, fraction = 7, message = "Longitude inválida.") // ex: -180.1234567
    private Double longitude;


    // Getters e Setters
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public Integer getNumero() { return numero; }
    public void setNumero(Integer numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public Double getLatitude() { return latitude; }
    public void setLatitude(Double latitude) { this.latitude = latitude; }
    public Double getLongitude() { return longitude; }
    public void setLongitude(Double longitude) { this.longitude = longitude; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\request\EonetRequestDTO.java | package br.com.fiap.gs.gsapi.dto.request | class EonetRequestDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.request; // Ajuste o pacote conforme sua estrutura

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import java.time.OffsetDateTime;

public class EonetRequestDTO {

    // O JSON pode ser grande, então não há @Size aqui,
    // mas pode ser @NotNull se o JSON sempre for esperado na criação.
    // Se o JSON for opcional na criação, remova @NotNull.
    @NotNull(message = "O conteúdo JSON não pode ser nulo.")
    private String json; // Para o campo CLOB

    // A data do evento pode ser opcional ou obrigatória dependendo do seu caso de uso.
    // Se for obrigatória na criação:
    @NotNull(message = "A data do evento não pode ser nula.")
    private OffsetDateTime data;

    @NotBlank(message = "O ID da API EONET não pode estar em branco.")
    @Size(max = 50, message = "O ID da API EONET não pode exceder 50 caracteres.")
    private String eonetIdApi; // ID único do evento vindo da API da NASA

    // Construtor Padrão
    public EonetRequestDTO() {
    }

    // Construtor Completo (opcional)
    public EonetRequestDTO(String json, OffsetDateTime data, String eonetIdApi) {
        this.json = json;
        this.data = data;
        this.eonetIdApi = eonetIdApi;
    }

    // Getters e Setters
    public String getJson() {
        return json;
    }

    public void setJson(String json) {
        this.json = json;
    }

    public OffsetDateTime getData() {
        return data;
    }

    public void setData(OffsetDateTime data) {
        this.data = data;
    }

    public String getEonetIdApi() {
        return eonetIdApi;
    }

    public void setEonetIdApi(String eonetIdApi) {
        this.eonetIdApi = eonetIdApi;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\ClienteResponseDTO.java | package br.com.fiap.gs.gsapi.dto.response | class ClienteResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;

import java.util.List;

public class ClienteResponseDTO {

    private Long idCliente;
    private String nome;
    private String sobrenome;
    private String dataNascimento;
    private String documento;
    private List<ContatoResponseDTO> contatos; // Usaremos DTOs para os relacionamentos também
    private List<br.com.fiap.gs.gsapi.dto.EnderecoResponseDTO> enderecos;

    // Construtor Padrão
    public ClienteResponseDTO() {
    }

    // Construtor com todos os campos
    public ClienteResponseDTO(Long idCliente, String nome, String sobrenome, String dataNascimento, String documento, List<ContatoResponseDTO> contatos, List<EnderecoResponseDTO> enderecos) {
        this.idCliente = idCliente;
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
        this.documento = documento;
        this.contatos = contatos;
        this.enderecos = enderecos;
    }


    // Getters e Setters
    public Long getIdCliente() {
        return idCliente;
    }

    public void setIdCliente(Long idCliente) {
        this.idCliente = idCliente;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getSobrenome() {
        return sobrenome;
    }

    public void setSobrenome(String sobrenome) {
        this.sobrenome = sobrenome;
    }

    public String getDataNascimento() {
        return dataNascimento;
    }

    public void setDataNascimento(String dataNascimento) {
        this.dataNascimento = dataNascimento;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public List<ContatoResponseDTO> getContatos() {
        return contatos;
    }

    public void setContatos(List<ContatoResponseDTO> contatos) {
        this.contatos = contatos;
    }

    public List<br.com.fiap.gs.gsapi.dto.EnderecoResponseDTO> getEnderecos() {
        return enderecos;
    }

    public void setEnderecos(List<br.com.fiap.gs.gsapi.dto.EnderecoResponseDTO> enderecos) {
        this.enderecos = enderecos;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\ContatoResponseDTO.java | package br.com.fiap.gs.gsapi.dto.response | class ContatoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

public class ContatoResponseDTO {
    private Long idContato;
    private String ddd;
    private String telefone;
    private String celular;
    private String whatsapp;
    private String email;
    private String tipoContato;

    // Construtores, Getters e Setters
    public ContatoResponseDTO() {}

    public ContatoResponseDTO(Long idContato, String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.idContato = idContato;
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    public Long getIdContato() { return idContato; }
    public void setIdContato(Long idContato) { this.idContato = idContato; }
    public String getDdd() { return ddd; }
    public void setDdd(String ddd) { this.ddd = ddd; }
    public String getTelefone() { return telefone; }
    public void setTelefone(String telefone) { this.telefone = telefone; }
    public String getCelular() { return celular; }
    public void setCelular(String celular) { this.celular = celular; }
    public String getWhatsapp() { return whatsapp; }
    public void setWhatsapp(String whatsapp) { this.whatsapp = whatsapp; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public String getTipoContato() { return tipoContato; }
    public void setTipoContato(String tipoContato) { this.tipoContato = tipoContato; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\EnderecoResponseDTO.java | package br.com.fiap.gs.gsapi.dto.response | class EnderecoResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response;

public class EnderecoResponseDTO {
    private Long idEndereco;
    private String cep;
    private Integer numero;
    private String logradouro;
    private String bairro;
    private String localidade;
    private String uf;
    private String complemento;
    private Double latitude;
    private Double longitude;

    // Construtores, Getters e Setters
    public EnderecoResponseDTO() {}

    public EnderecoResponseDTO(Long idEndereco, String cep, Integer numero, String logradouro, String bairro, String localidade, String uf, String complemento, Double latitude, Double longitude) {
        this.idEndereco = idEndereco;
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    public Long getIdEndereco() { return idEndereco; }
    public void setIdEndereco(Long idEndereco) { this.idEndereco = idEndereco; }
    public String getCep() { return cep; }
    public void setCep(String cep) { this.cep = cep; }
    public Integer getNumero() { return numero; }
    public void setNumero(Integer numero) { this.numero = numero; }
    public String getLogradouro() { return logradouro; }
    public void setLogradouro(String logradouro) { this.logradouro = logradouro; }
    public String getBairro() { return bairro; }
    public void setBairro(String bairro) { this.bairro = bairro; }
    public String getLocalidade() { return localidade; }
    public void setLocalidade(String localidade) { this.localidade = localidade; }
    public String getUf() { return uf; }
    public void setUf(String uf) { this.uf = uf; }
    public String getComplemento() { return complemento; }
    public void setComplemento(String complemento) { this.complemento = complemento; }
    public Double getLatitude() { return latitude; }
    public void setLatitude(Double latitude) { this.latitude = latitude; }
    public Double getLongitude() { return longitude; }
    public void setLongitude(Double longitude) { this.longitude = longitude; }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\EonetResponseDTO.java | package br.com.fiap.gs.gsapi.dto.response | class EonetResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.response; // Ajuste o pacote conforme sua estrutura

import br.com.fiap.gs.gsapi.model.Eonet; // Import necessário para o construtor
import java.time.OffsetDateTime;

public class EonetResponseDTO {

    private Long idEonet; // ID interno do seu banco
    private String json;
    private OffsetDateTime data;
    private String eonetIdApi; // ID da API da NASA

    // Construtor Padrão
    public EonetResponseDTO() {
    }

    // Construtor para facilitar a conversão da Entidade para DTO
    public EonetResponseDTO(Eonet eonet) {
        this.idEonet = eonet.getIdEonet();
        this.json = eonet.getJson(); // Pode ser necessário truncar ou tratar se for muito grande para logs
        this.data = eonet.getData();
        this.eonetIdApi = eonet.getEonetIdApi();
    }

    // Getters e Setters
    public Long getIdEonet() {
        return idEonet;
    }

    public void setIdEonet(Long idEonet) {
        this.idEonet = idEonet;
    }

    public String getJson() {
        return json;
    }

    public void setJson(String json) {
        this.json = json;
    }

    public OffsetDateTime getData() {
        return data;
    }

    public void setData(OffsetDateTime data) {
        this.data = data;
    }

    public String getEonetIdApi() {
        return eonetIdApi;
    }

    public void setEonetIdApi(String eonetIdApi) {
        this.eonetIdApi = eonetIdApi;
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\NominatimResponseDTO.java | package br.com.fiap.gs.gsapi.dto.external | class NominatimResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

@JsonIgnoreProperties(ignoreUnknown = true)
public class NominatimResponseDTO {

    @JsonProperty("place_id")
    private long placeId;

    @JsonProperty("licence")
    private String licence;

    @JsonProperty("osm_type")
    private String osmType;

    @JsonProperty("osm_id")
    private long osmId;

    @JsonProperty("lat")
    private String latitude; // Nominatim retorna como String

    @JsonProperty("lon")
    private String longitude; // Nominatim retorna como String

    @JsonProperty("display_name")
    private String displayName;

    @JsonProperty("boundingbox")
    private String[] boundingBox;

    // Construtor padrão
    public NominatimResponseDTO() {
    }

    // Getters e Setters
    public long getPlaceId() {
        return placeId;
    }

    public void setPlaceId(long placeId) {
        this.placeId = placeId;
    }

    public String getLicence() {
        return licence;
    }

    public void setLicence(String licence) {
        this.licence = licence;
    }

    public String getOsmType() {
        return osmType;
    }

    public void setOsmType(String osmType) {
        this.osmType = osmType;
    }

    public long getOsmId() {
        return osmId;
    }

    public void setOsmId(long osmId) {
        this.osmId = osmId;
    }

    public String getLatitude() {
        return latitude;
    }

    public void setLatitude(String latitude) {
        this.latitude = latitude;
    }

    public String getLongitude() {
        return longitude;
    }

    public void setLongitude(String longitude) {
        this.longitude = longitude;
    }

    public String getDisplayName() {
        return displayName;
    }

    public void setDisplayName(String displayName) {
        this.displayName = displayName;
    }

    public String[] getBoundingBox() {
        return boundingBox;
    }

    public void setBoundingBox(String[] boundingBox) {
        this.boundingBox = boundingBox;
    }

    @Override
    public String toString() {
        return "NominatimResponseDTO{" +
                "latitude='" + latitude + '\'' +
                ", longitude='" + longitude + '\'' +
                ", displayName='" + displayName + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\dto\response\ViaCepResponseDTO.java | package br.com.fiap.gs.gsapi.dto.external | class ViaCepResponseDTO
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.dto.external; // Ou seu pacote de DTOs

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

@JsonIgnoreProperties(ignoreUnknown = true) // Importante para ignorar campos não mapeados do JSON do ViaCEP
public class ViaCepResponseDTO {

    private String cep;
    private String logradouro;
    private String complemento;
    private String bairro;
    private String localidade; // Cidade
    private String uf;
    private String ibge;
    private String gia;
    private String ddd;
    private String siafi;
    private boolean erro; // Campo que o ViaCEP retorna se o CEP não for encontrado

    // Construtores
    public ViaCepResponseDTO() {
    }

    // Getters e Setters (essenciais para o Jackson desserializar)
    public String getCep() {
        return cep;
    }

    public void setCep(String cep) {
        this.cep = cep;
    }

    public String getLogradouro() {
        return logradouro;
    }

    public void setLogradouro(String logradouro) {
        this.logradouro = logradouro;
    }

    public String getComplemento() {
        return complemento;
    }

    public void setComplemento(String complemento) {
        this.complemento = complemento;
    }

    public String getBairro() {
        return bairro;
    }

    public void setBairro(String bairro) {
        this.bairro = bairro;
    }

    public String getLocalidade() {
        return localidade;
    }

    public void setLocalidade(String localidade) {
        this.localidade = localidade;
    }

    public String getUf() {
        return uf;
    }

    public void setUf(String uf) {
        this.uf = uf;
    }

    public String getIbge() {
        return ibge;
    }

    public void setIbge(String ibge) {
        this.ibge = ibge;
    }

    public String getGia() {
        return gia;
    }

    public void setGia(String gia) {
        this.gia = gia;
    }

    public String getDdd() {
        return ddd;
    }

    public void setDdd(String ddd) {
        this.ddd = ddd;
    }

    public String getSiafi() {
        return siafi;
    }

    public void setSiafi(String siafi) {
        this.siafi = siafi;
    }

    public boolean isErro() {
        return erro;
    }

    public void setErro(boolean erro) {
        this.erro = erro;
    }

    @Override
    public String toString() {
        return "ViaCepResponseDTO{" +
                "cep='" + cep + '\'' +
                ", logradouro='" + logradouro + '\'' +
                ", complemento='" + complemento + '\'' +
                ", bairro='" + bairro + '\'' +
                ", localidade='" + localidade + '\'' +
                ", uf='" + uf + '\'' +
                ", ibge='" + ibge + '\'' +
                ", gia='" + gia + '\'' +
                ", ddd='" + ddd + '\'' +
                ", siafi='" + siafi + '\'' +
                ", erro=" + erro +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\exception\GlobalExceptionHandler.java | package br.com.fiap.gs.gsapi.exception | class GlobalExceptionHandler
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.exception;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<Object> handleResourceNotFoundException(
            ResourceNotFoundException ex, WebRequest request) {

        logger.warn("Recurso não encontrado: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.NOT_FOUND.value());
        body.put("error", "Not Found");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));

        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Object> handleMethodArgumentNotValid(
            MethodArgumentNotValidException ex, WebRequest request) {

        logger.warn("Erro de validação nos argumentos: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request - Validation Error");
        body.put("path", request.getDescription(false).replace("uri=", ""));

        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.toList());

        body.put("messages", errors);

        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Object> handleIllegalArgumentException(
            IllegalArgumentException ex, WebRequest request) {

        logger.warn("Argumento ilegal ou requisição inválida: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.BAD_REQUEST.value());
        body.put("error", "Bad Request");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));

        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(IllegalStateException.class)
    public ResponseEntity<Object> handleIllegalStateException(
            IllegalStateException ex, WebRequest request) {

        logger.warn("Estado ilegal para a operação: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.CONFLICT.value());
        body.put("error", "Conflict");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));

        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }

    @ExceptionHandler(ServiceUnavailableException.class) // Handler adicionado
    public ResponseEntity<Object> handleServiceUnavailableException(
            ServiceUnavailableException ex, WebRequest request) {

        logger.error("Serviço externo indisponível ou erro de comunicação: {}", ex.getMessage());
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.SERVICE_UNAVAILABLE.value());
        body.put("error", "Service Unavailable");
        body.put("message", ex.getMessage());
        body.put("path", request.getDescription(false).replace("uri=", ""));

        return new ResponseEntity<>(body, HttpStatus.SERVICE_UNAVAILABLE);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<Object> handleGenericException(
            Exception ex, WebRequest request) {

        logger.error("Erro inesperado na aplicação: ", ex);
        Map<String, Object> body = new LinkedHashMap<>();
        body.put("timestamp", LocalDateTime.now());
        body.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        body.put("error", "Internal Server Error");
        body.put("message", "Ocorreu um erro inesperado. Por favor, tente novamente mais tarde.");
        body.put("path", request.getDescription(false).replace("uri=", ""));

        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\exception\ResourceNotFoundException.java | package br.com.fiap.gs.gsapi.exception | class ResourceNotFoundException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND) // Mapeia esta exceção para o status HTTP 404 Not Found
public class ResourceNotFoundException extends RuntimeException {

    /**
     * Construtor que aceita uma mensagem para a exceção.
     * @param message A mensagem detalhando a causa da exceção.
     */
    public ResourceNotFoundException(String message) {
        super(message);
    }

    /**
     * Construtor que aceita uma mensagem e a causa original da exceção.
     * @param message A mensagem detalhando a causa da exceção.
     * @param cause A causa original (outra exceção que levou a esta).
     */
    public ResourceNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\exception\ServiceUnavailableException.java | package br.com.fiap.gs.gsapi.exception | class ServiceUnavailableException
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.SERVICE_UNAVAILABLE)
public class ServiceUnavailableException extends RuntimeException {
    public ServiceUnavailableException(String message) {
        super(message);
    }

    public ServiceUnavailableException(String message, Throwable cause) {
        super(message, cause);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\ClienteMapper.java | package br.com.fiap.gs.gsapi.mapper | class ClienteMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.model.Cliente;
import br.com.fiap.gs.gsapi.model.Contato; // Necessário para extrair IDs
import br.com.fiap.gs.gsapi.model.Endereco; // Necessário para extrair IDs

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Mappings;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import java.util.Set;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring", uses = {ContatoMapper.class, EnderecoMapper.class})
public interface ClienteMapper {

    ClienteMapper INSTANCE = Mappers.getMapper(ClienteMapper.class);

    @Mappings({
            @Mapping(source = "contatos", target = "contatos", qualifiedByName = "contatosToContatoResponseDTOs"),
            @Mapping(source = "enderecos", target = "enderecos", qualifiedByName = "enderecosToEnderecoResponseDTOs")
    })
    ClienteResponseDTO toResponseDTO(Cliente cliente);

    @Mappings({
            @Mapping(target = "idCliente", ignore = true), // IDs são gerados pelo banco
            @Mapping(source = "contatosIds", target = "contatos", qualifiedByName = "idsToContatos"),
            @Mapping(source = "enderecosIds", target = "enderecos", qualifiedByName = "idsToEnderecos")
    })
    Cliente toEntity(ClienteRequestDTO clienteRequestDTO);

    // Métodos nomeados para lidar com coleções de IDs para Entidades
    // Esta é uma forma. Outra seria injetar os repositórios no mapper ou fazer no serviço.
    // Para MapStruct puro, é mais complexo lidar com buscas no DB diretamente.
    // Por simplicidade, a lógica de buscar Contatos/Enderecos por IDs ainda será feita no serviço
    // e o mapper pode ser usado para o restante, ou o serviço pode passar as entidades já carregadas.
    // Vamos manter a lógica de carregamento de entidades por ID no serviço por enquanto
    // e ajustar o toEntity para ignorar contatosIds e enderecosIds,
    // já que o serviço irá tratar essa associação.

    // Simplificando toEntity para o que o MapStruct pode fazer diretamente:
    @Mappings({
            @Mapping(target = "idCliente", ignore = true),
            @Mapping(target = "contatos", ignore = true), // Será tratado no serviço
            @Mapping(target = "enderecos", ignore = true) // Será tratado no serviço
    })
    Cliente requestToEntity(ClienteRequestDTO clienteRequestDTO);

    // Se você tiver ContatoMapper e EnderecoMapper, MapStruct pode usar eles para coleções:
    // ClienteResponseDTO toResponseDTO(Cliente cliente); // MapStruct cuidará das listas se os mappers individuais existirem.
    // Cliente toEntity(ClienteRequestDTO clienteRequestDTO);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\ContatoMapper.java | package br.com.fiap.gs.gsapi.mapper | class ContatoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.model.Contato;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring")
public interface ContatoMapper {

    ContatoMapper INSTANCE = Mappers.getMapper(ContatoMapper.class);

    ContatoResponseDTO toResponseDTO(Contato contato);

    Set<ContatoResponseDTO> toResponseDTOSet(Set<Contato> contatos); // Para coleções

    List<ContatoResponseDTO> toResponseDTOList(List<Contato> contatos); // Para coleções

    @Mapping(target = "idContato", ignore = true) // ID é gerado pelo banco
    @Mapping(target = "clientes", ignore = true) // Lado inverso, gerenciado pelo Cliente
    Contato toEntity(ContatoRequestDTO contatoRequestDTO);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\EnderecoMapper.java | package br.com.fiap.gs.gsapi.mapper | class EnderecoMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.model.Endereco;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

@Mapper(componentModel = "spring")
public interface EnderecoMapper {

    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    EnderecoResponseDTO toResponseDTO(Endereco endereco);

    Set<EnderecoResponseDTO> toResponseDTOSet(Set<Endereco> enderecos); // Para coleções

    List<EnderecoResponseDTO> toResponseDTOList(List<Endereco> enderecos); // Para coleções

    @Mapping(target = "idEndereco", ignore = true) // ID é gerado pelo banco
    @Mapping(target = "clientes", ignore = true)    // Lado inverso, gerenciado pelo Cliente
    @Mapping(target = "eventosEonet", ignore = true) // Relacionamento gerenciado aqui ou via serviço dedicado
    Endereco toEntity(EnderecoRequestDTO enderecoRequestDTO);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\mapper\EonetMapper.java | package br.com.fiap.gs.gsapi.mapper | class EonetMapper
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.mapper;

import br.com.fiap.gs.gsapi.dto.request.EonetRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EonetResponseDTO;
import br.com.fiap.gs.gsapi.model.Eonet;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

@Mapper(componentModel = "spring")
public interface EonetMapper {

    EonetMapper INSTANCE = Mappers.getMapper(EonetMapper.class);

    EonetResponseDTO toResponseDTO(Eonet eonet);

    @Mapping(target = "idEonet", ignore = true)
    @Mapping(target = "enderecos", ignore = true) // Relacionamento gerenciado pelo Endereco
    Eonet toEntity(EonetRequestDTO eonetRequestDTO);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Cliente.java | package br.com.fiap.gs.gsapi.model | class Cliente
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "tb_cliente3")
public class Cliente {

    @Id
    @SequenceGenerator(name = "cliente_seq", sequenceName = "tb_cliente3_id_cliente_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "cliente_seq")
    @Column(name = "id_cliente")
    private Long idCliente; // Mapeia para id_cliente NUMBER NOT NULL [cite: 2]

    @Column(name = "nome", nullable = false, length = 100)
    private String nome; // Mapeia para nome VARCHAR2(100) NOT NULL [cite: 2]

    @Column(name = "sobrenome", nullable = false, length = 100)
    private String sobrenome; // Mapeia para sobrenome VARCHAR2(100) NOT NULL [cite: 1]

    @Column(name = "data_nascimento", nullable = false, length = 10)
    private String dataNascimento; // Mapeia para data_nascimento VARCHAR2(10) NOT NULL [cite: 1]

    @Column(name = "documento", nullable = false, length = 18)
    private String documento; // Mapeia para documento VARCHAR2(18) NOT NULL [cite: 1]

    @ManyToMany(fetch = FetchType.LAZY,
            cascade = {
                    CascadeType.PERSIST,
                    CascadeType.MERGE
            })
    @JoinTable(name = "tb_clientecontato3", // Tabela de junção [cite: 4]
            joinColumns = { @JoinColumn(name = "tb_cliente3_id_cliente") }, // FK para tb_cliente3 [cite: 4, 17]
            inverseJoinColumns = { @JoinColumn(name = "tb_contato3_id_contato") }) // FK para tb_contato3 [cite: 4, 18]
    private Set<Contato> contatos = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY,
            cascade = {
                    CascadeType.PERSIST,
                    CascadeType.MERGE
            })
    @JoinTable(name = "tb_clienteendereco3", // Tabela de junção [cite: 6]
            joinColumns = { @JoinColumn(name = "tb_cliente3_id_cliente") }, // FK para tb_cliente3 [cite: 6, 19]
            inverseJoinColumns = { @JoinColumn(name = "tb_endereco3_id_endereco") }) // FK para tb_endereco3 [cite: 6, 20]
    private Set<Endereco> enderecos = new HashSet<>();

    // Construtor padrão (exigido pela JPA)
    public Cliente() {
    }

    // Construtor para criar um novo cliente
    public Cliente(String nome, String sobrenome, String dataNascimento, String documento) {
        this.nome = nome;
        this.sobrenome = sobrenome;
        this.dataNascimento = dataNascimento;
        this.documento = documento;
    }

    // Getters e Setters
    public Long getIdCliente() {
        return idCliente;
    }

    public void setIdCliente(Long idCliente) {
        this.idCliente = idCliente;
    }

    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        this.nome = nome;
    }

    public String getSobrenome() {
        return sobrenome;
    }

    public void setSobrenome(String sobrenome) {
        this.sobrenome = sobrenome;
    }

    public String getDataNascimento() {
        return dataNascimento;
    }

    public void setDataNascimento(String dataNascimento) {
        this.dataNascimento = dataNascimento;
    }

    public String getDocumento() {
        return documento;
    }

    public void setDocumento(String documento) {
        this.documento = documento;
    }

    public Set<Contato> getContatos() {
        return contatos;
    }

    public void setContatos(Set<Contato> contatos) {
        this.contatos = contatos;
    }

    public Set<Endereco> getEnderecos() {
        return enderecos;
    }

    public void setEnderecos(Set<Endereco> enderecos) {
        this.enderecos = enderecos;
    }

    // Métodos auxiliares para gerenciar relacionamentos (opcional, mas útil)
    public void addContato(Contato contato) {
        this.contatos.add(contato);
        // Se Contato tivesse uma referência de volta para Cliente, você adicionaria aqui:
        // contato.getClientesInternal().add(this);
    }

    public void removeContato(Contato contato) {
        this.contatos.remove(contato);
        // contato.getClientesInternal().remove(this);
    }

    public void addEndereco(Endereco endereco) {
        this.enderecos.add(endereco);
        // endereco.getClientesInternal().add(this);
    }

    public void removeEndereco(Endereco endereco) {
        this.enderecos.remove(endereco);
        // endereco.getClientesInternal().remove(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Cliente cliente = (Cliente) o;
        return Objects.equals(idCliente, cliente.idCliente);
    }

    @Override
    public int hashCode() {
        return Objects.hash(idCliente);
    }

    @Override
    public String toString() {
        return "Cliente{" +
                "idCliente=" + idCliente +
                ", nome='" + nome + '\'' +
                ", sobrenome='" + sobrenome + '\'' +
                ", dataNascimento='" + dataNascimento + '\'' +
                ", documento='" + documento + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Contato.java | package br.com.fiap.gs.gsapi.model | class Contato
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "tb_contato3")
public class Contato {

    @Id
    @SequenceGenerator(name = "contato_seq", sequenceName = "tb_contato3_id_contato_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "contato_seq")
    @Column(name = "id_contato")
    private Long idContato; // Mapeia para id_contato NUMBER NOT NULL [cite: 8]

    @Column(name = "ddd", nullable = false, length = 3)
    private String ddd; // Mapeia para ddd VARCHAR2(3) NOT NULL [cite: 8]

    @Column(name = "telefone", nullable = false, length = 15)
    private String telefone; // Mapeia para telefone VARCHAR2(15) NOT NULL [cite: 8]

    @Column(name = "celular", nullable = false, length = 15)
    private String celular; // Mapeia para celular VARCHAR2(15) NOT NULL [cite: 8]

    @Column(name = "whatsapp", nullable = false, length = 15)
    private String whatsapp; // Mapeia para whatsapp VARCHAR2(15) NOT NULL [cite: 8]

    @Column(name = "email", nullable = false, length = 255)
    private String email; // Mapeia para email VARCHAR2(255) NOT NULL [cite: 8]

    @Column(name = "tipo_contato", nullable = false, length = 50)
    private String tipoContato; // Mapeia para tipo_contato VARCHAR2(50) NOT NULL [cite: 8]

    @ManyToMany(mappedBy = "contatos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    // Construtor padrão
    public Contato() {
    }

    // Construtor para criar um novo contato
    public Contato(String ddd, String telefone, String celular, String whatsapp, String email, String tipoContato) {
        this.ddd = ddd;
        this.telefone = telefone;
        this.celular = celular;
        this.whatsapp = whatsapp;
        this.email = email;
        this.tipoContato = tipoContato;
    }

    // Getters e Setters
    public Long getIdContato() {
        return idContato;
    }

    public void setIdContato(Long idContato) {
        this.idContato = idContato;
    }

    public String getDdd() {
        return ddd;
    }

    public void setDdd(String ddd) {
        this.ddd = ddd;
    }

    public String getTelefone() {
        return telefone;
    }

    public void setTelefone(String telefone) {
        this.telefone = telefone;
    }

    public String getCelular() {
        return celular;
    }

    public void setCelular(String celular) {
        this.celular = celular;
    }

    public String getWhatsapp() {
        return whatsapp;
    }

    public void setWhatsapp(String whatsapp) {
        this.whatsapp = whatsapp;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getTipoContato() {
        return tipoContato;
    }

    public void setTipoContato(String tipoContato) {
        this.tipoContato = tipoContato;
    }

    public Set<Cliente> getClientes() {
        return clientes;
    }

    public void setClientes(Set<Cliente> clientes) {
        this.clientes = clientes;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Contato contato = (Contato) o;
        return Objects.equals(idContato, contato.idContato);
    }

    @Override
    public int hashCode() {
        return Objects.hash(idContato);
    }

    @Override
    public String toString() {
        return "Contato{" +
                "idContato=" + idContato +
                ", ddd='" + ddd + '\'' +
                ", telefone='" + telefone + '\'' +
                ", celular='" + celular + '\'' +
                ", whatsapp='" + whatsapp + '\'' +
                ", email='" + email + '\'' +
                ", tipoContato='" + tipoContato + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Endereco.java | package br.com.fiap.gs.gsapi.model | class Endereco
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "tb_endereco3")
public class Endereco {

    @Id
    @SequenceGenerator(name = "endereco_seq", sequenceName = "tb_endereco3_id_endereco_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "endereco_seq")
    @Column(name = "id_endereco")
    private Long idEndereco; // Mapeia para id_endereco NUMBER NOT NULL [cite: 10]

    @Column(name = "cep", nullable = false, length = 9)
    private String cep; // Mapeia para cep VARCHAR2(9) NOT NULL [cite: 10]

    @Column(name = "numero", nullable = false)
    private Integer numero; // Mapeia para numero NUMBER(5) NOT NULL [cite: 10]

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Mapeia para logradouro VARCHAR2(255) NOT NULL [cite: 10]

    @Column(name = "bairro", nullable = false, length = 255)
    private String bairro; // Mapeia para bairro VARCHAR2(255) NOT NULL [cite: 10]

    @Column(name = "localidade", nullable = false, length = 100)
    private String localidade; // Mapeia para localidade VARCHAR2(100) NOT NULL [cite: 10]

    @Column(name = "uf", nullable = false, length = 2)
    private String uf; // Mapeia para uf VARCHAR2(2) NOT NULL [cite: 10]

    @Column(name = "complemento", nullable = false, length = 255)
    private String complemento; // Mapeia para complemento VARCHAR2(255) NOT NULL [cite: 10]

    @Column(name = "latitude", nullable = false, precision = 10, scale = 7)
    private Double latitude; // Mapeia para latitude NUMBER(10,7) NOT NULL [cite: 10]

    @Column(name = "longitude", nullable = false, precision = 10, scale = 7)
    private Double longitude; // Mapeia para longitude NUMBER(10,7) NOT NULL [cite: 11]

    @ManyToMany(mappedBy = "enderecos", fetch = FetchType.LAZY)
    private Set<Cliente> clientes = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY,
            cascade = {
                    CascadeType.PERSIST,
                    CascadeType.MERGE
            })
    @JoinTable(name = "tb_enderecoeventos3", // Tabela de junção [cite: 13]
            joinColumns = { @JoinColumn(name = "tb_endereco3_id_endereco") }, // FK para tb_endereco3 [cite: 13, 21]
            inverseJoinColumns = { @JoinColumn(name = "tb_eonet3_id_eonet") }) // FK para tb_eonet3 [cite: 13, 22]
    private Set<Eonet> eventosEonet = new HashSet<>();

    // Construtor padrão
    public Endereco() {
    }

    // Construtor para criar um novo endereço
    public Endereco(String cep, Integer numero, String logradouro, String bairro, String localidade, String uf, String complemento, Double latitude, Double longitude) {
        this.cep = cep;
        this.numero = numero;
        this.logradouro = logradouro;
        this.bairro = bairro;
        this.localidade = localidade;
        this.uf = uf;
        this.complemento = complemento;
        this.latitude = latitude;
        this.longitude = longitude;
    }

    // Getters e Setters
    public Long getIdEndereco() {
        return idEndereco;
    }

    public void setIdEndereco(Long idEndereco) {
        this.idEndereco = idEndereco;
    }

    public String getCep() {
        return cep;
    }

    public void setCep(String cep) {
        this.cep = cep;
    }

    public Integer getNumero() {
        return numero;
    }

    public void setNumero(Integer numero) {
        this.numero = numero;
    }

    public String getLogradouro() {
        return logradouro;
    }

    public void setLogradouro(String logradouro) {
        this.logradouro = logradouro;
    }

    public String getBairro() {
        return bairro;
    }

    public void setBairro(String bairro) {
        this.bairro = bairro;
    }

    public String getLocalidade() {
        return localidade;
    }

    public void setLocalidade(String localidade) {
        this.localidade = localidade;
    }

    public String getUf() {
        return uf;
    }

    public void setUf(String uf) {
        this.uf = uf;
    }

    public String getComplemento() {
        return complemento;
    }

    public void setComplemento(String complemento) {
        this.complemento = complemento;
    }

    public Double getLatitude() {
        return latitude;
    }

    public void setLatitude(Double latitude) {
        this.latitude = latitude;
    }

    public Double getLongitude() {
        return longitude;
    }

    public void setLongitude(Double longitude) {
        this.longitude = longitude;
    }

    public Set<Cliente> getClientes() {
        return clientes;
    }

    public void setClientes(Set<Cliente> clientes) {
        this.clientes = clientes;
    }

    public Set<Eonet> getEventosEonet() {
        return eventosEonet;
    }

    public void setEventosEonet(Set<Eonet> eventosEonet) {
        this.eventosEonet = eventosEonet;
    }

    // Métodos auxiliares
    public void addEventoEonet(Eonet evento) {
        this.eventosEonet.add(evento);
        // evento.getEnderecosInternal().add(this);
    }

    public void removeEventoEonet(Eonet evento) {
        this.eventosEonet.remove(evento);
        // evento.getEnderecosInternal().remove(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Endereco endereco = (Endereco) o;
        return Objects.equals(idEndereco, endereco.idEndereco);
    }

    @Override
    public int hashCode() {
        return Objects.hash(idEndereco);
    }

    @Override
    public String toString() {
        return "Endereco{" +
                "idEndereco=" + idEndereco +
                ", cep='" + cep + '\'' +
                ", numero=" + numero +
                ", logradouro='" + logradouro + '\'' +
                ", bairro='" + bairro + '\'' +
                ", localidade='" + localidade + '\'' +
                ", uf='" + uf + '\'' +
                ", complemento='" + complemento + '\'' +
                ", latitude=" + latitude +
                ", longitude=" + longitude +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\model\Eonet.java | package br.com.fiap.gs.gsapi.model | class Eonet
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.model;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Lob;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;
import java.time.OffsetDateTime;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

@Entity
@Table(name = "tb_eonet3")
public class Eonet {

    @Id
    @SequenceGenerator(name = "eonet_seq", sequenceName = "tb_eonet3_id_eonet_seq", allocationSize = 1)
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "eonet_seq")
    @Column(name = "id_eonet")
    private Long idEonet; // Mapeia para id_eonet NUMBER NOT NULL [cite: 15]

    @Lob // Indica que é um Large Object (CLOB neste caso)
    @Column(name = "json", columnDefinition = "CLOB") // Mapeia para json CLOB NULL [cite: 15]
    private String json;

    @Column(name = "data") // Mapeia para data TIMESTAMP WITH LOCAL TIME ZONE NULL [cite: 15]
    private OffsetDateTime data;

    @Column(name = "eonet_id", nullable = false, length = 50)
    private String eonetIdApi; // Mapeia para eonet_id VARCHAR2(50) NOT NULL [cite: 15]

    @ManyToMany(mappedBy = "eventosEonet", fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>();

    // Construtor padrão
    public Eonet() {
    }

    // Construtor para criar um novo evento EONET
    public Eonet(String json, OffsetDateTime data, String eonetIdApi) {
        this.json = json;
        this.data = data;
        this.eonetIdApi = eonetIdApi;
    }

    // Outro construtor, caso json e data sejam opcionais na criação inicial
    public Eonet(String eonetIdApi) {
        this.eonetIdApi = eonetIdApi;
    }

    // Getters e Setters
    public Long getIdEonet() {
        return idEonet;
    }

    public void setIdEonet(Long idEonet) {
        this.idEonet = idEonet;
    }

    public String getJson() {
        return json;
    }

    public void setJson(String json) {
        this.json = json;
    }

    public OffsetDateTime getData() {
        return data;
    }

    public void setData(OffsetDateTime data) {
        this.data = data;
    }

    public String getEonetIdApi() {
        return eonetIdApi;
    }

    public void setEonetIdApi(String eonetIdApi) {
        this.eonetIdApi = eonetIdApi;
    }

    public Set<Endereco> getEnderecos() {
        return enderecos;
    }

    public void setEnderecos(Set<Endereco> enderecos) {
        this.enderecos = enderecos;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Eonet eonet = (Eonet) o;
        return Objects.equals(idEonet, eonet.idEonet);
    }

    @Override
    public int hashCode() {
        return Objects.hash(idEonet);
    }

    @Override
    public String toString() {
        return "Eonet{" +
                "idEonet=" + idEonet +
                ", json='" + (json != null && json.length() > 50 ? json.substring(0, 50) + "..." : json) + '\'' +
                ", data=" + data +
                ", eonetIdApi='" + eonetIdApi + '\'' +
                '}';
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\ClienteRepository.java | package br.com.fiap.gs.gsapi.repository | class ClienteRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Cliente;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ClienteRepository extends JpaRepository<Cliente, Long> {

    /**
     * Busca um cliente pelo seu documento (CPF/CNPJ).
     * @param documento O número do documento.
     * @return Um Optional contendo o cliente se encontrado, ou vazio caso contrário.
     */
    Optional<Cliente> findByDocumento(String documento);

    /**
     * Busca clientes cujo nome contenha a string fornecida, ignorando maiúsculas/minúsculas,
     * com suporte a paginação.
     * @param nome Parte do nome a ser buscado.
     * @param pageable Objeto de paginação.
     * @return Uma página de clientes que correspondem ao critério.
     */
    Page<Cliente> findByNomeContainingIgnoreCase(String nome, Pageable pageable);

    /**
     * Exemplo de busca customizada usando JPQL para encontrar clientes
     * por parte do nome ou sobrenome, ignorando maiúsculas/minúsculas, com paginação.
     * @param termo O termo a ser buscado no nome ou sobrenome.
     * @param pageable Objeto de paginação.
     * @return Uma página de clientes que correspondem ao critério.
     */
    @Query("SELECT c FROM Cliente c WHERE lower(c.nome) LIKE lower(concat('%', :termo, '%')) OR lower(c.sobrenome) LIKE lower(concat('%', :termo, '%'))")
    Page<Cliente> searchByNomeOrSobrenome(@Param("termo") String termo, Pageable pageable);

}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\ContatoRepository.java | package br.com.fiap.gs.gsapi.repository | class ContatoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Contato;
import org.springframework.data.domain.Page; // Import necessário
import org.springframework.data.domain.Pageable; // Import necessário
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ContatoRepository extends JpaRepository<Contato, Long> {

    /**
     * Busca um contato pelo seu endereço de e-mail.
     * @param email O e-mail a ser buscado.
     * @return Um Optional contendo o contato se encontrado.
     */
    Optional<Contato> findByEmail(String email);

    /**
     * Busca contatos por tipo, ignorando maiúsculas/minúsculas. (Versão que retorna Lista)
     * @param tipoContato O tipo de contato (ex: "COMERCIAL", "PESSOAL").
     * @return Uma lista de contatos que correspondem ao tipo.
     */
    List<Contato> findByTipoContatoIgnoreCase(String tipoContato); // Método original que retorna List

    /**
     * Busca contatos por tipo, ignorando maiúsculas/minúsculas, com suporte a paginação.
     * @param tipoContato O tipo de contato (ex: "COMERCIAL", "PESSOAL").
     * @param pageable Objeto de paginação.
     * @return Uma página de contatos que correspondem ao tipo.
     */
    Page<Contato> findByTipoContatoIgnoreCase(String tipoContato, Pageable pageable); // Novo método com Pageable
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\EnderecoRepository.java | package br.com.fiap.gs.gsapi.repository | class EnderecoRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Endereco;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface EnderecoRepository extends JpaRepository<Endereco, Long> {

    /**
     * Busca endereços por CEP.
     * @param cep O CEP a ser buscado.
     * @return Uma lista de endereços que correspondem ao CEP.
     */
    List<Endereco> findByCep(String cep);

    /**
     * Busca um endereço específico pela combinação de logradouro e número.
     * @param logradouro O logradouro do endereço.
     * @param numero O número do endereço.
     * @return Um Optional contendo o endereço se encontrado.
     */
    Optional<Endereco> findByLogradouroAndNumero(String logradouro, Integer numero);

    /**
     * Busca endereços por UF (Estado), com suporte a paginação.
     * @param uf A sigla do Estado (UF).
     * @param pageable Objeto de paginação.
     * @return Uma página de endereços que correspondem à UF.
     */
    Page<Endereco> findByUfIgnoreCase(String uf, Pageable pageable);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\repository\EonetRepository.java | package br.com.fiap.gs.gsapi.repository | class EonetRepository
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.repository;

import br.com.fiap.gs.gsapi.model.Eonet;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface EonetRepository extends JpaRepository<Eonet, Long> {

    /**
     * Busca um evento EONET pelo seu ID único da API externa.
     * @param eonetIdApi O ID do evento fornecido pela API EONET.
     * @return Um Optional contendo o evento se encontrado.
     */
    Optional<Eonet> findByEonetIdApi(String eonetIdApi);

    /**
     * Busca eventos EONET dentro de um intervalo de datas.
     * @param dataInicial Data inicial do intervalo.
     * @param dataFinal Data final do intervalo.
     * @return Uma lista de eventos EONET dentro do intervalo especificado.
     */
    List<Eonet> findByDataBetween(OffsetDateTime dataInicial, OffsetDateTime dataFinal);
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\ClienteService.java | package br.com.fiap.gs.gsapi.service | class ClienteService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.ClienteRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ClienteResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.ClienteMapper;
import br.com.fiap.gs.gsapi.model.Cliente;
import br.com.fiap.gs.gsapi.model.Contato;
import br.com.fiap.gs.gsapi.model.Endereco;
import br.com.fiap.gs.gsapi.repository.ClienteRepository;
import br.com.fiap.gs.gsapi.repository.ContatoRepository;
import br.com.fiap.gs.gsapi.repository.EnderecoRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class ClienteService {

    private final ClienteRepository clienteRepository;
    private final ContatoRepository contatoRepository;
    private final EnderecoRepository enderecoRepository;
    private final ClienteMapper clienteMapper; // Mapper injetado

    @Autowired
    public ClienteService(ClienteRepository clienteRepository,
                          ContatoRepository contatoRepository,
                          EnderecoRepository enderecoRepository,
                          ClienteMapper clienteMapper) { // Construtor com todas as dependências
        this.clienteRepository = clienteRepository;
        this.contatoRepository = contatoRepository;
        this.enderecoRepository = enderecoRepository;
        this.clienteMapper = clienteMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "clientes", key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<ClienteResponseDTO> listarTodos(Pageable pageable) {
        Page<Cliente> clientesPage = clienteRepository.findAll(pageable);
        return clientesPage.map(clienteMapper::toResponseDTO); // Usando o mapper
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "clienteById", key = "#id")
    public ClienteResponseDTO buscarPorId(Long id) {
        Cliente cliente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com o ID: " + id));
        return clienteMapper.toResponseDTO(cliente); // Usando o mapper
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "clienteByDocumento", key = "#documento")
    public ClienteResponseDTO buscarPorDocumento(String documento) {
        Cliente cliente = clienteRepository.findByDocumento(documento)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com o documento: " + documento));
        return clienteMapper.toResponseDTO(cliente); // Usando o mapper
    }

    @Transactional
    @CacheEvict(value = {"clientes", "clienteById", "clienteByDocumento", "clientesSearch"}, allEntries = true)
    public ClienteResponseDTO criarCliente(ClienteRequestDTO clienteRequestDTO) {
        if (clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).isPresent()) {
            throw new IllegalArgumentException("Já existe um cliente cadastrado com o documento: " + clienteRequestDTO.getDocumento());
        }

        Cliente cliente = clienteMapper.toEntity(clienteRequestDTO); // Usando o mapper para campos básicos

        // Associar contatos existentes (lógica mantida no serviço)
        if (clienteRequestDTO.getContatosIds() != null && !clienteRequestDTO.getContatosIds().isEmpty()) {
            Set<Contato> contatos = new HashSet<>(contatoRepository.findAllById(clienteRequestDTO.getContatosIds()));
            if (contatos.size() != clienteRequestDTO.getContatosIds().size()) {
                // Coleta os IDs não encontrados para uma mensagem de erro mais detalhada
                Set<Long> foundIds = contatos.stream().map(Contato::getIdContato).collect(Collectors.toSet());
                Set<Long> notFoundIds = clienteRequestDTO.getContatosIds().stream()
                        .filter(id -> !foundIds.contains(id))
                        .collect(Collectors.toSet());
                throw new ResourceNotFoundException("Um ou mais IDs de Contato não foram encontrados: " + notFoundIds);
            }
            cliente.setContatos(contatos);
        } else {
            cliente.setContatos(new HashSet<>()); // Garante que a coleção não seja nula
        }

        // Associar endereços existentes (lógica mantida no serviço)
        if (clienteRequestDTO.getEnderecosIds() != null && !clienteRequestDTO.getEnderecosIds().isEmpty()) {
            Set<Endereco> enderecos = new HashSet<>(enderecoRepository.findAllById(clienteRequestDTO.getEnderecosIds()));
            if (enderecos.size() != clienteRequestDTO.getEnderecosIds().size()) {
                Set<Long> foundIds = enderecos.stream().map(Endereco::getIdEndereco).collect(Collectors.toSet());
                Set<Long> notFoundIds = clienteRequestDTO.getEnderecosIds().stream()
                        .filter(id -> !foundIds.contains(id))
                        .collect(Collectors.toSet());
                throw new ResourceNotFoundException("Um ou mais IDs de Endereço não foram encontrados: " + notFoundIds);
            }
            cliente.setEnderecos(enderecos);
        } else {
            cliente.setEnderecos(new HashSet<>()); // Garante que a coleção não seja nula
        }

        Cliente clienteSalvo = clienteRepository.save(cliente);
        return clienteMapper.toResponseDTO(clienteSalvo); // Usando o mapper
    }

    @Transactional
    @CachePut(value = "clienteById", key = "#id") // Atualiza o cache para este ID
    @CacheEvict(value = {"clientes", "clienteByDocumento", "clientesSearch"}, allEntries = true) // Invalida outros caches relacionados
    public ClienteResponseDTO atualizarCliente(Long id, ClienteRequestDTO clienteRequestDTO) {
        Cliente clienteExistente = clienteRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Cliente não encontrado com o ID: " + id));

        if (!clienteExistente.getDocumento().equals(clienteRequestDTO.getDocumento()) &&
                clienteRepository.findByDocumento(clienteRequestDTO.getDocumento()).isPresent()) {
            throw new IllegalArgumentException("Já existe outro cliente cadastrado com o documento: " + clienteRequestDTO.getDocumento());
        }

        // Atualiza os campos básicos usando o mapper ou manualmente se preferir controle fino
        // MapStruct pode atualizar uma entidade existente também com @MappingTarget
        // Por simplicidade aqui, faremos manualmente para os campos da entidade principal:
        clienteExistente.setNome(clienteRequestDTO.getNome());
        clienteExistente.setSobrenome(clienteRequestDTO.getSobrenome());
        clienteExistente.setDataNascimento(clienteRequestDTO.getDataNascimento());
        clienteExistente.setDocumento(clienteRequestDTO.getDocumento());

        // Atualizar associações de contatos (lógica mantida no serviço)
        if (clienteRequestDTO.getContatosIds() != null) {
            if (clienteRequestDTO.getContatosIds().isEmpty()){
                clienteExistente.getContatos().clear();
            } else {
                Set<Contato> contatos = new HashSet<>(contatoRepository.findAllById(clienteRequestDTO.getContatosIds()));
                if (contatos.size() != clienteRequestDTO.getContatosIds().size()) {
                    Set<Long> foundIds = contatos.stream().map(Contato::getIdContato).collect(Collectors.toSet());
                    Set<Long> notFoundIds = clienteRequestDTO.getContatosIds().stream()
                            .filter(contactId -> !foundIds.contains(contactId))
                            .collect(Collectors.toSet());
                    throw new ResourceNotFoundException("Um ou mais IDs de Contato fornecidos para atualização não foram encontrados: " + notFoundIds);
                }
                clienteExistente.setContatos(contatos);
            }
        }

        // Atualizar associações de endereços (lógica mantida no serviço)
        if (clienteRequestDTO.getEnderecosIds() != null) {
            if (clienteRequestDTO.getEnderecosIds().isEmpty()){
                clienteExistente.getEnderecos().clear();
            } else {
                Set<Endereco> enderecos = new HashSet<>(enderecoRepository.findAllById(clienteRequestDTO.getEnderecosIds()));
                if (enderecos.size() != clienteRequestDTO.getEnderecosIds().size()) {
                    Set<Long> foundIds = enderecos.stream().map(Endereco::getIdEndereco).collect(Collectors.toSet());
                    Set<Long> notFoundIds = clienteRequestDTO.getEnderecosIds().stream()
                            .filter(addressId -> !foundIds.contains(addressId))
                            .collect(Collectors.toSet());
                    throw new ResourceNotFoundException("Um ou mais IDs de Endereço fornecidos para atualização não foram encontrados: " + notFoundIds);
                }
                clienteExistente.setEnderecos(enderecos);
            }
        }

        Cliente clienteAtualizado = clienteRepository.save(clienteExistente);
        return clienteMapper.toResponseDTO(clienteAtualizado); // Usando o mapper
    }

    @Transactional
    @CacheEvict(value = {"clientes", "clienteById", "clienteByDocumento", "clientesSearch"}, allEntries = true)
    public void deletarCliente(Long id) {
        if (!clienteRepository.existsById(id)) {
            throw new ResourceNotFoundException("Cliente não encontrado com o ID: " + id);
        }
        clienteRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "clientesSearch", key = "#termo + '-' + #pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<ClienteResponseDTO> pesquisarClientes(String termo, Pageable pageable) {
        Page<Cliente> clientesPage = clienteRepository.searchByNomeOrSobrenome(termo, pageable);
        return clientesPage.map(clienteMapper::toResponseDTO); // Usando o mapper
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\ContatoService.java | package br.com.fiap.gs.gsapi.service | class ContatoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.ContatoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.ContatoResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.ContatoMapper;
import br.com.fiap.gs.gsapi.model.Contato;
import br.com.fiap.gs.gsapi.repository.ContatoRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class ContatoService {

    private final ContatoRepository contatoRepository;
    private final ContatoMapper contatoMapper; // Mapper injetado

    @Autowired
    public ContatoService(ContatoRepository contatoRepository, ContatoMapper contatoMapper) { // Construtor
        this.contatoRepository = contatoRepository;
        this.contatoMapper = contatoMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatos", key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<ContatoResponseDTO> listarTodos(Pageable pageable) {
        Page<Contato> contatosPage = contatoRepository.findAll(pageable);
        return contatosPage.map(contatoMapper::toResponseDTO); // Usando o mapper
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatoById", key = "#id")
    public ContatoResponseDTO buscarPorId(Long id) {
        Contato contato = contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com o ID: " + id));
        return contatoMapper.toResponseDTO(contato); // Usando o mapper
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatoByEmail", key = "#email")
    public ContatoResponseDTO buscarPorEmail(String email) {
        Contato contato = contatoRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com o e-mail: " + email));
        return contatoMapper.toResponseDTO(contato);
    }

    @Transactional
    @CacheEvict(value = {"contatos", "contatoById", "contatoByEmail"}, allEntries = true)
    public ContatoResponseDTO criarContato(ContatoRequestDTO contatoRequestDTO) {
        // Validação de e-mail duplicado (exemplo de regra de negócio)
        if (contatoRepository.findByEmail(contatoRequestDTO.getEmail()).isPresent()) {
            throw new IllegalArgumentException("Já existe um contato cadastrado com o e-mail: " + contatoRequestDTO.getEmail());
        }

        Contato contato = contatoMapper.toEntity(contatoRequestDTO); // Usando o mapper
        // A associação com Cliente é feita através do ClienteService ou por endpoints específicos
        // de associação, não diretamente aqui na criação isolada de um contato.
        Contato contatoSalvo = contatoRepository.save(contato);
        return contatoMapper.toResponseDTO(contatoSalvo); // Usando o mapper
    }

    @Transactional
    @CachePut(value = "contatoById", key = "#id")
    @CacheEvict(value = {"contatos", "contatoByEmail"}, allEntries = true)
    public ContatoResponseDTO atualizarContato(Long id, ContatoRequestDTO contatoRequestDTO) {
        Contato contatoExistente = contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com o ID: " + id));

        // Validação para não alterar o e-mail para um já existente em outro contato
        if (!contatoExistente.getEmail().equalsIgnoreCase(contatoRequestDTO.getEmail()) &&
                contatoRepository.findByEmail(contatoRequestDTO.getEmail()).isPresent()) {
            throw new IllegalArgumentException("Já existe outro contato cadastrado com o e-mail: " + contatoRequestDTO.getEmail());
        }

        // Atualiza os campos da entidade existente
        // Poderia usar MapStruct com @MappingTarget: contatoMapper.updateEntityFromDto(contatoRequestDTO, contatoExistente);
        contatoExistente.setDdd(contatoRequestDTO.getDdd());
        contatoExistente.setTelefone(contatoRequestDTO.getTelefone());
        contatoExistente.setCelular(contatoRequestDTO.getCelular());
        contatoExistente.setWhatsapp(contatoRequestDTO.getWhatsapp());
        contatoExistente.setEmail(contatoRequestDTO.getEmail());
        contatoExistente.setTipoContato(contatoRequestDTO.getTipoContato());

        Contato contatoAtualizado = contatoRepository.save(contatoExistente);
        return contatoMapper.toResponseDTO(contatoAtualizado); // Usando o mapper
    }

    @Transactional
    @CacheEvict(value = {"contatos", "contatoById", "contatoByEmail"}, allEntries = true)
    public void deletarContato(Long id) {
        Contato contato = contatoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Contato não encontrado com o ID: " + id));

        // Antes de deletar, é importante considerar as associações com Cliente.
        // A exclusão de um Contato aqui removerá o registro da tb_contato3. [cite: 8]
        // As entradas na tabela de junção tb_clientecontato3 [cite: 4] que referenciam este contato
        // também devem ser removidas. O provedor JPA (Hibernate) geralmente cuida disso
        // se o relacionamento ManyToMany for corretamente configurado (especialmente do lado do Cliente).
        // Se um contato for deletado, os Clientes associados não serão deletados, apenas a associação será desfeita.
        if (!contato.getClientes().isEmpty()) {
            // Poderia lançar uma exceção se a regra de negócio impedir deletar contato associado,
            // ou desassociar programaticamente (embora a JPA deva cuidar disso ao remover da coleção em Cliente ou pela FK).
            // Ex: throw new IllegalStateException("Não é possível deletar contato pois está associado a clientes.");
            // Ou, limpar as associações nos clientes se necessário (geralmente não é feito aqui).
        }
        contatoRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "contatosPorTipo", key = "#tipoContato + '-' + #pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<ContatoResponseDTO> buscarPorTipoContato(String tipoContato, Pageable pageable) {
        // Supondo que você crie um método no ContatoRepository:
        // Page<Contato> findByTipoContatoIgnoreCase(String tipoContato, Pageable pageable);
        // Se não, pode ser List<Contato> e você faz a paginação manualmente (menos ideal)
        // ou ajusta o repositório.
        // Por ora, vou usar o método que retorna List e adaptar, ou sugerir a criação do método paginável.
        // Para este exemplo, vou assumir que você adicionará o método paginável ao repositório:
        // Page<Contato> contatosPage = contatoRepository.findByTipoContatoIgnoreCase(tipoContato, pageable);
        // return contatosPage.map(contatoMapper::toResponseDTO);

        // Se o método no repositório for List<Contato> findByTipoContatoIgnoreCase(String tipoContato);
        List<ContatoResponseDTO> listaContatos = contatoRepository.findByTipoContatoIgnoreCase(tipoContato)
                .stream()
                .map(contatoMapper::toResponseDTO)
                .collect(Collectors.toList());
        // A conversão para Page aqui seria manual e mais complexa. É melhor ter o método paginado no repositório.
        // Se você adicionar Page<Contato> findByTipoContatoIgnoreCase(String tipoContato, Pageable pageable)
        // no ContatoRepository, o código acima (comentado) é o ideal.
        // Por enquanto, vou deixar como está, mas recomendo o ajuste no repositório para paginação correta.

        // Para fins de exemplo e para não falhar, se o método no repo for List:
        // Este retorno não é paginado, mas demonstra a busca.
        // return new PageImpl<>(listaContatos, pageable, listaContatos.size());
        // O ideal é:
        // Page<Contato> page = contatoRepository.findByTipoContatoIgnoreCase(tipoContato, pageable);
        // return page.map(contatoMapper::toResponseDTO);
        // Para isso, o ContatoRepository precisaria de:
        // Page<Contato> findByTipoContatoIgnoreCase(String tipoContato, Pageable pageable);
        // Vou assumir que você adicionará esse método ao ContatoRepository.
        // Se não for adicionado, este método do serviço precisará de ajustes ou não suportará paginação corretamente.
        // throw new UnsupportedOperationException("Paginable findByTipoContatoIgnoreCase não implementado no repositório.");

        // Assumindo que ContatoRepository.findByTipoContatoIgnoreCase(tipoContato, pageable) existe:
        Page<Contato> contatosPage = contatoRepository.findByTipoContatoIgnoreCase(tipoContato, pageable); // Supondo que este método foi adicionado ao ContatoRepository
        return contatosPage.map(contatoMapper::toResponseDTO);
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\EnderecoService.java | package br.com.fiap.gs.gsapi.service | class EnderecoService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.client.GeoCodingClient; // Importar
import br.com.fiap.gs.gsapi.client.ViaCepClient;
import br.com.fiap.gs.gsapi.dto.external.NominatimResponseDTO; // Importar
import br.com.fiap.gs.gsapi.dto.external.ViaCepResponseDTO;
import br.com.fiap.gs.gsapi.dto.request.EnderecoGeoRequestDTO; // Importar
import br.com.fiap.gs.gsapi.dto.request.EnderecoRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EnderecoResponseDTO;
import br.com.fiap.gs.gsapi.dto.response.GeoCoordinatesDTO; // Importar
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.exception.ServiceUnavailableException;
import br.com.fiap.gs.gsapi.mapper.EnderecoMapper;
import br.com.fiap.gs.gsapi.model.Endereco;
import br.com.fiap.gs.gsapi.repository.EnderecoRepository;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.List;

@Service
public class EnderecoService {

    private static final Logger logger = LoggerFactory.getLogger(EnderecoService.class);

    private final EnderecoRepository enderecoRepository;
    private final EnderecoMapper enderecoMapper;
    private final ViaCepClient viaCepClient;
    private final GeoCodingClient geoCodingClient; // Injetar o novo cliente

    @Autowired
    public EnderecoService(EnderecoRepository enderecoRepository,
                           EnderecoMapper enderecoMapper,
                           ViaCepClient viaCepClient,
                           GeoCodingClient geoCodingClient) { // Adicionar ao construtor
        this.enderecoRepository = enderecoRepository;
        this.enderecoMapper = enderecoMapper;
        this.viaCepClient = viaCepClient;
        this.geoCodingClient = geoCodingClient; // Atribuir
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "enderecos", key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<EnderecoResponseDTO> listarTodos(Pageable pageable) {
        Page<Endereco> enderecosPage = enderecoRepository.findAll(pageable);
        return enderecosPage.map(enderecoMapper::toResponseDTO);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "enderecoById", key = "#id")
    public EnderecoResponseDTO buscarPorId(Long id) {
        Endereco endereco = enderecoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Endereço não encontrado com o ID: " + id));
        return enderecoMapper.toResponseDTO(endereco);
    }

    @Transactional
    @CacheEvict(value = {"enderecos", "enderecoById", "enderecosPorCep"}, allEntries = true)
    public EnderecoResponseDTO criarEndereco(EnderecoRequestDTO enderecoRequestDTO) {
        Endereco endereco = enderecoMapper.toEntity(enderecoRequestDTO);

        endereco.setCep(formatarCep(endereco.getCep()));
        if (endereco.getUf() != null) {
            endereco.setUf(endereco.getUf().toUpperCase());
        }

        if (enderecoRequestDTO.getLatitude() == null || enderecoRequestDTO.getLongitude() == null) {
            throw new IllegalArgumentException("Latitude e Longitude são obrigatórias para criar um endereço.");
        }

        Endereco enderecoSalvo = enderecoRepository.save(endereco);
        return enderecoMapper.toResponseDTO(enderecoSalvo);
    }

    @Transactional
    @CachePut(value = "enderecoById", key = "#id")
    @CacheEvict(value = {"enderecos", "enderecosPorCep"}, allEntries = true)
    public EnderecoResponseDTO atualizarEndereco(Long id, EnderecoRequestDTO enderecoRequestDTO) {
        Endereco enderecoExistente = enderecoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Endereço não encontrado com o ID: " + id));

        enderecoExistente.setCep(formatarCep(enderecoRequestDTO.getCep()));
        enderecoExistente.setNumero(enderecoRequestDTO.getNumero());
        enderecoExistente.setLogradouro(enderecoRequestDTO.getLogradouro());
        enderecoExistente.setBairro(enderecoRequestDTO.getBairro());
        enderecoExistente.setLocalidade(enderecoRequestDTO.getLocalidade());
        if (enderecoRequestDTO.getUf() != null) {
            enderecoExistente.setUf(enderecoRequestDTO.getUf().toUpperCase());
        }
        enderecoExistente.setComplemento(enderecoRequestDTO.getComplemento());

        if (enderecoRequestDTO.getLatitude() == null || enderecoRequestDTO.getLongitude() == null) {
            throw new IllegalArgumentException("Latitude e Longitude são obrigatórias para atualizar um endereço.");
        }
        enderecoExistente.setLatitude(enderecoRequestDTO.getLatitude());
        enderecoExistente.setLongitude(enderecoRequestDTO.getLongitude());

        Endereco enderecoAtualizado = enderecoRepository.save(enderecoExistente);
        return enderecoMapper.toResponseDTO(enderecoAtualizado);
    }

    @Transactional
    @CacheEvict(value = {"enderecos", "enderecoById", "enderecosPorCep"}, allEntries = true)
    public void deletarEndereco(Long id) {
        if (!enderecoRepository.existsById(id)) {
            throw new ResourceNotFoundException("Endereço não encontrado com o ID: " + id);
        }
        enderecoRepository.deleteById(id);
    }

    private String formatarCep(String cep) {
        if (cep != null) {
            return cep.replaceAll("[^0-9]", "");
        }
        return null;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "viacepConsulta", key = "#cep")
    public ViaCepResponseDTO consultarDadosPorCep(String cep) {
        String cepFormatado = formatarCep(cep);
        if (cepFormatado == null || cepFormatado.length() != 8) {
            throw new IllegalArgumentException("Formato de CEP inválido. Use 8 dígitos numéricos.");
        }
        ViaCepResponseDTO viaCepData = viaCepClient.buscarEnderecoPorCep(cepFormatado);
        if (viaCepData == null || viaCepData.isErro()) {
            throw new ResourceNotFoundException("CEP " + cepFormatado + " não encontrado ou inválido.");
        }
        return viaCepData;
    }

    // Novo método para calcular coordenadas usando Nominatim
    @Transactional(readOnly = true)
    @Cacheable(value = "geoCoordenadas", key = "#enderecoGeoRequestDTO.toString()") // Chave de cache simples
    public GeoCoordinatesDTO calcularCoordenadasPorEndereco(EnderecoGeoRequestDTO enderecoGeoRequestDTO) {
        // Construir a query para o Nominatim
        StringBuilder queryBuilder = new StringBuilder();
        if (StringUtils.hasText(enderecoGeoRequestDTO.getLogradouro())) {
            queryBuilder.append(enderecoGeoRequestDTO.getLogradouro());
        }
        if (StringUtils.hasText(enderecoGeoRequestDTO.getNumero())) {
            queryBuilder.append(", ").append(enderecoGeoRequestDTO.getNumero());
        }
        if (StringUtils.hasText(enderecoGeoRequestDTO.getBairro())) {
            queryBuilder.append(", ").append(enderecoGeoRequestDTO.getBairro());
        }
        if (StringUtils.hasText(enderecoGeoRequestDTO.getCidade())) {
            queryBuilder.append(", ").append(enderecoGeoRequestDTO.getCidade());
        }
        if (StringUtils.hasText(enderecoGeoRequestDTO.getUf())) {
            queryBuilder.append(" - ").append(enderecoGeoRequestDTO.getUf());
        }
        if (StringUtils.hasText(enderecoGeoRequestDTO.getCep())) {
            queryBuilder.append(", CEP ").append(formatarCep(enderecoGeoRequestDTO.getCep()));
        }
        queryBuilder.append(", Brasil"); // Adicionar país pode ajudar

        String query = queryBuilder.toString().replaceFirst("^, ", ""); // Remove vírgula inicial se houver

        if (!StringUtils.hasText(query)) {
            throw new IllegalArgumentException("Dados insuficientes para geocodificação.");
        }

        logger.info("Iniciando geocodificação para query: {}", query);
        List<NominatimResponseDTO> nominatimResults = geoCodingClient.buscarCoordenadasPorEndereco(query);

        if (nominatimResults == null || nominatimResults.isEmpty()) {
            logger.warn("Nenhum resultado da geocodificação para a query: {}", query);
            throw new ResourceNotFoundException("Não foi possível encontrar coordenadas para o endereço fornecido.");
        }

        // Pega o primeiro resultado (geralmente o mais relevante)
        NominatimResponseDTO bestResult = nominatimResults.get(0);
        try {
            double latitude = Double.parseDouble(bestResult.getLatitude());
            double longitude = Double.parseDouble(bestResult.getLongitude());
            logger.info("Coordenadas encontradas para query '{}': Lat={}, Lon={}, Endereço Encontrado='{}'",
                    query, latitude, longitude, bestResult.getDisplayName());
            return new GeoCoordinatesDTO(latitude, longitude, bestResult.getDisplayName());
        } catch (NumberFormatException e) {
            logger.error("Erro ao converter lat/lon do Nominatim para double: lat={}, lon={}",
                    bestResult.getLatitude(), bestResult.getLongitude(), e);
            throw new ServiceUnavailableException("Formato de coordenadas inválido retornado pelo serviço de geocodificação.");
        }
    }
}

//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
// main\java\br\com\fiap\gs\gsapi\service\EonetService.java | package br.com.fiap.gs.gsapi.service | class EonetService
//――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――

package br.com.fiap.gs.gsapi.service;

import br.com.fiap.gs.gsapi.dto.request.EonetRequestDTO;
import br.com.fiap.gs.gsapi.dto.response.EonetResponseDTO;
import br.com.fiap.gs.gsapi.exception.ResourceNotFoundException;
import br.com.fiap.gs.gsapi.mapper.EonetMapper;
import br.com.fiap.gs.gsapi.model.Eonet;
import br.com.fiap.gs.gsapi.repository.EonetRepository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.CachePut;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class EonetService {

    private final EonetRepository eonetRepository;
    private final EonetMapper eonetMapper; // Mapper injetado

    @Autowired
    public EonetService(EonetRepository eonetRepository, EonetMapper eonetMapper) { // Construtor
        this.eonetRepository = eonetRepository;
        this.eonetMapper = eonetMapper;
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "eonetEventos", key = "#pageable.pageNumber + '-' + #pageable.pageSize + '-' + #pageable.sort.toString()")
    public Page<EonetResponseDTO> listarTodosEventos(Pageable pageable) {
        Page<Eonet> eventosPage = eonetRepository.findAll(pageable);
        return eventosPage.map(eonetMapper::toResponseDTO); // Usando o mapper
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "eonetEventoById", key = "#id")
    public EonetResponseDTO buscarEventoPorIdInterno(Long id) {
        Eonet evento = eonetRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Evento EONET não encontrado com o ID interno: " + id));
        return eonetMapper.toResponseDTO(evento); // Usando o mapper
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "eonetEventoByApiId", key = "#eonetApiId")
    public EonetResponseDTO buscarEventoPorEonetApiId(String eonetApiId) {
        Eonet evento = eonetRepository.findByEonetIdApi(eonetApiId)
                .orElseThrow(() -> new ResourceNotFoundException("Evento EONET não encontrado com o ID da API: " + eonetApiId));
        return eonetMapper.toResponseDTO(evento); // Usando o mapper
    }

    @Transactional
    @CacheEvict(value = {"eonetEventos", "eonetEventoById", "eonetEventoByApiId", "eonetEventosPorData"}, allEntries = true)
    public EonetResponseDTO salvarEvento(EonetRequestDTO eonetRequestDTO) {
        eonetRepository.findByEonetIdApi(eonetRequestDTO.getEonetIdApi()).ifPresent(existingEvent -> {
            throw new IllegalArgumentException("Já existe um evento EONET registrado com o API ID: " + eonetRequestDTO.getEonetIdApi());
        });

        Eonet evento = eonetMapper.toEntity(eonetRequestDTO); // Usando o mapper
        Eonet eventoSalvo = eonetRepository.save(evento);
        return eonetMapper.toResponseDTO(eventoSalvo); // Usando o mapper
    }

    @Transactional
    @CachePut(value = "eonetEventoById", key = "#idInterno") // Atualiza este cache
    // Considerar invalidar eonetEventoByApiId se o eonetApiId puder mudar e for chave de cache
    @CacheEvict(value = {"eonetEventos", "eonetEventoByApiId", "eonetEventosPorData"}, allEntries = true)
    public EonetResponseDTO atualizarEvento(Long idInterno, EonetRequestDTO eonetRequestDTO) {
        Eonet eventoExistente = eonetRepository.findById(idInterno)
                .orElseThrow(() -> new ResourceNotFoundException("Evento EONET não encontrado com o ID interno: " + idInterno));

        // Valida se o eonetIdApi está sendo alterado para um que já pertence a outro evento
        if (!eventoExistente.getEonetIdApi().equals(eonetRequestDTO.getEonetIdApi())) {
            eonetRepository.findByEonetIdApi(eonetRequestDTO.getEonetIdApi()).ifPresent(anotherEvent -> {
                if (!anotherEvent.getIdEonet().equals(idInterno)) {
                    throw new IllegalArgumentException("Já existe outro evento EONET registrado com o API ID: " + eonetRequestDTO.getEonetIdApi());
                }
            });
        }

        // Atualiza campos da entidade existente
        // Novamente, MapStruct com @MappingTarget seria ideal: eonetMapper.updateEntityFromDto(eonetRequestDTO, eventoExistente);
        eventoExistente.setEonetIdApi(eonetRequestDTO.getEonetIdApi());
        eventoExistente.setJson(eonetRequestDTO.getJson());
        eventoExistente.setData(eonetRequestDTO.getData());

        Eonet eventoAtualizado = eonetRepository.save(eventoExistente);
        return eonetMapper.toResponseDTO(eventoAtualizado); // Usando o mapper
    }

    @Transactional
    @CacheEvict(value = {"eonetEventos", "eonetEventoById", "eonetEventoByApiId", "eonetEventosPorData"}, allEntries = true)
    public void deletarEvento(Long idInterno) {
        if (!eonetRepository.existsById(idInterno)) {
            throw new ResourceNotFoundException("Evento EONET não encontrado com o ID interno: " + idInterno);
        }
        eonetRepository.deleteById(idInterno);
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "eonetEventosPorData", key = "#dataInicial.toString() + '-' + #dataFinal.toString()")
    public List<EonetResponseDTO> buscarEventosPorIntervaloDeData(OffsetDateTime dataInicial, OffsetDateTime dataFinal) {
        if (dataInicial == null || dataFinal == null || dataInicial.isAfter(dataFinal)) {
            throw new IllegalArgumentException("Datas inválidas para busca. Data inicial deve ser anterior à data final.");
        }
        List<Eonet> eventos = eonetRepository.findByDataBetween(dataInicial, dataFinal);
        return eventos.stream()
                .map(eonetMapper::toResponseDTO) // Usando o mapper
                .collect(Collectors.toList());
    }
}

